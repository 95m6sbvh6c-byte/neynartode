<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neynartodes - Main Launch Coming Soon</title>

  <!-- Farcaster Mini App Embed -->
  <meta name="fc:frame" content='{"version":"1","imageUrl":"https://frame-opal-eight.vercel.app/Neynartodes_1200x638_splash.png","button":{"title":"Launch NEYNARtodes","action":{"type":"launch_frame","name":"NEYNARtodes","url":"https://frame-opal-eight.vercel.app/app","splashImageUrl":"https://frame-opal-eight.vercel.app/Neynartodes_1200x638_splash.png","splashBackgroundColor":"#667eea"}}}' />

  <!-- Open Graph -->
  <meta property="og:title" content="NEYNARtodes - Season 0 Beta" />
  <meta property="og:description" content="Create contests on Farcaster!" />
  <meta property="og:image" content="https://frame-opal-eight.vercel.app/Neynartodes_1200x638_splash.png" />
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- QR Code library for signer approval (qrcodejs - browser compatible) -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

  <!-- Vercel Analytics -->
  <script type="module">
    import { inject, track } from 'https://esm.sh/@vercel/analytics';
    inject();
    window.analytics = { track };
  </script>

  <!-- Farcaster Mini App SDK - loads and signals when ready -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';

    window.FarcasterSDK = sdk;
    await sdk.actions.ready();

    // Splash audio will be handled in attachEventListeners (plays on first tap)

    // Wagmi will be loaded dynamically when needed (to not block app loading)
    window.WagmiLoaded = false;
    window.loadWagmi = async function() {
      if (window.WagmiLoaded) return true;
      try {
        console.log('Loading wagmi dynamically...');
        const [wagmiCore, wagmiChains, miniAppConnector] = await Promise.all([
          import('https://esm.sh/@wagmi/core@2'),
          import('https://esm.sh/@wagmi/core@2/chains'),
          import('https://esm.sh/@farcaster/miniapp-wagmi-connector')
        ]);

        const { createConfig, connect, disconnect, getAccount, sendTransaction, parseEther, http } = wagmiCore;
        const { base } = wagmiChains;
        const { farcasterMiniApp } = miniAppConnector;

        // IMPORTANT: Instantiate connector ONCE and reuse it
        const ff = farcasterMiniApp();
        console.log('Using farcasterMiniApp connector');

        // Create wagmi config with the single connector instance
        const wagmiConfig = createConfig({
          chains: [base],
          connectors: [ff],
          transports: {
            [base.id]: http()
          }
        });

        // Store for use in click handler
        window.WagmiConfig = wagmiConfig;
        window.FrameConnector = ff;
        window.WagmiConnect = connect;
        window.WagmiDisconnect = disconnect;
        window.WagmiGetAccount = getAccount;
        window.WagmiSendTransaction = sendTransaction;
        window.WagmiParseEther = parseEther;
        window.WagmiLoaded = true;
        console.log('Wagmi loaded successfully');
        return true;
      } catch (e) {
        console.error('Wagmi load failed:', e);
        return false;
      }
    };

    // Try to get context
    try {
      const context = await sdk.context;
      window.FarcasterContext = context;
      console.log('Farcaster context:', context);
      if (context?.user) {
        window.FarcasterUser = context.user;
        console.log('Farcaster user:', context.user);
      }

      // Check for notification details and store them
      const notifDetails = context?.client?.notificationDetails;
      const userFid = context?.user?.fid;
      const hadNotifsBefore = localStorage.getItem('neynartodes_notifs_enabled') === 'true';

      if (notifDetails?.token && notifDetails?.url && userFid) {
        console.log('Found notification details, storing...');
        window.NotificationsEnabled = true;
        localStorage.setItem('neynartodes_notifs_enabled', 'true');
        try {
          await fetch('/api/webhook', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              event: 'notifications_enabled',
              fid: userFid,
              notificationDetails: {
                token: notifDetails.token,
                url: notifDetails.url,
              },
            }),
          });
          console.log('Notification token stored for FID', userFid);
        } catch (e) {
          console.log('Could not store notification token:', e);
        }
      } else {
        console.log('No notification details found - notifications may be disabled');
        window.NotificationsEnabled = false;

        // If user previously had notifications, they got reset - show prompt
        if (hadNotifsBefore) {
          console.log('User had notifications before - they were reset by deployment');
          window.NotificationsWereReset = true;
        }
      }
    } catch (e) {
      console.log('Could not get Farcaster context:', e);
      window.NotificationsEnabled = false;
    }

    // Check for contestId - main script runs first and may have stored it
    // Also check URL params and SDK context as fallbacks
    let contestIdParam = window.PendingContestEntry || null;

    // Fallback: check URL params (in case they haven't been cleaned yet)
    if (!contestIdParam) {
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('action') === 'enter') {
        contestIdParam = urlParams.get('contestId');
      }
    }

    // Fallback: check sessionStorage
    if (!contestIdParam) {
      contestIdParam = sessionStorage.getItem('pendingEnterContest');
    }

    console.log('Primary button check - contestId:', contestIdParam);

    if (contestIdParam) {
      console.log('Contest entry mode: setting up primary button for contest', contestIdParam);
      window.PendingContestId = contestIdParam;

      // Set up the primary button
      try {
        await sdk.actions.setPrimaryButton({
          text: 'Enter Raffle ðŸŽ°',
          loading: false,
          disabled: false
        });
        console.log('Primary button set');

        // Listen for button clicks (following Neynar's pattern)
        sdk.on('primaryButtonClicked', async () => {
          console.log('Primary button clicked - entering contest', contestIdParam);

          // Set loading state
          sdk.actions.setPrimaryButton({
            text: 'Processing...',
            loading: true,
            disabled: true
          });

          try {
            // Get verified ETH address from Neynar API using FID
            // The SDK context does NOT include verifiedAddresses - must fetch from Neynar
            const context = window.FarcasterContext;
            const userFid = context?.user?.fid;
            console.log('User FID:', userFid);

            if (!userFid) {
              throw new Error('No FID available from Farcaster context');
            }

            // Entry key is the contest ID with M- or T- prefix
            const entryKey = contestIdParam;
            console.log('Contest ID:', contestIdParam, 'entryKey:', entryKey);

            // Check if user has already entered this contest
            try {
              const entryCheckRes = await fetch(`/api/check-entries?fid=${userFid}&contestIds=${entryKey}`);
              if (entryCheckRes.ok) {
                const entryData = await entryCheckRes.json();
                if (entryData.entries?.[entryKey]?.entered) {
                  console.log('User already entered this contest');
                  sdk.actions.setPrimaryButton({
                    text: 'Already Entered âœ“',
                    loading: false,
                    disabled: true
                  });
                  return; // Don't proceed - already entered
                }
              }
            } catch (e) {
              console.log('Entry check failed, proceeding anyway:', e);
            }

            // Check signer status - need approved signer for like/recast
            console.log('Checking signer status for FID:', userFid);
            let signerApproved = false;

            try {
              const signerStatusRes = await fetch(`/api/signer-status?fid=${userFid}`);
              if (signerStatusRes.ok) {
                const signerData = await signerStatusRes.json();
                signerApproved = signerData.approved === true;
                console.log('Signer status:', signerData);
              }
            } catch (e) {
              console.log('Signer status check failed:', e);
            }

            if (!signerApproved) {
              // Need to create/approve signer
              console.log('No approved signer - creating one...');
              sdk.actions.setPrimaryButton({
                text: 'Authorizing...',
                loading: true,
                disabled: true
              });

              try {
                const createRes = await fetch('/api/signer-create', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ fid: userFid })
                });

                if (!createRes.ok) {
                  throw new Error('Failed to create signer');
                }

                const createData = await createRes.json();
                console.log('Signer create response:', createData);

                if (createData.already_approved) {
                  signerApproved = true;
                } else if (createData.approval_url) {
                  // Open approval URL - this will open Warpcast for user to approve
                  console.log('Opening signer approval URL:', createData.approval_url);
                  sdk.actions.openUrl(createData.approval_url);

                  // Poll for approval (max 60 seconds)
                  sdk.actions.setPrimaryButton({
                    text: 'Waiting for approval...',
                    loading: true,
                    disabled: true
                  });

                  let pollAttempts = 0;
                  const maxPollAttempts = 30;

                  while (!signerApproved && pollAttempts < maxPollAttempts) {
                    await new Promise(r => setTimeout(r, 2000));
                    pollAttempts++;

                    try {
                      const pollRes = await fetch(`/api/signer-status?fid=${userFid}`);
                      if (pollRes.ok) {
                        const pollData = await pollRes.json();
                        if (pollData.approved) {
                          signerApproved = true;
                          console.log('Signer approved!');
                          break;
                        }
                      }
                    } catch (e) {
                      console.log('Poll attempt failed:', e);
                    }
                  }

                  if (!signerApproved) {
                    throw new Error('Signer approval timed out. Please try again.');
                  }
                }
              } catch (signerError) {
                console.error('Signer creation/approval failed:', signerError);
                sdk.actions.setPrimaryButton({
                  text: 'Authorization Failed',
                  loading: false,
                  disabled: false
                });
                throw signerError;
              }
            }

            console.log('Signer approved, proceeding with entry...');
            sdk.actions.setPrimaryButton({
              text: 'Processing...',
              loading: true,
              disabled: true
            });

            // Fetch verified addresses from Neynar API
            console.log('Fetching verified addresses from Neynar API...');
            const NEYNAR_API_KEY = 'AA2E0FC2-FDC0-466D-9EBA-4BCA968C9B1D';
            const neynarResponse = await fetch(`https://api.neynar.com/v2/farcaster/user/bulk?fids=${userFid}`, {
              headers: { 'api_key': NEYNAR_API_KEY }
            });

            if (!neynarResponse.ok) {
              throw new Error(`Neynar API error: ${neynarResponse.status}`);
            }

            const neynarData = await neynarResponse.json();
            console.log('Neynar user data:', neynarData);

            const neynarUser = neynarData.users?.[0];
            const verifiedAddresses = neynarUser?.verified_addresses?.eth_addresses || [];
            console.log('Verified ETH addresses:', verifiedAddresses);

            let from = verifiedAddresses[0];

            // Fallback to custody address if no verified addresses
            if (!from && neynarUser?.custody_address) {
              console.log('No verified addresses, using custody address:', neynarUser.custody_address);
              from = neynarUser.custody_address;
            }

            if (!from) {
              throw new Error('No wallet address found for user');
            }
            console.log('Using address:', from);

            // Check if user is a holder (100M+ tokens)
            // Use Base RPC directly since embedded wallet doesn't support eth_call
            const NEYNARTODES_TOKEN = '0x8de1622fe07f56CDA2E2273e615a513f1D828b07';
            const HOLDER_THRESHOLD = '100000000000000000000000000'; // 100M with 18 decimals
            const BASE_RPC = 'https://base-mainnet.g.alchemy.com/v2/QooWtq9nKQlkeqKF_-rvC';

            let isHolder = false;
            try {
              const rpcResponse = await fetch(BASE_RPC, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  jsonrpc: '2.0',
                  id: 1,
                  method: 'eth_call',
                  params: [{
                    to: NEYNARTODES_TOKEN,
                    data: '0x70a08231000000000000000000000000' + from.slice(2).toLowerCase()
                  }, 'latest']
                })
              });
              const rpcData = await rpcResponse.json();
              const balance = BigInt(rpcData.result || '0x0');
              isHolder = balance >= BigInt(HOLDER_THRESHOLD);
              console.log('Is holder:', isHolder, 'Balance:', balance.toString());
            } catch (e) {
              console.log('Balance check failed, assuming non-holder:', e);
            }

            // Fetch contest details first to get cast hash and host address
            let castHash = null;
            let contestDetails = null;
            try {
              let contestRes = await fetch(`/api/contest-history?limit=100&status=active`);
              if (contestRes.ok) {
                const contestData = await contestRes.json();
                contestDetails = contestData.contests?.find(c => c.contestId == contestIdParam);
                if (contestDetails?.castId) {
                  castHash = contestDetails.castId.split('|')[0];
                  console.log('Got cast hash and host:', castHash, contestDetails.host);
                }
              }
              if (!castHash) {
                contestRes = await fetch(`/api/contest-history?limit=100&status=active&_t=${Date.now()}`);
                if (contestRes.ok) {
                  const contestData = await contestRes.json();
                  contestDetails = contestData.contests?.find(c => c.contestId == contestIdParam);
                  if (contestDetails?.castId) {
                    castHash = contestDetails.castId.split('|')[0];
                  }
                }
              }
            } catch (e) {
              console.log('Could not fetch contest details:', e);
            }

            if (!castHash || !contestDetails?.host) {
              throw new Error('Could not get contest details. Contest may have ended or not exist.');
            }

            const hostAddress = contestDetails.host;
            const BUYBURNHOLDEARN = '0xCfa90CfE67Ca3a08f862671Bd7Fb808662efAC28';

            // Get SDK's ethereum provider
            const ethProvider = await sdk.wallet.getEthereumProvider();
            const accounts = await ethProvider.request({ method: 'eth_requestAccounts' });
            const providerAddress = accounts[0];
            console.log('Provider address:', providerAddress);

            if (isHolder) {
              // Holder: Call rewardHostForHolderEntry(host) - sends 150K from treasury to host
              console.log('Processing holder entry - sending 150K to host:', hostAddress);

              // Encode rewardHostForHolderEntry(address host)
              // Function selector: keccak256("rewardHostForHolderEntry(address)")[:4] = 0xc763489d
              const data = '0xc763489d' + hostAddress.slice(2).toLowerCase().padStart(64, '0');

              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [{
                  from: providerAddress,
                  to: BUYBURNHOLDEARN,
                  value: '0x0',
                  data: data,
                  gas: '0x' + (150000).toString(16)
                }]
              });
              console.log('Holder entry tx sent:', txHash);

              // Record entry
              const userFid = window.FarcasterContext?.user?.fid;
              await fetch('/api/enter-contest', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  fid: userFid,
                  contestId: entryKey,
                  castHash: castHash,
                  addresses: [from],
                  holderEntryTx: txHash
                })
              });

              sdk.actions.setPrimaryButton({
                text: 'Entered âœ“',
                loading: false,
                disabled: true
              });
              showCelebration(castHash);

            } else {
              // Non-holder: Call buyAndDistribute(entrant, host) - buys 1M, distributes 25/25/35/15
              console.log('Processing non-holder entry...');
              console.log('Entrant:', providerAddress, 'Host:', hostAddress);

              // Get quote for ETH needed via RPC call
              const quoteCalldata = '0x171755b1'; // getQuote() selector
              const quoteResponse = await fetch(BASE_RPC, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  jsonrpc: '2.0',
                  id: 1,
                  method: 'eth_call',
                  params: [{ to: BUYBURNHOLDEARN, data: quoteCalldata }, 'latest']
                })
              });
              const quoteData = await quoteResponse.json();
              const ethNeeded = BigInt(quoteData.result || '0x0');
              // Add 5% buffer
              const ethWithBuffer = ethNeeded * 105n / 100n;
              const valueHex = '0x' + ethWithBuffer.toString(16);
              console.log('Entry fee with buffer:', ethWithBuffer.toString(), 'wei');

              // Encode buyAndDistribute(address entrant, address host)
              // Function selector: keccak256("buyAndDistribute(address,address)")[:4] = 0x7dfda8d0
              const entrantPadded = providerAddress.slice(2).toLowerCase().padStart(64, '0');
              const hostPadded = hostAddress.slice(2).toLowerCase().padStart(64, '0');
              const data = '0x7dfda8d0' + entrantPadded + hostPadded;

              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [{
                  from: providerAddress,
                  to: BUYBURNHOLDEARN,
                  value: valueHex,
                  data: data,
                  gas: '0x' + (500000).toString(16)
                }]
              });
              console.log('Non-holder entry tx sent:', txHash);

              sdk.actions.setPrimaryButton({
                text: 'Entered âœ“',
                loading: false,
                disabled: true
              });

              showCelebration(castHash);

              // Record entry
              const userFid = window.FarcasterContext?.user?.fid;
              if (userFid && castHash) {
                fetch('/api/enter-contest', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    fid: userFid,
                    contestId: entryKey,
                    castHash: castHash,
                    addresses: [from],
                    entryTx: txHash
                  })
                }).then(res => res.json()).then(data => {
                  console.log('Entry recorded:', data);
                }).catch(e => console.log('Entry record failed:', e));
              }
            }

          } catch (err) {
            console.error('Entry failed:', err);
            sdk.actions.setPrimaryButton({
              text: 'Try Again',
              loading: false,
              disabled: false
            });
          }
        });

      } catch (e) {
        console.log('Could not set up primary button:', e);
      }
    }

    // Signal that SDK is ready - main script will listen for this
    window.FarcasterSDKReady = true;
    window.dispatchEvent(new Event('farcaster-ready'));
    console.log('Farcaster Mini App SDK ready');
  </script>
  <style>
    /* ===== MODERN DARK THEME FOUNDATION ===== */
    :root {
      /* Base colors */
      --bg-primary: #0a0a0f;
      --bg-secondary: #12121a;
      --bg-tertiary: #1a1a24;
      --bg-card: rgba(26, 26, 36, 0.8);

      /* Text colors */
      --text-primary: #f4f4f5;
      --text-secondary: #a1a1aa;
      --text-muted: #71717a;

      /* Accent - Violet/Purple */
      --accent: #8b5cf6;
      --accent-light: #a78bfa;
      --accent-dark: #7c3aed;
      --accent-glow: rgba(139, 92, 246, 0.3);

      /* Status colors */
      --success: #10b981;
      --success-glow: rgba(16, 185, 129, 0.2);
      --warning: #f59e0b;
      --warning-glow: rgba(245, 158, 11, 0.2);
      --error: #ef4444;
      --error-glow: rgba(239, 68, 68, 0.2);
      --info: #3b82f6;

      /* Borders */
      --border-subtle: rgba(255, 255, 255, 0.06);
      --border-light: rgba(255, 255, 255, 0.1);
      --border-accent: rgba(139, 92, 246, 0.3);

      /* Shadows */
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
      --shadow-glow: 0 0 40px var(--accent-glow);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    /* ===== GLASSMORPHISM CARDS ===== */
    .glass-card {
      background: var(--bg-card);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border-subtle);
      border-radius: 16px;
      transition: all 0.3s ease;
    }

    .glass-card:hover {
      border-color: var(--border-light);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .glass-card-accent {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(139, 92, 246, 0.05) 100%);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-accent);
      border-radius: 16px;
    }

    /* ===== BUTTONS ===== */
    .btn-primary {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: white;
      font-weight: 600;
      padding: 12px 24px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 14px var(--accent-glow);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px var(--accent-glow);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-weight: 500;
      padding: 12px 24px;
      border-radius: 12px;
      border: 1px solid var(--border-light);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--border-accent);
    }

    .btn-ghost {
      background: transparent;
      color: var(--text-secondary);
      font-weight: 500;
      padding: 10px 16px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
    }

    .btn-ghost.active {
      background: rgba(139, 92, 246, 0.15);
      color: var(--accent-light);
    }

    /* ===== INPUTS ===== */
    .input-modern {
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 14px 16px;
      color: var(--text-primary);
      font-size: 14px;
      transition: all 0.2s ease;
      width: 100%;
    }

    .input-modern:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-glow);
    }

    .input-modern::placeholder {
      color: var(--text-muted);
    }

    /* ===== STAT CARDS ===== */
    .stat-card {
      background: var(--bg-card);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-subtle);
      border-radius: 16px;
      padding: 20px;
      position: relative;
      overflow: hidden;
    }

    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent) 0%, transparent 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .stat-card:hover::before {
      opacity: 1;
    }

    .stat-label {
      font-size: 12px;
      font-weight: 500;
      color: var(--accent-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--text-primary);
      line-height: 1.2;
    }

    .stat-value-sm {
      font-size: 20px;
    }

    .stat-subtitle {
      font-size: 13px;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    /* ===== TAGS/BADGES ===== */
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
    }

    .tag-accent {
      background: rgba(139, 92, 246, 0.15);
      color: var(--accent-light);
    }

    .tag-success {
      background: var(--success-glow);
      color: var(--success);
    }

    .tag-warning {
      background: var(--warning-glow);
      color: var(--warning);
    }

    .tag-error {
      background: var(--error-glow);
      color: var(--error);
    }

    /* ===== ANIMATIONS ===== */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 20px var(--accent-glow); }
      50% { box-shadow: 0 0 40px var(--accent-glow); }
    }

    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }

    .animate-fade-in {
      animation: fadeIn 0.4s ease-out;
    }

    .animate-pulse-glow {
      animation: pulse-glow 2s ease-in-out infinite;
    }

    /* ===== SKELETON LOADING ===== */
    .skeleton {
      background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: 8px;
    }

    /* ===== APP LOADING STATE ===== */
    /* Prevents layout jumping by showing loading splash until app is ready */
    #app-loading {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg-primary);
      z-index: 9999;
      transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
    }

    #app-loading.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    #app-loading .loading-logo {
      width: 80px;
      height: 80px;
      animation: pulse-glow 1.5s ease-in-out infinite;
      filter: drop-shadow(0 0 20px rgba(139, 92, 246, 0.5));
    }

    #app-loading .loading-text {
      margin-top: 16px;
      color: var(--text-secondary);
      font-size: 14px;
    }

    #app {
      opacity: 0;
      transition: opacity 0.3s ease-in;
    }

    #app.ready {
      opacity: 1;
    }

    /* ===== SCROLLBAR ===== */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* ===== TOAST NOTIFICATIONS ===== */
    #toast-container {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 90vw;
      pointer-events: none;
    }

    .toast {
      background: var(--bg-card);
      backdrop-filter: blur(20px);
      color: var(--text-primary);
      padding: 14px 18px;
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-line;
      animation: toastIn 0.3s ease-out;
      pointer-events: auto;
      max-width: 500px;
      border: 1px solid var(--border-subtle);
    }

    .toast.success { border-left: 3px solid var(--success); }
    .toast.error { border-left: 3px solid var(--error); }
    .toast.info { border-left: 3px solid var(--info); }
    .toast.warning { border-left: 3px solid var(--warning); }

    @keyframes toastIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes toastOut {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-20px); }
    }

    /* ===== UTILITY CLASSES ===== */
    .text-gradient {
      background: linear-gradient(135deg, var(--accent-light) 0%, var(--accent) 50%, #ec4899 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .glow-accent {
      box-shadow: var(--shadow-glow);
    }

    .divider {
      height: 1px;
      background: var(--border-subtle);
      margin: 16px 0;
    }

    /* ===== CELEBRATION OVERLAY ===== */
    .celebration-overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.85);
      animation: celebrationFadeIn 0.3s ease-out;
      pointer-events: auto;
    }

    @keyframes celebrationFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .celebration-content {
      text-align: center;
      animation: celebrationBounce 0.5s ease-out;
    }

    @keyframes celebrationBounce {
      0% { transform: scale(0.5) translateY(50px); opacity: 0; }
      50% { transform: scale(1.1) translateY(-10px); }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }

    .celebration-title {
      font-size: 2.5rem;
      font-weight: 800;
      background: linear-gradient(135deg, #10b981 0%, #34d399 50%, #6ee7b7 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 1rem;
      text-shadow: 0 0 40px rgba(16, 185, 129, 0.5);
    }

    .celebration-message {
      font-size: 1.1rem;
      color: var(--text-secondary);
      max-width: 300px;
      line-height: 1.6;
    }

    .celebration-message strong {
      color: var(--accent-light);
    }

    /* Firework particles */
    .firework {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      animation: fireworkExplode 1s ease-out forwards;
    }

    @keyframes fireworkExplode {
      0% { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }

    .firework-trail {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      animation: trailFade 0.6s ease-out forwards;
    }

    @keyframes trailFade {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.3); }
    }

    /* Confetti */
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      animation: confettiFall 3s ease-out forwards;
    }

    @keyframes confettiFall {
      0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }

    /* Floating sticker animation */
    @keyframes stickerFloat {
      0%, 100% { transform: translate(0, 0) rotate(var(--rot)); }
      25% { transform: translate(2px, -3px) rotate(calc(var(--rot) + 2deg)); }
      50% { transform: translate(-1px, -5px) rotate(calc(var(--rot) - 1deg)); }
      75% { transform: translate(-3px, -2px) rotate(calc(var(--rot) + 1deg)); }
    }

    .sticker-float {
      animation: stickerFloat var(--duration) ease-in-out infinite;
    }

    /* Horizontal drift animations for PFP rows */
    @keyframes driftRight {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(6px); }
    }

    @keyframes driftLeft {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(-6px); }
    }

    .drift-right {
      animation: driftRight var(--drift-duration) ease-in-out infinite;
    }

    .drift-left {
      animation: driftLeft var(--drift-duration) ease-in-out infinite;
    }
  </style>
</head>
<body>
  <!-- Loading splash - shown until app is ready -->
  <div id="app-loading">
    <img src="/neynartode-sticker.png" alt="" class="loading-logo" />
    <div class="loading-text">Loading...</div>
  </div>

  <div id="toast-container"></div>
  <div id="celebration-container"></div>

  <div id="app"></div>

  <script>
    // Show bonus tip in the display area (tap to reveal details)
    function showBonusTip(message) {
      const display = document.getElementById('bonusTipDisplay');
      if (!display) return;

      // If same message is already showing, hide it (toggle behavior)
      if (!display.classList.contains('hidden') && display.textContent === message) {
        display.classList.add('hidden');
        return;
      }

      display.textContent = message;
      display.classList.remove('hidden');

      // Auto-hide after 5 seconds
      clearTimeout(window.bonusTipTimeout);
      window.bonusTipTimeout = setTimeout(() => {
        display.classList.add('hidden');
      }, 5000);
    }

    // Toast notification system (replaces alert() which is blocked in Farcaster iframe)
    // Set duration to 0 for persistent toast that stays until user closes it
    function showToast(message, type = 'info', duration = 5000) {
      const container = document.getElementById('toast-container');
      if (!container) return;

      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.style.position = 'relative';
      toast.style.whiteSpace = 'pre-line';

      // Add message text
      const textSpan = document.createElement('span');
      textSpan.textContent = message;
      toast.appendChild(textSpan);

      // Add close button for persistent toasts
      if (duration === 0) {
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'âœ•';
        closeBtn.style.cssText = 'position:absolute;top:8px;right:8px;background:none;border:none;color:inherit;font-size:16px;cursor:pointer;padding:4px 8px;opacity:0.7;';
        closeBtn.onmouseover = () => closeBtn.style.opacity = '1';
        closeBtn.onmouseout = () => closeBtn.style.opacity = '0.7';
        closeBtn.onclick = (e) => {
          e.stopPropagation();
          toast.style.animation = 'toastOut 0.3s ease-out forwards';
          setTimeout(() => toast.remove(), 300);
        };
        toast.appendChild(closeBtn);
        toast.style.paddingRight = '32px';
      }

      container.appendChild(toast);

      // Auto-remove after duration (skip if duration is 0 for persistent)
      if (duration > 0) {
        setTimeout(() => {
          toast.style.animation = 'toastOut 0.3s ease-out forwards';
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      // Click to dismiss (anywhere on toast)
      toast.onclick = () => {
        toast.style.animation = 'toastOut 0.3s ease-out forwards';
        setTimeout(() => toast.remove(), 300);
      };
    }

    // Show participants modal for a contest
    async function showParticipantsModal(contestId) {
      state.participantsModal = { contestId, loading: true, participants: [], count: 0 };
      render();

      try {
        // Fetch full list (up to 200)
        const response = await fetch(`/api/contest-participants?contestId=${contestId}&limit=200`);
        const data = await response.json();
        state.participantsModal = {
          contestId,
          loading: false,
          participants: data.participants || [],
          count: data.count || 0
        };
      } catch (e) {
        console.error('Error fetching participants:', e);
        state.participantsModal.loading = false;
        state.participantsModal.error = e.message;
      }
      render();
    }

    // Close participants modal
    function closeParticipantsModal() {
      state.participantsModal = null;
      render();
    }

    // Show Buy Burn Hold Earn modal
    function showBuyBurnHoldEarnModal() {
      state.buyBurnHoldEarnModal = true;
      render();
    }

    // Close Buy Burn Hold Earn modal
    function closeBuyBurnHoldEarnModal() {
      state.buyBurnHoldEarnModal = false;
      render();
    }

    // Render Buy Burn Hold Earn modal
    function renderBuyBurnHoldEarnModal() {
      if (!state.buyBurnHoldEarnModal) return '';

      return `
        <div
          class="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4"
          onclick="if(event.target === this) closeBuyBurnHoldEarnModal()"
        >
          <div class="bg-[var(--bg-secondary)] rounded-2xl max-w-md w-full p-5 shadow-xl border border-[var(--border)] max-h-[90vh] overflow-y-auto">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-xl font-bold text-[var(--text-primary)] flex items-center gap-2">
                <span>ðŸ”¥</span> Buy Burn Hold Earn
              </h3>
              <button
                onclick="closeBuyBurnHoldEarnModal()"
                class="text-[var(--text-muted)] hover:text-[var(--text-primary)] text-2xl leading-none"
              >&times;</button>
            </div>

            <p class="text-sm text-[var(--text-muted)] mb-4">
              Every contest entry triggers a token buy that benefits the entire ecosystem.
            </p>

            <!-- Non-Holder Entry Section -->
            <div class="mb-4 p-4 rounded-xl bg-[var(--bg-tertiary)] border border-[var(--border)]">
              <div class="font-semibold text-[var(--text-primary)] mb-2 flex items-center gap-2">
                <span class="text-lg">ðŸ’°</span> Standard Entry
              </div>
              <p class="text-xs text-[var(--text-muted)] mb-3">
                If you hold less than 100M NEYNARTODES, the contract buys 1M tokens and distributes them:
              </p>
              <div class="space-y-2">
                <div class="flex items-center justify-between">
                  <span class="text-sm text-[var(--text-muted)]">To You (Entrant)</span>
                  <span class="font-semibold text-[var(--accent-light)]">25% (250K)</span>
                </div>
                <div class="flex items-center justify-between">
                  <span class="text-sm text-[var(--text-muted)]">Burned Forever</span>
                  <span class="font-semibold text-[var(--error)]">25% (250K)</span>
                </div>
                <div class="flex items-center justify-between">
                  <span class="text-sm text-[var(--text-muted)]">To Treasury</span>
                  <span class="font-semibold text-[var(--success)]">35% (350K)</span>
                </div>
                <div class="flex items-center justify-between">
                  <span class="text-sm text-[var(--text-muted)]">To Contest Host</span>
                  <span class="font-semibold text-[var(--warning)]">15% (150K)</span>
                </div>
              </div>
            </div>

            <!-- Holder Entry Section -->
            <div class="mb-4 p-4 rounded-xl bg-gradient-to-r from-[var(--accent)]/10 to-[var(--success)]/10 border border-[var(--accent)]/30">
              <div class="font-semibold text-[var(--text-primary)] mb-2 flex items-center gap-2">
                <span class="text-lg">ðŸ‘‘</span> Holder Bonus
              </div>
              <p class="text-xs text-[var(--text-muted)] mb-3">
                If you hold 100M+ NEYNARTODES, you enter FREE and the host still gets rewarded:
              </p>
              <div class="flex items-center justify-between">
                <span class="text-sm text-[var(--text-muted)]">To Contest Host</span>
                <span class="font-semibold text-[var(--warning)]">150K tokens</span>
              </div>
              <p class="text-xs text-[var(--text-muted)] mt-2 italic">
                Host rewards come from the Treasury, not your wallet!
              </p>
            </div>

            <!-- Benefits Summary -->
            <div class="p-3 rounded-lg bg-[var(--bg-primary)] border border-[var(--border)]">
              <div class="font-semibold text-sm text-[var(--text-primary)] mb-2">Why This Matters</div>
              <ul class="text-xs text-[var(--text-muted)] space-y-1">
                <li>â€¢ <span class="text-[var(--error)]">25% burned</span> = reduced supply</li>
                <li>â€¢ <span class="text-[var(--accent-light)]">25% to you</span> = instant rewards</li>
                <li>â€¢ <span class="text-[var(--warning)]">Hosts earn</span> = incentivized contest creation</li>
                <li>â€¢ <span class="text-[var(--success)]">Treasury grows</span> = bigger prize pools</li>
              </ul>
            </div>

            <button
              onclick="closeBuyBurnHoldEarnModal()"
              class="w-full mt-4 py-3 px-4 rounded-xl bg-[var(--accent)] text-white font-semibold hover:opacity-90 transition-opacity"
            >
              Got It!
            </button>
          </div>
        </div>
      `;
    }

    // Render participants modal
    function renderParticipantsModal() {
      if (!state.participantsModal) return '';

      const { contestId, loading, participants, count, error } = state.participantsModal;

      let content = '';
      if (loading) {
        content = '<div class="text-center py-8 text-[var(--text-muted)]">Loading participants...</div>';
      } else if (error) {
        content = `<div class="text-center py-8 text-red-400">Error: ${error}</div>`;
      } else if (participants.length === 0) {
        content = '<div class="text-center py-8 text-[var(--text-muted)]">No participants yet</div>';
      } else {
        content = `
          <div class="max-h-80 overflow-y-auto space-y-2 pr-2">
            ${participants.map(p => `
              <div class="flex items-center gap-3 py-2 px-3 rounded-lg bg-[var(--bg-tertiary)]">
                <img
                  src="${p.pfpUrl || '/neynartode-sticker.png'}"
                  alt=""
                  class="w-10 h-10 rounded-full object-cover border-2 border-[var(--accent)]"
                  onerror="this.src='/neynartode-sticker.png'"
                />
                <div class="flex-1 min-w-0">
                  <div class="font-medium text-[var(--text-primary)] truncate">
                    ${p.displayName || p.username}
                  </div>
                  <div class="text-xs text-[var(--text-muted)]">@${p.username}</div>
                </div>
              </div>
            `).join('')}
          </div>
        `;
      }

      return `
        <div
          class="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4"
          onclick="if(event.target === this) closeParticipantsModal()"
        >
          <div class="bg-[var(--bg-secondary)] rounded-2xl max-w-sm w-full p-4 shadow-xl border border-[var(--border)]">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-lg font-semibold text-[var(--text-primary)]">
                Participants (${count})
              </h3>
              <button
                onclick="closeParticipantsModal()"
                class="text-[var(--text-muted)] hover:text-[var(--text-primary)] text-2xl leading-none"
              >&times;</button>
            </div>
            <div class="text-xs text-[var(--text-muted)] mb-3">Contest ${contestId}</div>
            ${content}
          </div>
        </div>
      `;
    }

    // Proxy IPFS images through our server to avoid 403 errors in Warpcast webview
    function proxyImage(url) {
      if (!url) return '';
      // Check if it's an IPFS URL that needs proxying
      if (url.includes('ipfs.io') || url.includes('ipfs://') ||
          url.includes('cloudflare-ipfs.com') || url.includes('dweb.link') ||
          url.includes('nftstorage.link') || url.includes('/ipfs/')) {
        return `/api/image-proxy?url=${encodeURIComponent(url)}`;
      }
      return url;
    }

    // Celebration overlay with fireworks
    function showCelebration(castHash) {
      const container = document.getElementById('celebration-container');
      if (!container) return;

      // Build Warpcast reply URL
      const replyUrl = castHash ? `https://warpcast.com/~/conversations/${castHash}` : null;

      // Create overlay
      const overlay = document.createElement('div');
      overlay.className = 'celebration-overlay';
      overlay.innerHTML = `
        <div class="celebration-content">
          <div class="celebration-title">You're Entered!</div>
          <div class="celebration-message">
            <strong>Reply to the cast</strong> to get an<br>
            <strong>extra entry</strong> into the raffle!
          </div>
          ${replyUrl ? `
            <button id="reply-btn" style="
              margin-top: 1.5rem;
              background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
              color: white;
              font-weight: 600;
              padding: 14px 28px;
              border-radius: 12px;
              border: none;
              cursor: pointer;
              font-size: 1rem;
              box-shadow: 0 4px 14px var(--accent-glow);
              transition: all 0.2s ease;
            ">Reply Now</button>
          ` : ''}
          <div style="margin-top: 1rem; color: var(--text-muted); font-size: 0.85rem;">Tap anywhere to close</div>
        </div>
      `;

      container.appendChild(overlay);

      // Create fireworks
      const colors = ['#10b981', '#34d399', '#8b5cf6', '#a78bfa', '#f59e0b', '#ec4899', '#3b82f6'];

      function createFirework(x, y) {
        const particleCount = 20;
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.className = 'firework';
          particle.style.left = x + 'px';
          particle.style.top = y + 'px';
          particle.style.background = colors[Math.floor(Math.random() * colors.length)];

          const angle = (i / particleCount) * Math.PI * 2;
          const distance = 80 + Math.random() * 60;
          particle.style.setProperty('--tx', Math.cos(angle) * distance + 'px');
          particle.style.setProperty('--ty', Math.sin(angle) * distance + 'px');
          particle.style.animationDelay = Math.random() * 0.2 + 's';

          overlay.appendChild(particle);
          setTimeout(() => particle.remove(), 1200);
        }
      }

      // Create confetti
      function createConfetti() {
        for (let i = 0; i < 50; i++) {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + '%';
          confetti.style.top = '-20px';
          confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.animationDelay = Math.random() * 0.5 + 's';
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;

          if (Math.random() > 0.5) {
            confetti.style.borderRadius = '50%';
          }

          overlay.appendChild(confetti);
          setTimeout(() => confetti.remove(), 3500);
        }
      }

      // Launch fireworks at different positions
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      setTimeout(() => createFirework(vw * 0.3, vh * 0.3), 100);
      setTimeout(() => createFirework(vw * 0.7, vh * 0.25), 300);
      setTimeout(() => createFirework(vw * 0.5, vh * 0.4), 500);
      setTimeout(() => createFirework(vw * 0.2, vh * 0.5), 700);
      setTimeout(() => createFirework(vw * 0.8, vh * 0.45), 900);

      // Launch confetti
      createConfetti();

      // Handle reply button click
      const replyBtn = overlay.querySelector('#reply-btn');
      if (replyBtn && replyUrl) {
        replyBtn.onclick = (e) => {
          e.stopPropagation();
          // Open cast in Warpcast
          if (window.FarcasterSDK?.actions?.openUrl) {
            window.FarcasterSDK.actions.openUrl(replyUrl);
          } else {
            window.open(replyUrl, '_blank');
          }
          // Close celebration
          overlay.style.animation = 'celebrationFadeIn 0.3s ease-out reverse forwards';
          setTimeout(() => overlay.remove(), 300);
        };
      }

      // Click anywhere else to dismiss
      overlay.onclick = (e) => {
        if (e.target === overlay || e.target.closest('.celebration-content') && !e.target.closest('#reply-btn')) {
          overlay.style.animation = 'celebrationFadeIn 0.3s ease-out reverse forwards';
          setTimeout(() => overlay.remove(), 300);
        }
      };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENTER RAFFLE V2 - Auto like, recast, and optional buy and burn
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const BUYBURNHOLDEARN_ADDRESS = '0xCfa90CfE67Ca3a08f862671Bd7Fb808662efAC28'; // BuyBurnHoldEarn - distributes 25% entrant, 25% burn, 35% treasury, 15% host
    const HOLDER_THRESHOLD = ethers.BigNumber.from('100000000000000000000000000'); // 100M tokens (18 decimals)

    // Load which contests user has entered
    async function loadContestEntries() {
      // Get FID from state or Farcaster context
      let fid = state.userFid || window.FarcasterContext?.user?.fid;
      if (!fid) return;

      // Sync FID to state if not already set
      if (!state.userFid && fid) {
        state.userFid = fid;
        const user = window.FarcasterContext?.user;
        if (user) {
          state.userProfile = {
            fid: user.fid,
            username: user.username,
            displayName: user.displayName,
            pfpUrl: user.pfp?.url
          };
        }
      }

      // Contest IDs already have M- or T- prefix
      const contestIds = (state.upcomingContests || []).map(c => c.contestId).join(',');
      if (!contestIds) return;

      try {
        const response = await fetch(`/api/check-entries?fid=${fid}&contestIds=${contestIds}`);
        if (response.ok) {
          const data = await response.json();
          state.contestEntries = data.entries || {};
          render();
        }
      } catch (e) {
        console.log('Error loading contest entries:', e);
      }
    }

    // Load which contests user has shared (for Share button checkmarks)
    async function loadContestShares() {
      let fid = state.userFid || window.FarcasterContext?.user?.fid;
      if (!fid) return;

      const contestIds = (state.upcomingContests || []).map(c => c.contestId).join(',');
      if (!contestIds) return;

      try {
        const response = await fetch(`/api/check-shares?fid=${fid}&contestIds=${contestIds}`);
        if (response.ok) {
          const data = await response.json();
          state.contestShares = data.shares || {};
          render();
        }
      } catch (e) {
        console.log('Error loading contest shares:', e);
      }
    }

    // Check if user has approved signer
    async function checkSignerStatus() {
      if (!state.userFid) return null;

      try {
        const response = await fetch(`/api/signer-status?fid=${state.userFid}`);
        if (response.ok) {
          const data = await response.json();
          state.signerStatus = data;
          return data;
        }
      } catch (e) {
        console.log('Error checking signer status:', e);
      }
      return null;
    }

    // Create a new signer and get approval URL
    async function createSigner() {
      if (!state.userFid) {
        showToast('Please connect your Farcaster account first', 'warning');
        return null;
      }

      try {
        showToast('Creating authorization...', 'info');
        const response = await fetch('/api/signer-create', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ fid: state.userFid })
        });

        if (response.ok) {
          const data = await response.json();

          if (data.already_approved) {
            state.signerStatus = { has_signer: true, approved: true, signer_uuid: data.signer_uuid };
            return { approved: true };
          }

          // Show QR code modal for approval
          // Both URL formats (https://client.farcaster.xyz/deeplinks/... and farcaster://...)
          // ultimately need to be opened on mobile where Warpcast is installed
          if (data.approval_url) {
            state.signerApprovalUrl = data.approval_url;
            state.showSignerModal = true;
            renderSignerModal();

            // Start polling for approval
            pollSignerApproval(60).then(approved => {
              if (approved) {
                state.showSignerModal = false;
                renderSignerModal();
                showToast('Authorization approved! You can now enter contests.', 'success');
              }
            });

            return { pending: true, approval_url: data.approval_url };
          }
        } else {
          const error = await response.json();
          showToast(error.error || 'Failed to create signer', 'error');
        }
      } catch (e) {
        console.log('Error creating signer:', e);
        showToast('Failed to create authorization', 'error');
      }
      return null;
    }

    // Poll for signer approval
    async function pollSignerApproval(maxAttempts = 30) {
      for (let i = 0; i < maxAttempts; i++) {
        await new Promise(r => setTimeout(r, 2000)); // Wait 2 seconds
        const status = await checkSignerStatus();
        if (status?.approved) {
          showToast('Authorization approved!', 'success');
          return true;
        }
      }
      return false;
    }

    // Check if user is a holder (100M+ NEYNARTODES)
    async function checkHolderStatus() {
      if (!state.userFid && !state.userAddress) return false;

      try {
        // Get user's verified addresses
        let addresses = [];
        if (state.userProfile?.verifiedAddresses?.ethAddresses) {
          addresses = state.userProfile.verifiedAddresses.ethAddresses;
        }
        if (state.userAddress && !addresses.includes(state.userAddress)) {
          addresses.push(state.userAddress);
        }

        if (addresses.length === 0) {
          console.log('No addresses found for holder check');
          return false;
        }

        // Check NEYNARTODES balance via API call to avoid provider issues
        try {
          const params = state.userFid
            ? `fid=${state.userFid}&contestId=1`
            : `address=${addresses[0]}&contestId=1`;

          const response = await fetch(`/api/check-eligibility?${params}`);
          if (response.ok) {
            const data = await response.json();
            const isHolder = data.holder?.met || false;
            console.log(`Holder check via API: balance=${data.holder?.balanceFormatted}, threshold=${data.holder?.thresholdFormatted}, isHolder=${isHolder}`);
            return isHolder;
          }
        } catch (apiError) {
          console.log('API holder check failed, trying direct RPC:', apiError.message);
        }

        // Fallback: Check NEYNARTODES balance directly on-chain
        const provider = new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC_URL);
        const tokenContract = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          ['function balanceOf(address) view returns (uint256)'],
          provider
        );

        // Sum balance across all addresses
        let totalBalance = ethers.BigNumber.from(0);
        for (const addr of addresses) {
          try {
            const balance = await tokenContract.balanceOf(addr);
            totalBalance = totalBalance.add(balance);
          } catch (e) {
            console.log(`Error checking balance for ${addr}:`, e.message);
          }
        }

        // Threshold: 100M tokens (with 18 decimals)
        const threshold = ethers.utils.parseUnits('100000000', 18);
        const isHolder = totalBalance.gte(threshold);

        console.log(`Holder check via RPC: balance=${ethers.utils.formatUnits(totalBalance, 18)}, threshold=100M, isHolder=${isHolder}`);

        return isHolder;
      } catch (e) {
        console.log('Error checking holder status:', e);
      }
      return false;
    }

    // View cast on Warpcast
    function viewCast(castHash) {
      if (!castHash) {
        showToast('Cast not available', 'warning');
        return;
      }
      // Open Warpcast conversation view for the cast
      const warpcastUrl = `https://warpcast.com/~/conversations/${castHash}`;
      window.open(warpcastUrl, '_blank');
    }

    // Main Enter Raffle function
    async function enterRaffle(button) {
      const contestId = button.dataset.contestId;
      const castId = button.dataset.castId;

      // Extract additional data for auto-cast announcement
      const prize = decodeURIComponent(button.dataset.prize || '');
      const hoursLeft = parseInt(button.dataset.hours) || 0;
      const minutesLeft = parseInt(button.dataset.minutes) || 0;
      const hostUsername = decodeURIComponent(button.dataset.host || '');
      const isNft = button.dataset.isNft === 'true';
      const nftImage = decodeURIComponent(button.dataset.nftImage || '');
      const nftName = decodeURIComponent(button.dataset.nftName || '');

      if (!state.userFid) {
        showToast('Please connect your Farcaster account first', 'warning');
        return;
      }

      // Check if already entered
      const entryKey = contestId;
      if (state.contestEntries[entryKey]?.entered) {
        showToast('You have already entered this contest!', 'info');
        return;
      }

      // Update button state
      state.enteringContest = contestId;
      button.innerHTML = '<span class="animate-spin">â†»</span> Entering...';
      button.disabled = true;

      try {
        // Step 1: Check signer status
        let signerStatus = state.signerStatus;
        if (!signerStatus || !signerStatus.has_signer) {
          signerStatus = await checkSignerStatus();
        }

        if (!signerStatus?.approved) {
          // Need to create/approve signer
          showToast('You need to authorize the app to enter contests', 'info');
          const result = await createSigner();

          if (result?.pending) {
            showToast('Waiting for authorization approval...', 'info');
            const approved = await pollSignerApproval();
            if (!approved) {
              showToast('Authorization timed out. Please try again.', 'error');
              resetEnterButton(button, contestId);
              return;
            }
          } else if (!result?.approved) {
            resetEnterButton(button, contestId);
            return;
          }
        }

        // Step 2: Check if holder and process BuyBurnHoldEarn transaction
        const isHolder = await checkHolderStatus();
        const sdk = window.FarcasterSDK;

        // Get user's wallet address
        let fromAddress = state.userProfile?.verifiedAddresses?.ethAddresses?.[0] || state.userAddress;
        if (!fromAddress && sdk?.wallet?.ethProvider) {
          const accounts = await sdk.wallet.ethProvider.request({ method: 'eth_accounts' });
          fromAddress = accounts?.[0];
        }
        if (!fromAddress && window.ethereum) {
          const accounts = await window.ethereum.request({ method: 'eth_accounts' });
          fromAddress = accounts?.[0];
        }
        if (!fromAddress) {
          showToast('No wallet address found', 'error');
          resetEnterButton(button, contestId);
          return;
        }

        // Get contest host address from contest data
        const contest = state.upcomingContests?.find(c => c.contestId === contestId);
        const hostAddress = contest?.host;
        if (!hostAddress) {
          showToast('Could not find contest host address', 'error');
          resetEnterButton(button, contestId);
          return;
        }

        console.log('Entry details:', { isHolder, entrant: fromAddress, host: hostAddress });

        // Process BuyBurnHoldEarn transaction
        const iface = new ethers.utils.Interface(BUYBURNHOLDEARN_ABI);

        if (isHolder) {
          // Holder entry: call rewardHostForHolderEntry(host) - sends 150K from treasury to host
          showToast('Processing holder entry reward...', 'info');
          const data = iface.encodeFunctionData('rewardHostForHolderEntry', [hostAddress]);

          try {
            let txHash;
            const txParams = {
              from: fromAddress,
              to: BUYBURNHOLDEARN_ADDRESS,
              value: '0x0', // No ETH needed for holder entry
              data: data,
              gas: '0x' + (150000).toString(16) // 150k gas limit
            };

            if (sdk?.wallet?.ethProvider) {
              console.log('Using Farcaster SDK for holder entry');
              txHash = await sdk.wallet.ethProvider.request({
                method: 'eth_sendTransaction',
                params: [txParams]
              });
            } else if (window.ethereum) {
              console.log('Using window.ethereum for holder entry');
              txHash = await window.ethereum.request({
                method: 'eth_sendTransaction',
                params: [txParams]
              });
            } else {
              showToast('No wallet available', 'error');
              resetEnterButton(button, contestId);
              return;
            }

            showToast('Waiting for transaction confirmation...', 'info');

            // Wait for transaction to be mined
            const provider = new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC_URL);
            let receipt = null;
            let attempts = 0;
            while (!receipt && attempts < 60) {
              await new Promise(r => setTimeout(r, 2000));
              receipt = await provider.getTransactionReceipt(txHash).catch(() => null);
              attempts++;
            }

            if (!receipt) {
              showToast('Transaction submitted but confirmation timed out. Entry may still process.', 'warning');
            } else if (receipt.status === 1) {
              showToast('Holder entry confirmed! Host received 150K NEYNARTODES', 'success');
            } else {
              showToast('Transaction failed on-chain', 'error');
              resetEnterButton(button, contestId);
              return;
            }
          } catch (txError) {
            console.error('Holder entry error:', txError);
            if (txError.code === 4001 || txError.code === 'ACTION_REJECTED' || txError.message?.includes('rejected')) {
              showToast('Transaction cancelled - entry not recorded', 'warning');
            } else {
              showToast('Transaction failed: ' + (txError.message || txError), 'error');
            }
            resetEnterButton(button, contestId);
            return;
          }
        } else {
          // Non-holder entry: call buyAndDistribute(entrant, host) - buys 1M tokens, distributes 25/25/35/15
          showToast('Getting entry fee quote...', 'info');

          try {
            // Get quote for ETH needed
            const provider = new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC_URL);
            const contract = new ethers.Contract(BUYBURNHOLDEARN_ADDRESS, BUYBURNHOLDEARN_ABI, provider);
            const ethNeeded = await contract.callStatic.getQuote();
            // Add 5% buffer for price movement
            const ethWithBuffer = ethNeeded.mul(105).div(100);
            const valueHex = '0x' + ethWithBuffer.toBigInt().toString(16);

            console.log('Entry fee:', ethers.utils.formatEther(ethWithBuffer), 'ETH');

            showToast('Processing entry fee...', 'info');

            // Encode buyAndDistribute call
            const data = iface.encodeFunctionData('buyAndDistribute', [fromAddress, hostAddress]);

            let txHash;
            const txParams = {
              from: fromAddress,
              to: BUYBURNHOLDEARN_ADDRESS,
              value: valueHex,
              data: data,
              gas: '0x' + (500000).toString(16) // 500k gas limit for V4 swap
            };

            if (sdk?.wallet?.ethProvider) {
              console.log('Using Farcaster SDK for non-holder entry');
              txHash = await sdk.wallet.ethProvider.request({
                method: 'eth_sendTransaction',
                params: [txParams]
              });
            } else if (window.ethereum) {
              console.log('Using window.ethereum for non-holder entry');
              txHash = await window.ethereum.request({
                method: 'eth_sendTransaction',
                params: [txParams]
              });
            } else {
              showToast('No wallet available', 'error');
              resetEnterButton(button, contestId);
              return;
            }

            showToast('Waiting for transaction confirmation...', 'info');

            // Wait for transaction to be mined
            let receipt = null;
            let attempts = 0;
            while (!receipt && attempts < 60) {
              await new Promise(r => setTimeout(r, 2000));
              receipt = await provider.getTransactionReceipt(txHash).catch(() => null);
              attempts++;
            }

            if (!receipt) {
              showToast('Transaction submitted but confirmation timed out. Entry may still process.', 'warning');
            } else if (receipt.status === 1) {
              showToast('Entry confirmed! You received 250K NEYNARTODES', 'success');
            } else {
              showToast('Transaction failed on-chain', 'error');
              resetEnterButton(button, contestId);
              return;
            }
          } catch (txError) {
            console.error('Non-holder entry error:', txError);
            if (txError.code === 4001 || txError.code === 'ACTION_REJECTED' || txError.message?.includes('rejected')) {
              showToast('Transaction cancelled - entry not recorded', 'warning');
            } else {
              showToast('Transaction failed: ' + (txError.message || txError), 'error');
            }
            resetEnterButton(button, contestId);
            return;
          }
        }

        // Step 3: Call enter-contest API (auto like)
        const castHash = castId?.split('|')[0] || '';
        const userAddresses = state.userProfile?.verifiedAddresses?.ethAddresses || [];

        const response = await fetch('/api/enter-contest', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            fid: state.userFid,
            contestId: entryKey,
            castHash: castHash,
            addresses: userAddresses.length > 0 ? userAddresses : [state.userAddress]
          })
        });

        if (response.ok) {
          const data = await response.json();

          // Update state
          state.contestEntries[entryKey] = {
            entered: true,
            hasReplied: false,
            timestamp: Date.now()
          };

          // Update button
          button.innerHTML = 'Entered âœ“';
          button.disabled = true;
          button.style.opacity = '0.6';
          button.style.cursor = 'default';

          // Show celebration (no compose modal blocking it!)
          showCelebration(castHash);

          render();

        } else {
          const error = await response.json();
          if (error.already_entered) {
            state.contestEntries[entryKey] = { entered: true };
            button.innerHTML = 'Entered âœ“';
            button.disabled = true;
            showToast('You have already entered this contest!', 'info');
          } else if (error.needs_signer) {
            showToast('Authorization required. Please try again.', 'warning');
            resetEnterButton(button, entryKey);
          } else {
            showToast(error.error || 'Failed to enter contest', 'error');
            resetEnterButton(button, entryKey);
          }
        }

      } catch (error) {
        console.error('Enter raffle error:', error);
        showToast('Failed to enter contest: ' + error.message, 'error');
        resetEnterButton(button, entryKey);
      }

      state.enteringContest = null;
    }

    function resetEnterButton(button, contestId) {
      button.innerHTML = 'Enter Raffle';
      button.disabled = false;
      state.enteringContest = null;
    }

    // Cast sharing modal functions - wrapper to read from data attributes (avoids URL escaping issues in onclick)
    function openCastModalFromData(button) {
      const contestId = button.dataset.contestId; // Keep as string for M-1, T-1 format
      const prize = decodeURIComponent(button.dataset.prize || '');
      const hoursLeft = parseInt(button.dataset.hours);
      const minutesLeft = parseInt(button.dataset.minutes);
      const volumeReq = parseFloat(button.dataset.volume) || 0;
      const tokenSymbol = decodeURIComponent(button.dataset.token || '');
      const hostUsername = decodeURIComponent(button.dataset.host || '');
      const castId = button.dataset.castId || '';
      const isNft = button.dataset.isNft === 'true';
      const nftImage = decodeURIComponent(button.dataset.nftImage || '');
      const winnerCount = parseInt(button.dataset.winnerCount) || 1;
      const participantCount = parseInt(button.dataset.participantCount) || 0;

      shareContest(contestId, prize, hoursLeft, minutesLeft, volumeReq, tokenSymbol, hostUsername, castId, isNft, nftImage, winnerCount, participantCount, button);
    }

    async function shareContest(contestId, prize, hoursLeft, minutesLeft, volumeReq, tokenSymbol, hostUsername, castId, isNft, nftImage, winnerCount = 1, participantCount = 0, buttonEl = null) {
      // Format prize text with $ for cashtag highlighting
      let prizeText;
      if (isNft) {
        prizeText = prize || 'an NFT';
      } else if (prize && tokenSymbol) {
        // Extract amount from prize (e.g., "0.01 ETH" -> "0.01")
        const amount = prize.replace(tokenSymbol, '').trim();
        prizeText = `${amount} $${tokenSymbol}`;
      } else {
        prizeText = prize || 'tokens';
      }

      // Format time remaining
      let timeLeft;
      if (hoursLeft > 0 && minutesLeft > 0) {
        timeLeft = `${hoursLeft}h ${minutesLeft}m`;
      } else if (hoursLeft > 0) {
        timeLeft = `${hoursLeft} hour${hoursLeft > 1 ? 's' : ''}`;
      } else {
        timeLeft = `${minutesLeft} minute${minutesLeft > 1 ? 's' : ''}`;
      }

      // Host tag
      const hostTag = hostUsername ? `@${hostUsername}'s` : 'a';

      // Mini app URL
      const miniAppUrl = `https://farcaster.xyz/miniapps/uaKwcOvUry8F/neynartodes?contestId=${contestId}`;

      // Build the share text
      let text = `I just entered ${hostTag} raffle for ${prizeText}!!! â±ï¸ ${timeLeft} left

powered by $NEYNARTODES ðŸ¦Ž
ðŸ‘‡ Head to the app to enter!
${miniAppUrl}`;

      console.log('Sharing contest with mini app URL:', { contestId, isNft, winnerCount, participantCount, miniAppUrl });

      // Build embeds - quote cast first, then proxied NFT image if available
      const embeds = [];
      if (castId) {
        const cleanCastHash = castId.split('|')[0]; // Strip encoded requirements
        embeds.push(`https://warpcast.com/~/conversations/${cleanCastHash}`);
      }
      // Add NFT image via our proxy (avoids IPFS 403 errors)
      if (isNft && nftImage) {
        const proxiedImage = `https://frame-opal-eight.vercel.app/api/image-proxy?url=${encodeURIComponent(nftImage)}`;
        embeds.push(proxiedImage);
      }

      // Record share for bonus entry (do this when user clicks Share, even before composing)
      const recordShare = async () => {
        if (!state.userFid) {
          console.log('Cannot record share: no FID');
          return;
        }

        try {
          const response = await fetch('/api/record-share', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              fid: state.userFid,
              contestId: contestId
            })
          });

          const result = await response.json();
          if (result.success) {
            if (result.shared) {
              // First time sharing - earned bonus
              showToast('Share recorded! You earned a bonus entry.', 'success');
              // Update button to show shared status
              if (buttonEl) {
                buttonEl.innerHTML = 'Shared âœ“';
                buttonEl.classList.remove('btn-secondary');
                buttonEl.classList.add('btn-success');
                buttonEl.style.opacity = '0.8';
              }
              // Track in state
              if (!state.contestShares) state.contestShares = {};
              state.contestShares[contestId] = true;
            } else if (result.alreadyShared) {
              console.log('Already shared this contest');
            }
          }
        } catch (e) {
          console.error('Failed to record share:', e);
        }
      };

      // Record share immediately when button clicked
      recordShare();

      // Use SDK composeCast - embeds as plain string array
      const sdk = window.FarcasterSDK;
      if (sdk && sdk.actions && typeof sdk.actions.composeCast === 'function') {
        try {
          await sdk.actions.composeCast({
            text: text,
            embeds: embeds.length > 0 ? embeds : undefined
          });
          return;
        } catch (e) {
          console.log('composeCast failed, falling back to URL:', e);
        }
      }

      // Fallback: Build Warpcast compose URL
      let warpcastUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}`;
      embeds.forEach(embed => {
        warpcastUrl += `&embeds[]=${encodeURIComponent(embed)}`;
      });
      window.open(warpcastUrl, '_blank');
    }

    // Share host leaderboard stats
    async function shareHostStats(host) {
      const rankEmoji = host.rank === 1 ? 'ðŸ¥‡' : host.rank === 2 ? 'ðŸ¥ˆ' : host.rank === 3 ? 'ðŸ¥‰' : `#${host.rank}`;
      const countdown = getSeasonCountdown();
      const timeLeft = countdown && !countdown.ended ? countdown.text : 'Season ended';

      // Calculate vote score and net votes
      const upvotes = host.upvotes || 0;
      const downvotes = host.downvotes || 0;
      const netVotes = upvotes - downvotes;
      const voteScore = host.voteScore || (netVotes * 200);

      // Social score breakdown: (LikesÃ—1 + RecastsÃ—2 + RepliesÃ—3) Ã— 100
      const likes = host.likes || 0;
      const recasts = host.recasts || 0;
      const replies = host.replies || 0;
      const socialRaw = (likes * 1) + (recasts * 2) + (replies * 3);
      const completedContests = host.completedContests || host.contests || 0;
      const socialMultiplier = host.socialMultiplier || completedContests;

      const text = `${rankEmoji} @${host.username} on the $NEYNARTODES Leaderboard!

ðŸ“Š Season ${state.currentSeason} Stats:
ðŸ† Total Score: ${(host.totalScore || 0).toLocaleString()} pts
ðŸŽ¯ Contests: ${completedContests} completed

ðŸ“ˆ Score Breakdown:
â€¢ Social: [â¤ï¸${likes}Ã—1] + [ðŸ”${recasts}Ã—2] + [ðŸ’¬${replies}Ã—3] = ${socialRaw} Ã— 100 = ${(host.socialScore || 0).toLocaleString()}
  â†’ Ã—${socialMultiplier} (contests) = ${((host.socialScore || 0) * socialMultiplier).toLocaleString()} pts
â€¢ ðŸ’° Token: ${(host.tokenHoldings || 0).toLocaleString()} holdings Ã· 50,000 = ${(host.tokenScore || 0).toLocaleString()}
â€¢ ðŸŽ¯ Host Bonus: ${(host.hostBonus || completedContests * 100 || 0).toLocaleString()} (100/contest)
â€¢ ðŸ—³ï¸ Votes: ${netVotes >= 0 ? '+' : ''}${netVotes} Ã— 200 = ${voteScore >= 0 ? '+' : ''}${voteScore.toLocaleString()} pts

ðŸ‘ ${upvotes} | ðŸ‘Ž ${downvotes} | â­ Neynar: ${host.neynarScore || 'N/A'}

â±ï¸ ${timeLeft} left in season
ðŸ¦Ž Check out the leaderboard!`;

      const sdk = window.FarcasterSDK;
      if (sdk && sdk.actions && typeof sdk.actions.composeCast === 'function') {
        try {
          await sdk.actions.composeCast({
            text: text,
            embeds: ['https://frame-opal-eight.vercel.app/']
          });
          return;
        } catch (e) {
          console.log('composeCast failed, falling back to URL:', e);
        }
      }

      // Fallback
      const warpcastUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}&embeds[]=${encodeURIComponent('https://frame-opal-eight.vercel.app/')}`;
      window.open(warpcastUrl, '_blank');
    }

    // Share season stats (prize pool, tokens burned, time remaining)
    async function shareSeasonStats() {
      const countdown = getSeasonCountdown();
      const timeLeft = countdown && !countdown.ended ? countdown.text : 'Season ended';

      const text = `ðŸ¦Ž $NEYNARTODES Season ${state.currentSeason} Stats!

â±ï¸ Time Remaining: ${timeLeft}
ðŸ’° Host Prize Pool: ${state.hostPoolETH.toFixed(4)} ETH
ðŸ”¥ Tokens Burned: ${Number(state.totalTokensBurned).toLocaleString()} $NEYNARTODES
ðŸ’Ž All-Time Prizes: ${state.totalPrizesGiven.toFixed(4)} ETH

Host contests to climb the leaderboard and win from the prize pool!`;

      const sdk = window.FarcasterSDK;
      if (sdk && sdk.actions && typeof sdk.actions.composeCast === 'function') {
        try {
          await sdk.actions.composeCast({
            text: text,
            embeds: ['https://frame-opal-eight.vercel.app/']
          });
          return;
        } catch (e) {
          console.log('composeCast failed, falling back to URL:', e);
        }
      }

      // Fallback
      const warpcastUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}&embeds[]=${encodeURIComponent('https://frame-opal-eight.vercel.app/')}`;
      window.open(warpcastUrl, '_blank');
    }

  </script>

  <script>
    // ===== CONFIGURATION =====
    const CONFIG = {
      NEYNAR_API_KEY: 'AA2E0FC2-FDC0-466D-9EBA-4BCA968C9B1D',
      BASE_RPC_URL: 'https://base-mainnet.g.alchemy.com/v2/QooWtq9nKQlkeqKF_-rvC',
      CHAIN_ID: 8453, // Base chain ID
      CONTRACTS: {
        // === LEGACY V1 Contracts (archived - read-only for historical data) ===
        contestEscrowLegacy: '0x0A8EAf7de19268ceF2d2bA4F9000c60680cAde7A',
        nftContestEscrowLegacy: '0xFD6e84d4396Ecaa144771C65914b2a345305F922',
        contestManagerV2Legacy: '0x91F7536E5Feafd7b1Ea0225611b02514B7c2eb06',

        // === NEW Unified ContestManager (M- and T- prefix contests) ===
        contestManager: '0xF56Fe30e1eAb5178da1AA2CbBf14d1e3C0Ba3944',
        buyBurnHoldEarn: '0xCfa90CfE67Ca3a08f862671Bd7Fb808662efAC28', // BuyBurnHoldEarn - distributes 25% entrant, 25% burn, 35% treasury, 15% host

        // === Shared Contracts ===
        prizeNFT: '0x54E3972839A79fB4D1b0F70418141723d02E56e1',
        votingManager: '0x267Bd7ae64DA1060153b47d6873a8830dA4236f8',
        treasury: '0xd4d84f3477eb482783aAB48F00e357C801c48928',
        neynartodes: '0x8de1622fe07f56cda2e2273e615a513f1d828b07'
      },
      // Test mode - creates T- prefix contests with separate counter
      TEST_MODE: true,  // Set to false for production M- prefix contests
      // Contest ID prefixes
      MAIN_PREFIX: 'M-',
      TEST_PREFIX: 'T-',
      // Banned FIDs - these users cannot create contests (scammers)
      BANNED_FIDS: [
        1990047,  // ropiik - scam token contests
      ],
      // Maintenance mode - blocks all users except admins
      MAINTENANCE_MODE: false,
      // Public testing mode - allows entry but hides create/leaderboard/history for non-admins
      PUBLIC_TESTING_MODE: true,
      ADMIN_FIDS: [
        1188162,  // brianwharton - app owner
        1891537,  // neynartodes - official account
      ]
    };

    // Helper to check if current user is admin
    function isUserAdmin() {
      const userFid = state.userFid || window.FarcasterContext?.user?.fid;
      return CONFIG.ADMIN_FIDS && userFid && CONFIG.ADMIN_FIDS.includes(userFid);
    }

    // ===== NFT ABIs (needed for approval and transfer flow) =====
    const ERC721_ABI = [
      'function approve(address to, uint256 tokenId) external',
      'function getApproved(uint256 tokenId) external view returns (address)',
      'function setApprovalForAll(address operator, bool approved) external',
      'function isApprovedForAll(address owner, address operator) external view returns (bool)',
      'function ownerOf(uint256 tokenId) external view returns (address)',
      'function safeTransferFrom(address from, address to, uint256 tokenId) external',
      'function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external'
    ];

    const ERC1155_ABI = [
      'function setApprovalForAll(address operator, bool approved) external',
      'function isApprovedForAll(address account, address operator) external view returns (bool)',
      'function balanceOf(address account, uint256 id) external view returns (uint256)'
    ];

    // ===== SHARED RPC PROVIDER (reduces duplicate connections) =====
    const rpcProvider = new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC_URL);

    // ===== API CACHE (reduces duplicate Neynar calls) =====
    const apiCache = new Map();
    function getCached(key, ttlMs = 60000) {
      const entry = apiCache.get(key);
      if (entry && Date.now() - entry.ts < ttlMs) return entry.data;
      return null;
    }
    function setCache(key, data, ttlMs = 60000) {
      apiCache.set(key, { data, ts: Date.now() });
      // Cleanup old entries if cache gets too large
      if (apiCache.size > 500) {
        const now = Date.now();
        for (const [k, v] of apiCache) {
          if (now - v.ts > ttlMs * 2) apiCache.delete(k);
        }
      }
    }

    // Cached Neynar API helper
    async function neynarFetch(endpoint, cacheTtlMs = 30000) {
      const cacheKey = `neynar:${endpoint}`;
      const cached = getCached(cacheKey, cacheTtlMs);
      if (cached) return cached;

      const res = await fetch(`https://api.neynar.com/v2/farcaster/${endpoint}`, {
        headers: { 'api_key': CONFIG.NEYNAR_API_KEY }
      });
      if (!res.ok) throw new Error(`Neynar API error: ${res.status}`);
      const data = await res.json();
      setCache(cacheKey, data, cacheTtlMs);
      return data;
    }

    // Dev wallets with unlimited privileges (no contest launch limit, no voting limit)
    const DEV_WALLETS = [
      '0x78EeAA6F014667A339fCF8b4eCd74743366603fb', // MetaMask
      '0xAB4F21321A7A16eb57171994C7D7D1C808506E5d'  // Farcaster
    ];
    const DEV_WALLET = DEV_WALLETS[0]; // Keep for backwards compat
    const isDevWallet = (addr) => DEV_WALLETS.some(w => w.toLowerCase() === addr?.toLowerCase());

    // ===== BASE APP / COINBASE SMART WALLET DETECTION =====
    // Detect if running in Base app or Coinbase browser for better wallet UX
    function isBaseAppContext() {
      return window.ethereum?.isCoinbaseWallet ||
             navigator.userAgent.includes('CoinbaseWallet') ||
             navigator.userAgent.includes('CoinbaseBrowser');
    }

    // Check if Coinbase Smart Wallet is available
    function hasCoinbaseSmartWallet() {
      return window.ethereum?.isCoinbaseWallet === true;
    }

    // ===== STATE =====
    const state = {
      // App loading
      isAppReady: false, // Prevents jumping by hiding content until ready

      // Auth
      isLoggedIn: false,
      isCheckingWhitelist: false,
      walletStatus: null, // Status message during wallet connection
      isWhitelisted: false,
      hasTokens: false,
      userAddress: '',
      userFid: null,
      userProfile: null, // Full Farcaster profile {fid, username, displayName, pfpUrl}
      userBalance: '0',
      currentView: 'active', // 'active', 'create', 'leaderboard', 'suggestions'
      pendingTx: null, // Pending transaction hash
      notificationsEnabled: null, // null = unknown, true = enabled, false = disabled
      notificationsWereReset: false, // true if notifications were reset by deployment

      // Voting
      votesRemaining: 10,
      votesUsedToday: 0,

      // Season & Prize Pool
      currentSeason: 0,
      seasonEndTime: null, // Unix timestamp when season ends
      prizePoolETH: 0,
      hostPoolETH: 0,  // On-chain host prize pool
      voterPoolETH: 0, // On-chain voter prize pool
      pendingClankerFees: '0', // Pending Clanker fees to collect
      totalTokensBurned: '0', // All-time Neynartodes burned from voting
      totalPrizesGiven: 0, // All-time prizes distributed (ETH)
      leaderboardLoaded: false, // Track if leaderboard has been lazy-loaded

      // Contest settings
      startMode: 'now', // 'now' or 'scheduled'
      startDate: '',
      endDate: '',
      durationHours: '1',
      durationMinutes: '0',
      upcomingContests: [], // Array of scheduled contests
      contestParticipants: {}, // Map of contestId -> { participants, count, hasMore }
      contestShares: {}, // Map of contestId -> true (user has shared)
      participantsModal: null, // { contestId, loading } for participants popup
      buyBurnHoldEarnModal: false, // Show Buy Burn Hold Earn details modal
      contestsLoading: true, // Loading state for contests
      headerAnimated: false, // Track if header has been animated
      prizeType: 'token', // 'token' or 'nft'
      prizeTokenAddress: '',
      prizeTokenAmount: '',
      prizeTokenTicker: '',
      prizeTokenImage: '',
      prizeTokenSearch: '',
      showPrizeTokenSuggestions: false,
      prizeTokenSearching: false, // Loading state for DexScreener search
      showCustomPrizeTokenModal: false, // Modal for adding custom prize token
      // NFT Prize fields
      prizeNftAddress: '',
      prizeNftTokenId: '',
      prizeNftImage: '',
      prizeNftName: '',
      prizeNftCollection: '',
      prizeNftType: '', // 'ERC721' or 'ERC1155'
      prizeNftAmount: '1', // For ERC1155
      loadingNftMetadata: false,
      // NFT Picker (browse user's wallet)
      showNftPicker: false,
      userNfts: [],
      loadingUserNfts: false,
      nftPickerPageKey: null, // For pagination
      nftPickerMode: 'picker', // 'picker' or 'manual'
      // NFT Approval state (two-step flow for reliable wallet handling)
      nftApprovalStatus: 'none', // 'none', 'pending', 'approved'
      nftApprovalTxHash: '',

      // Cast for contest
      castHash: '',
      showRecentCasts: false, // Toggle for recent casts dropdown
      recentCasts: [], // User's last 3 casts
      loadingRecentCasts: false,

      // Free Entries - when enabled, anyone can enter (no holder requirement)
      freeEntriesEnabled: false, // Default: require NEYNARTODES to enter
      tokenAddress: '0x8de1622fe07f56cda2e2273e615a513f1d828b07', // Always NEYNARTODES
      tokenTicker: 'NEYNARTODES',
      tokenSearching: false, // Loading state for token search (unused, requirement is fixed)
      winnerCount: 1, // Number of winners (1-5 for ETH/ERC20, always 1 for NFT)

      // Winner announcement
      customMessage: '',

      // Enter Raffle V2
      contestEntries: {},
      signerStatus: null,
      enteringContest: null,

      // Signer approval QR modal
      showSignerModal: false,
      signerApprovalUrl: null,

      // Cast sharing modal
      showCastModal: false,
      castModalText: '',
      castModalContestId: null,

      // Contest state
      contestLaunched: false,
      showCastPreview: false,
      announcementCast: '',
      contestActive: false,
      winner: null,
      totalParticipants: 0,
      contestStats: null,
      winnerCast: '',
      autoPosted: false,
      prizeReleased: false,

      // Leaderboard
      leaderboardData: [],

      // User badges
      userBadges: [],

      // Contest History
      historyData: [],
      historyLoading: false,
      historyError: null,
      historyTotal: 0,
      historyTotalToken: 0,
      historyTotalV2: 0,

      // Suggestions (anonymous)
      suggestions: [],
      suggestionText: '',
      suggestionsLoading: false
    };

    // ===== TOKEN DATABASE =====
    // Popular Base network tokens (fallback/cache)
    let tokenDatabase = [
      {
        name: 'Ethereum',
        ticker: 'ETH',
        address: '0x4200000000000000000000000000000000000006', // WETH on Base
        mcap: 450000000000,
        supply: 120000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png'
      },
      {
        name: 'USD Coin',
        ticker: 'USDC',
        address: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base
        mcap: 35000000000,
        supply: 35000000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png'
      },
      {
        name: 'Neynartodes',
        ticker: 'NEYNARTODES',
        address: '0x8de1622fe07f56cda2e2273e615a513f1d828b07',
        mcap: 85000,
        supply: 1000000000,
        image: 'https://i.imgur.com/placeholder-neynartodes.png'
      },
      {
        name: 'Dai Stablecoin',
        ticker: 'DAI',
        address: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb', // DAI on Base
        mcap: 5000000000,
        supply: 5000000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png'
      },
      {
        name: 'Aerodrome Finance',
        ticker: 'AERO',
        address: '0x940181a94A35A4569E4529A3CDfB74e38FD98631',
        mcap: 500000000,
        supply: 500000000,
        image: 'https://assets.coingecko.com/coins/images/31745/small/token.png'
      },
      {
        name: 'Brett',
        ticker: 'BRETT',
        address: '0x532f27101965dd16442E59d40670FaF5eBB142E4',
        mcap: 100000000,
        supply: 10000000000,
        image: 'https://assets.coingecko.com/coins/images/35711/small/brett.jpg'
      }
    ];

    // Cache for API token results
    let tokenCache = new Map();
    let lastFetchTime = 0;

    // ===== LOCALSTORAGE HELPERS FOR CUSTOM TOKENS =====
    const CUSTOM_TOKENS_KEY = 'neynartodes_custom_tokens';
    const ONE_YEAR_MS = 365 * 24 * 60 * 60 * 1000; // 1 year in milliseconds

    // Load custom tokens from localStorage (filters out expired ones)
    function loadCustomTokens() {
      try {
        const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
        if (!stored) return [];

        const data = JSON.parse(stored);
        const now = Date.now();

        // Filter out expired tokens (older than 1 year)
        const validTokens = data.filter(item => {
          return item.expiresAt && item.expiresAt > now;
        });

        // Save back the filtered list if we removed any expired tokens
        if (validTokens.length !== data.length) {
          localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(validTokens));
        }

        return validTokens.map(item => item.token);
      } catch (error) {
        console.warn('Failed to load custom tokens from localStorage:', error);
        return [];
      }
    }

    // Save a custom token to localStorage with 1-year expiration
    function saveCustomToken(token) {
      try {
        const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
        let data = stored ? JSON.parse(stored) : [];
        const now = Date.now();

        // Check if token already exists (by address)
        const existingIndex = data.findIndex(item =>
          item.token.address.toLowerCase() === token.address.toLowerCase()
        );

        if (existingIndex >= 0) {
          // Update expiration date for existing token
          data[existingIndex].expiresAt = now + ONE_YEAR_MS;
        } else {
          // Add new token with expiration
          data.push({
            token: token,
            expiresAt: now + ONE_YEAR_MS,
            addedAt: now
          });
        }

        localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(data));
        console.log(`Saved custom token ${token.ticker} to localStorage (expires in 1 year)`);
      } catch (error) {
        console.warn('Failed to save custom token to localStorage:', error);
      }
    }

    // ===== UTILITY FUNCTIONS =====
    // Fetch tokens from multiple sources for comprehensive Base token coverage
    async function fetchBaseTokens() {
      try {
        // First, load custom tokens from localStorage
        const customTokens = loadCustomTokens();
        if (customTokens.length > 0) {
          const existing = new Set(tokenDatabase.map(t => t.address.toLowerCase()));
          customTokens.forEach(token => {
            if (!existing.has(token.address.toLowerCase())) {
              tokenDatabase.push(token);
              existing.add(token.address.toLowerCase());
            }
          });
          console.log(`Loaded ${customTokens.length} custom tokens from localStorage`);
        }

        // Try multiple token list sources
        const tokenListUrls = [
          'https://tokens.coingecko.com/base/all.json', // CoinGecko Base tokens
          'https://raw.githubusercontent.com/Uniswap/default-token-list/main/build/uniswap-default.tokenlist.json', // Uniswap default
          'https://tokens.1inch.io/v1.1/8453' // 1inch Base tokens (chainId 8453)
        ];

        for (const url of tokenListUrls) {
          try {
            const response = await fetch(url);
            if (!response.ok) continue;

            const data = await response.json();
            let tokens = [];

            // Handle different token list formats
            if (data.tokens && Array.isArray(data.tokens)) {
              // Uniswap/CoinGecko format
              tokens = data.tokens.filter(t => t.chainId === 8453 || !t.chainId); // Base chainId is 8453
            } else if (typeof data === 'object' && !Array.isArray(data)) {
              // 1inch format (object with addresses as keys)
              tokens = Object.values(data);
            }

            if (tokens.length > 0) {
              const newTokens = tokens.map(token => ({
                name: token.name,
                ticker: token.symbol,
                address: (token.address || '').toLowerCase(),
                mcap: token.marketCap || 1000000,
                supply: token.totalSupply || 1000000000,
                image: token.logoURI || token.logo || `https://via.placeholder.com/40/9333ea/ffffff?text=${token.symbol?.[0] || '?'}`
              })).filter(t => t.address && t.address.startsWith('0x'));

              // Merge unique tokens
              const existing = new Set(tokenDatabase.map(t => t.address.toLowerCase()));
              newTokens.forEach(token => {
                if (!existing.has(token.address)) {
                  tokenDatabase.push(token);
                  existing.add(token.address);
                }
              });

              console.log(`Loaded ${newTokens.length} Base tokens from token list`);
              break; // Success, stop trying other sources
            }
          } catch (err) {
            console.warn('Failed to fetch from', url, err);
            continue; // Try next source
          }
        }
      } catch (error) {
        console.warn('Failed to fetch Base token lists, using fallback:', error);
      }
    }

    // Search tokens (synchronous search through cached database)
    function searchTokens(query) {
      if (!query || query.length < 2) return [];
      const q = query.toLowerCase();
      return tokenDatabase.filter(token =>
        token.name.toLowerCase().includes(q) ||
        token.ticker.toLowerCase().includes(q) ||
        token.address.toLowerCase().includes(q)
      ).slice(0, 20); // Limit to 20 results for performance
    }

    // ===== DEXSCREENER REAL-TIME TOKEN SEARCH =====
    // Debounce utility
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Search DexScreener API for tokens on Base
    async function searchDexScreener(query) {
      if (!query || query.length < 2) return [];

      try {
        // DexScreener search endpoint
        const response = await fetch(`https://api.dexscreener.com/latest/dex/search?q=${encodeURIComponent(query)}`);
        if (!response.ok) return [];

        const data = await response.json();
        if (!data.pairs || !Array.isArray(data.pairs)) return [];

        // Filter for Base chain (chainId: base) and extract unique tokens
        const baseTokens = new Map();
        data.pairs
          .filter(pair => pair.chainId === 'base')
          .forEach(pair => {
            // Add base token if matches query
            if (pair.baseToken && !baseTokens.has(pair.baseToken.address.toLowerCase())) {
              const token = pair.baseToken;
              if (token.name?.toLowerCase().includes(query.toLowerCase()) ||
                  token.symbol?.toLowerCase().includes(query.toLowerCase())) {
                baseTokens.set(token.address.toLowerCase(), {
                  name: token.name || token.symbol,
                  ticker: token.symbol,
                  address: token.address.toLowerCase(),
                  mcap: pair.marketCap || pair.fdv || 1000000,
                  supply: 1000000000,
                  image: `https://dd.dexscreener.com/ds-data/tokens/base/${token.address.toLowerCase()}.png`,
                  priceUsd: pair.priceUsd,
                  source: 'dexscreener'
                });
              }
            }
          });

        return Array.from(baseTokens.values()).slice(0, 10);
      } catch (error) {
        console.warn('DexScreener search failed:', error);
        return [];
      }
    }

    // Lookup token by contract address on DexScreener
    async function lookupTokenByAddress(address) {
      if (!address || !address.startsWith('0x') || address.length !== 42) return null;

      try {
        const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${address}`);
        if (!response.ok) return null;

        const data = await response.json();
        if (!data.pairs || data.pairs.length === 0) return null;

        // Find Base chain pair
        const basePair = data.pairs.find(p => p.chainId === 'base');
        if (!basePair) return null;

        const token = basePair.baseToken.address.toLowerCase() === address.toLowerCase()
          ? basePair.baseToken
          : basePair.quoteToken;

        return {
          name: token.name || token.symbol,
          ticker: token.symbol,
          address: token.address.toLowerCase(),
          mcap: basePair.marketCap || basePair.fdv || 1000000,
          supply: 1000000000,
          image: `https://dd.dexscreener.com/ds-data/tokens/base/${token.address.toLowerCase()}.png`,
          priceUsd: basePair.priceUsd,
          source: 'dexscreener'
        };
      } catch (error) {
        console.warn('DexScreener address lookup failed:', error);
        return null;
      }
    }

    // Enhanced token search with DexScreener fallback
    let dexScreenerSearchTimeout = null;
    let lastDexScreenerResults = [];

    async function enhancedTokenSearch(query, targetDropdown = 'prize') {
      // First, do local search
      const localResults = searchTokens(query);

      // Check if query looks like a contract address
      const isAddress = query.startsWith('0x') && query.length >= 10;

      // If we have enough local results and it's not an address, use them
      if (localResults.length >= 3 && !isAddress) {
        lastDexScreenerResults = [];
        return localResults;
      }

      // Show loading indicator
      if (targetDropdown === 'prize') {
        state.prizeTokenSearching = true;
        updatePrizeTokenDropdown();
      } else {
        state.tokenSearching = true;
        updateTokenDropdown();
      }

      try {
        let dexResults = [];

        if (isAddress) {
          // Direct address lookup
          const token = await lookupTokenByAddress(query);
          if (token) {
            dexResults = [token];
          }
        } else {
          // Search by name/ticker
          dexResults = await searchDexScreener(query);
        }

        // Merge results, avoiding duplicates
        const existingAddresses = new Set(localResults.map(t => t.address.toLowerCase()));
        const newResults = dexResults.filter(t => !existingAddresses.has(t.address.toLowerCase()));

        // Add new tokens to database for future local searches
        newResults.forEach(token => {
          if (!tokenDatabase.find(t => t.address.toLowerCase() === token.address.toLowerCase())) {
            tokenDatabase.push(token);
            // Save to localStorage for persistence
            saveCustomToken(token);
          }
        });

        lastDexScreenerResults = newResults;
        return [...localResults, ...newResults];
      } catch (error) {
        console.warn('Enhanced token search failed:', error);
        lastDexScreenerResults = [];
        return localResults;
      } finally {
        // Hide loading indicator
        if (targetDropdown === 'prize') {
          state.prizeTokenSearching = false;
          updatePrizeTokenDropdown();
        } else {
          state.tokenSearching = false;
          updateTokenDropdown();
        }
      }
    }

    // Debounced version for use in input handlers
    const debouncedEnhancedSearch = debounce(async (query, targetDropdown) => {
      await enhancedTokenSearch(query, targetDropdown);
    }, 400);

    // Fetch NFT metadata using Alchemy API (handles all NFT types, avoids CORS issues)
    async function fetchNftMetadata(contractAddress, tokenId) {
      try {
        // Use our server-side API which calls Alchemy's getNFTMetadata
        const url = `/api/get-user-nfts?contract=${contractAddress}&tokenId=${encodeURIComponent(tokenId)}`;
        const response = await fetch(url);
        const result = await response.json();

        if (!result.success) {
          throw new Error(result.error || 'Failed to fetch NFT metadata');
        }

        return {
          success: true,
          name: result.name,
          collection: result.collection,
          image: result.image,
          type: result.tokenType,
          description: result.description || '',
          attributes: result.attributes || [],
          floorPrice: result.floorPrice || null, // Floor price in ETH from OpenSea
        };
      } catch (error) {
        console.error('NFT metadata fetch error:', error);
        return {
          success: false,
          error: error.message
        };
      }
    }

    // Handle NFT address/tokenId input and fetch metadata
    async function loadNftMetadata() {
      const address = state.prizeNftAddress.trim();
      const tokenId = state.prizeNftTokenId.trim();

      if (!address || !tokenId) {
        showToast('Enter both NFT contract address and Token ID', 'warning');
        return;
      }

      if (!ethers.utils.isAddress(address)) {
        showToast('Invalid contract address', 'error');
        return;
      }

      state.loadingNftMetadata = true;
      render();

      const result = await fetchNftMetadata(address, tokenId);

      state.loadingNftMetadata = false;

      if (result.success) {
        // Verify ownership before allowing selection
        const rpcProvider = new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC_URL);
        const nftType = result.type || 'ERC721';
        let ownsNft = false;

        try {
          if (nftType === 'ERC721') {
            const nft = new ethers.Contract(address, ERC721_ABI, rpcProvider);
            const owner = await nft.ownerOf(tokenId);
            ownsNft = owner.toLowerCase() === state.userAddress.toLowerCase();
            if (!ownsNft) {
              console.log('NFT owned by:', owner, 'User address:', state.userAddress);
            }
          } else if (nftType === 'ERC1155') {
            const nft = new ethers.Contract(address, ERC1155_ABI, rpcProvider);
            const balance = await nft.balanceOf(state.userAddress, tokenId);
            ownsNft = balance.gt(0);
          }
        } catch (ownerErr) {
          console.error('Error verifying NFT ownership:', ownerErr);
          showToast('Could not verify NFT ownership', 'error');
          state.loadingNftMetadata = false;
          render();
          return;
        }

        if (!ownsNft) {
          showToast('You do not own this NFT! It may have been used in a previous contest.', 'error');
          state.prizeNftImage = '';
          state.prizeNftName = '';
          state.prizeNftCollection = '';
          state.prizeNftType = '';
          state.loadingNftMetadata = false;
          render();
          return;
        }

        state.prizeNftImage = result.image;
        state.prizeNftName = result.name;
        state.prizeNftCollection = result.collection;
        state.prizeNftType = result.type;
        state.prizeNftFloorPrice = result.floorPrice; // Floor price in ETH for value tracking
        const floorMsg = result.floorPrice ? ` (Floor: ${result.floorPrice} ETH)` : '';
        showToast(`Loaded: ${result.name}${floorMsg}`, 'success');
        // Check if NFT is already approved
        await checkNftApprovalStatus();
      } else {
        state.prizeNftImage = '';
        state.prizeNftName = '';
        state.prizeNftCollection = '';
        state.prizeNftType = '';
        state.prizeNftFloorPrice = null;
        state.nftApprovalStatus = 'none';
        showToast(`Failed to load NFT: ${result.error}`, 'error');
      }

      render();
    }

    // Fetch user's NFTs from their wallet
    async function fetchUserNfts(loadMore = false) {
      if (!state.userAddress) {
        showToast('Please connect your wallet first', 'warning');
        return;
      }

      state.loadingUserNfts = true;
      if (!loadMore) {
        state.userNfts = [];
        state.nftPickerPageKey = null;
      }
      render();

      try {
        let url = `/api/get-user-nfts?address=${state.userAddress}`;
        if (loadMore && state.nftPickerPageKey) {
          url += `&pageKey=${state.nftPickerPageKey}`;
        }

        const response = await fetch(url);
        const data = await response.json();

        if (data.success) {
          if (loadMore) {
            state.userNfts = [...state.userNfts, ...data.nfts];
          } else {
            state.userNfts = data.nfts;
          }
          state.nftPickerPageKey = data.pageKey;

          if (data.nfts.length === 0 && !loadMore) {
            showToast('No NFTs found in your wallet', 'info');
          }
        } else {
          showToast('Failed to load NFTs: ' + data.error, 'error');
        }
      } catch (error) {
        console.error('Error fetching user NFTs:', error);
        showToast('Failed to load NFTs', 'error');
      }

      state.loadingUserNfts = false;
      render();
    }

    // Select an NFT from the picker
    async function selectNftFromPicker(nft) {
      // Verify ownership on-chain before selecting (picker data may be stale)
      const rpcProvider = new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC_URL);
      const nftType = nft.tokenType || 'ERC721';
      let ownsNft = false;

      try {
        if (nftType === 'ERC721') {
          const nftContract = new ethers.Contract(nft.contractAddress, ERC721_ABI, rpcProvider);
          const owner = await nftContract.ownerOf(nft.tokenId);
          ownsNft = owner.toLowerCase() === state.userAddress.toLowerCase();
        } else if (nftType === 'ERC1155') {
          const nftContract = new ethers.Contract(nft.contractAddress, ERC1155_ABI, rpcProvider);
          const balance = await nftContract.balanceOf(state.userAddress, nft.tokenId);
          ownsNft = balance.gt(0);
        }
      } catch (ownerErr) {
        console.error('NFT ownership check failed:', ownerErr);
        showToast('Could not verify NFT ownership', 'error');
        return;
      }

      if (!ownsNft) {
        showToast('You no longer own this NFT! It may have been used in a previous contest.', 'error');
        // Remove from userNfts list since it's stale
        state.userNfts = state.userNfts.filter(n =>
          !(n.contractAddress === nft.contractAddress && n.tokenId === nft.tokenId)
        );
        render();
        return;
      }

      state.prizeNftAddress = nft.contractAddress;
      state.prizeNftTokenId = nft.tokenId;
      state.prizeNftImage = nft.image;
      state.prizeNftName = nft.name;
      state.prizeNftCollection = nft.collection;
      state.prizeNftType = nft.tokenType;
      state.prizeNftAmount = nft.tokenType === 'ERC1155' ? String(nft.balance) : '1';
      state.prizeNftFloorPrice = nft.floorPrice || null; // Floor price in ETH for value tracking
      state.showNftPicker = false;
      state.nftApprovalStatus = 'none';

      const floorMsg = nft.floorPrice ? ` (Floor: ${nft.floorPrice} ETH)` : '';
      showToast(`Selected: ${nft.name}${floorMsg}`, 'success');

      // Check approval status for the selected NFT
      checkNftApprovalStatus();
      render();
    }

    // Toggle NFT picker mode
    function toggleNftPickerMode() {
      state.nftPickerMode = state.nftPickerMode === 'picker' ? 'manual' : 'picker';
      render();
    }

    // Open NFT picker
    function openNftPicker() {
      state.showNftPicker = true;
      if (state.userNfts.length === 0 && !state.loadingUserNfts) {
        fetchUserNfts();
      }
      render();
    }

    // Close NFT picker
    function closeNftPicker() {
      state.showNftPicker = false;
      render();
    }

    // Approve NFT for escrow (Step 1 of NFT contest creation)
    // This is a separate step to ensure the wallet properly sequences transactions
    async function approveNftForEscrow() {
      if (!state.prizeNftAddress || !state.prizeNftType) {
        showToast('Please load the NFT first', 'warning');
        return;
      }

      if (!state.userAddress) {
        showToast('Please connect your wallet first', 'error');
        return;
      }

      // Get the Ethereum provider from Farcaster SDK or fallback to window.ethereum
      let ethProvider = null;
      const sdk = window.FarcasterSDK;
      if (sdk && typeof sdk.wallet?.getEthereumProvider === 'function') {
        ethProvider = sdk.wallet.getEthereumProvider();
        if (ethProvider && typeof ethProvider.then === 'function') {
          ethProvider = await ethProvider;
        }
      }
      if (!ethProvider && window.ethereum) {
        ethProvider = window.ethereum;
      }
      if (!ethProvider) {
        showToast('Wallet provider not available', 'error');
        return;
      }

      state.nftApprovalStatus = 'pending';
      render();

      try {
        const signerAddress = state.userAddress;
        // Use BigInt for large token IDs (e.g., Basenames)
        const tokenId = state.prizeNftTokenId ? BigInt(state.prizeNftTokenId) : 0n;

        console.log('NFT Approval Debug:', {
          nftAddress: state.prizeNftAddress,
          nftType: state.prizeNftType,
          tokenId: tokenId,
          signerAddress: signerAddress,
          escrowAddress: CONFIG.CONTRACTS.contestManager
        });

        // Check if already approved
        const nftContract = new ethers.Contract(
          state.prizeNftAddress,
          state.prizeNftType === 'ERC721' ? ERC721_ABI : ERC1155_ABI,
          rpcProvider
        );

        let isAlreadyApproved = false;
        try {
          if (state.prizeNftType === 'ERC721') {
            const approved = await nftContract.getApproved(tokenId);
            const isApprovedForAll = await nftContract.isApprovedForAll(signerAddress, CONFIG.CONTRACTS.contestManager);
            console.log('ERC721 approval check:', { approved, isApprovedForAll, escrow: CONFIG.CONTRACTS.contestManager });
            isAlreadyApproved = approved.toLowerCase() === CONFIG.CONTRACTS.contestManager.toLowerCase() || isApprovedForAll;
          } else {
            isAlreadyApproved = await nftContract.isApprovedForAll(signerAddress, CONFIG.CONTRACTS.contestManager);
            console.log('ERC1155 approval check:', { isAlreadyApproved });
          }
        } catch (checkErr) {
          console.log('Approval check error (may be normal for some NFTs):', checkErr.message);
        }

        if (isAlreadyApproved) {
          state.nftApprovalStatus = 'approved';
          showToast('NFT already approved! You can now create the contest.', 'success');
          render();
          return;
        }

        // Send approval transaction
        const approveIface = new ethers.utils.Interface(state.prizeNftType === 'ERC721' ? ERC721_ABI : ERC1155_ABI);
        const approveData = approveIface.encodeFunctionData('setApprovalForAll', [
          CONFIG.CONTRACTS.contestManager,
          true
        ]);

        const txParams = {
          from: signerAddress,
          to: state.prizeNftAddress,
          data: approveData
        };

        console.log('Sending approval tx with params:', txParams);
        console.log('Encoded data:', approveData);

        // Try to estimate gas first to catch errors early
        try {
          const gasEstimate = await rpcProvider.estimateGas({
            from: signerAddress,
            to: state.prizeNftAddress,
            data: approveData
          });
          console.log('Gas estimate:', gasEstimate.toString());
        } catch (gasErr) {
          console.error('Gas estimation failed:', gasErr.message);
          console.error('Full error:', gasErr);
          showToast(`Transaction would fail: ${gasErr.reason || gasErr.message}`, 'error');
          state.nftApprovalStatus = 'failed';
          render();
          return;
        }

        const approveTxHash = await ethProvider.request({
          method: 'eth_sendTransaction',
          params: [txParams]
        });

        console.log('NFT approval tx hash:', approveTxHash);
        state.nftApprovalTxHash = approveTxHash;
        showToast('Approval submitted! Waiting for confirmation...', 'info');
        render();

        // Wait for transaction to be mined
        let txReceipt = null;
        for (let i = 0; i < 60; i++) {
          try {
            const receipt = await rpcProvider.getTransactionReceipt(approveTxHash);
            if (receipt && receipt.blockNumber) {
              txReceipt = receipt;
              console.log('=== APPROVAL TX RECEIPT ===');
              console.log('Block number:', receipt.blockNumber);
              console.log('Status:', receipt.status, '(1=success, 0=failed)');
              console.log('Gas used:', receipt.gasUsed?.toString());
              console.log('From:', receipt.from);
              console.log('To:', receipt.to);
              console.log('Logs:', receipt.logs?.length || 0, 'events');
              if (receipt.status === 0) {
                console.error('APPROVAL TRANSACTION FAILED ON-CHAIN!');
                showToast('Approval transaction failed on-chain!', 'error');
                state.nftApprovalStatus = 'failed';
                render();
                return;
              }
              break;
            }
          } catch (e) {
            // Receipt not yet available
          }
          await new Promise(r => setTimeout(r, 2000));
        }

        if (!txReceipt) {
          console.warn('Could not get transaction receipt after 2 minutes');
        }

        // Verify approval is confirmed on-chain
        console.log('=== VERIFYING APPROVAL ON-CHAIN ===');
        console.log('Checking approval for:');
        console.log('  NFT Contract:', state.prizeNftAddress);
        console.log('  Owner:', signerAddress);
        console.log('  Operator (contestManager):', CONFIG.CONTRACTS.contestManager);

        // Use shared rpcProvider instead of creating new one each iteration
        const verifyContract = new ethers.Contract(
          state.prizeNftAddress,
          state.prizeNftType === 'ERC721' ? ERC721_ABI : ERC1155_ABI,
          rpcProvider
        );

        for (let i = 0; i < 10; i++) {
          await new Promise(r => setTimeout(r, 2000));

          const nowApproved = await verifyContract.isApprovedForAll(signerAddress, CONFIG.CONTRACTS.contestManager);
          console.log(`Approval check attempt ${i + 1}: isApprovedForAll =`, nowApproved);
          if (nowApproved) {
            console.log('=== APPROVAL CONFIRMED ===');
            state.nftApprovalStatus = 'approved';
            showToast('NFT approved! You can now create the contest.', 'success');
            render();
            return;
          }
        }

        // Approval didn't confirm in time
        state.nftApprovalStatus = 'none';
        showToast('Approval may still be pending. Please try again or check BaseScan.', 'warning');
        render();

      } catch (error) {
        console.error('NFT approval error:', error);
        state.nftApprovalStatus = 'none';
        showToast('Failed to approve NFT: ' + (error.message || error), 'error');
        render();
      }
    }

    // Check if NFT is currently approved for escrow
    async function checkNftApprovalStatus() {
      if (!state.prizeNftAddress || !state.prizeNftType || !state.userAddress) {
        state.nftApprovalStatus = 'none';
        return;
      }

      try {
        const nftContract = new ethers.Contract(
          state.prizeNftAddress,
          state.prizeNftType === 'ERC721' ? ERC721_ABI : ERC1155_ABI,
          rpcProvider
        );

        // Use BigInt for large token IDs (e.g., Basenames)
        const tokenId = state.prizeNftTokenId ? BigInt(state.prizeNftTokenId) : 0n;
        let isApproved = false;

        if (state.prizeNftType === 'ERC721') {
          const approved = await nftContract.getApproved(tokenId);
          const isApprovedForAll = await nftContract.isApprovedForAll(state.userAddress, CONFIG.CONTRACTS.contestManager);
          isApproved = approved.toLowerCase() === CONFIG.CONTRACTS.contestManager.toLowerCase() || isApprovedForAll;
        } else {
          isApproved = await nftContract.isApprovedForAll(state.userAddress, CONFIG.CONTRACTS.contestManager);
        }

        state.nftApprovalStatus = isApproved ? 'approved' : 'none';
      } catch (e) {
        console.error('Error checking NFT approval:', e);
        state.nftApprovalStatus = 'none';
      }
    }

    function getBadgeMultiplier(badges) {
      if (!badges || badges.length === 0) return 1;
      let multiplier = 1;
      badges.forEach(badge => {
        if (badge === 'gold') multiplier += 2;
        else if (badge === 'silver') multiplier += 1;
        else if (badge === 'bronze') multiplier += 0.5;
        else if (badge === 'purple') multiplier += 0.25;
      });
      return multiplier;
    }

    function getBadgeEmoji(badge) {
      if (badge === 'gold') return 'ðŸ¥‡';
      if (badge === 'silver') return 'ðŸ¥ˆ';
      if (badge === 'bronze') return 'ðŸ¥‰';
      if (badge === 'purple') return 'ðŸŸ£';
      if (badge === 'season0_beta') return 'ðŸ¦Ž';
      return '';
    }

    function getBadgeTitle(badge) {
      if (badge === 'gold') return 'Gold Badge';
      if (badge === 'silver') return 'Silver Badge';
      if (badge === 'bronze') return 'Bronze Badge';
      if (badge === 'purple') return 'Purple Badge';
      if (badge === 'season0_beta') return 'Season 0 Beta Tester - Forever OG';
      return badge;
    }

    // ===== SEASON 0 BETA BADGE TRACKING =====
    function getSeasonTesterBadges() {
      try {
        const stored = localStorage.getItem('season0_beta_participants');
        return stored ? JSON.parse(stored) : {};
      } catch (e) {
        return {};
      }
    }

    function awardSeasonBetaBadge(fid, username) {
      if (state.currentSeason === 0 || state.currentSeason === 1) {
        try {
          const badges = getSeasonTesterBadges();
          if (!badges[fid]) {
            badges[fid] = {
              username: username,
              awardedAt: Date.now(),
              season: state.currentSeason
            };
            localStorage.setItem('season0_beta_participants', JSON.stringify(badges));
            console.log(`ðŸ¦Ž Season 0 Beta badge awarded to @${username} (FID: ${fid})`);
          }
        } catch (e) {
          console.error('Failed to award Season 0 Beta badge:', e);
        }
      }
    }

    function hasSeasonBetaBadge(fid) {
      const badges = getSeasonTesterBadges();
      return !!badges[fid];
    }

    // ===== CAST VALIDATION =====
    // Extract cast hash and username from URL or raw hash
    // Returns { hash, username } - username is only set for farcaster.xyz URLs with short hashes
    function extractCastInfo(input) {
      if (!input) return { hash: null, username: null };
      input = input.trim();

      // Extract from Farcaster.xyz URL: https://farcaster.xyz/username/0x1234abcd
      // These use SHORT hashes that need to be resolved
      const farcasterMatch = input.match(/farcaster\.xyz\/([^/]+)\/(0x[a-fA-F0-9]+)/i);
      if (farcasterMatch) {
        const username = farcasterMatch[1].toLowerCase();
        const hash = farcasterMatch[2].toLowerCase();
        // farcaster.xyz uses short hashes (10 chars like 0x539e9184)
        // Full hashes are 66 chars (0x + 64 hex)
        const isShortHash = hash.length < 42;
        return { hash, username: isShortHash ? username : null };
      }

      // If it's already a hash (starts with 0x)
      if (input.startsWith('0x')) {
        return { hash: input.toLowerCase(), username: null };
      }

      // Extract from Warpcast URL: https://warpcast.com/username/0x1234abcd
      const warpcastMatch = input.match(/warpcast\.com\/[^/]+\/(0x[a-fA-F0-9]+)/i);
      if (warpcastMatch) {
        return { hash: warpcastMatch[1].toLowerCase(), username: null };
      }

      // Try to find any 0x hash in the string
      const hashMatch = input.match(/(0x[a-fA-F0-9]{8,})/i);
      if (hashMatch) {
        return { hash: hashMatch[1].toLowerCase(), username: null };
      }

      return { hash: null, username: null };
    }

    // Legacy function for backwards compatibility
    function extractCastHash(input) {
      return extractCastInfo(input).hash;
    }

    // Resolve a short hash to full hash by looking up user's casts
    async function resolveShortHash(shortHash, username) {
      try {
        console.log(`Resolving short hash ${shortHash} for user ${username}`);

        // Method 1: Try Neynar cast lookup API directly with short hash
        // Sometimes this works if the hash is unique enough
        try {
          const directResponse = await fetch(`https://api.neynar.com/v2/farcaster/cast?identifier=${shortHash}&type=hash`, {
            headers: {
              'accept': 'application/json',
              'api_key': CONFIG.NEYNAR_API_KEY
            }
          });

          if (directResponse.ok) {
            const directData = await directResponse.json();
            if (directData.cast?.hash) {
              console.log(`Direct lookup resolved ${shortHash} to: ${directData.cast.hash}`);
              return directData.cast.hash;
            }
          }
        } catch (e) {
          console.log('Direct lookup failed, trying user casts method');
        }

        // Method 2: Get user's FID and search their casts
        const userResponse = await fetch(`https://api.neynar.com/v2/farcaster/user/by_username?username=${username}`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        if (!userResponse.ok) {
          console.log('Could not find user:', username);
          return null;
        }

        const userData = await userResponse.json();
        const fid = userData.user?.fid;
        if (!fid) return null;

        // Fetch user's casts with pagination to find older casts
        let cursor = null;
        let attempts = 0;
        const maxAttempts = 4; // Check up to ~400 casts

        while (attempts < maxAttempts) {
          const url = cursor
            ? `https://api.neynar.com/v2/farcaster/feed/user/casts?fid=${fid}&limit=100&cursor=${cursor}`
            : `https://api.neynar.com/v2/farcaster/feed/user/casts?fid=${fid}&limit=100`;

          const castsResponse = await fetch(url, {
            headers: {
              'accept': 'application/json',
              'api_key': CONFIG.NEYNAR_API_KEY
            }
          });

          if (!castsResponse.ok) break;

          const castsData = await castsResponse.json();

          // Find the cast that starts with the short hash
          const matchingCast = castsData.casts?.find(cast =>
            cast.hash.toLowerCase().startsWith(shortHash.toLowerCase())
          );

          if (matchingCast) {
            console.log(`Resolved ${shortHash} to full hash: ${matchingCast.hash}`);
            return matchingCast.hash;
          }

          // Check if there are more casts to fetch
          cursor = castsData.next?.cursor;
          if (!cursor || !castsData.casts?.length) break;

          attempts++;
        }

        console.log(`No cast found starting with ${shortHash} after checking ${(attempts + 1) * 100} casts`);
        return null;
      } catch (e) {
        console.error('Error resolving short hash:', e);
        return null;
      }
    }

    // Validate cast exists via Neynar API
    // Can accept either a hash directly or a raw URL input (for short hash resolution)
    async function validateCast(castHashOrInput, rawInput = null) {
      try {
        let castHash = castHashOrInput;

        // If rawInput is provided, try to resolve short hashes from farcaster.xyz URLs
        if (rawInput) {
          const castInfo = extractCastInfo(rawInput);
          if (castInfo.username && castInfo.hash && castInfo.hash.length < 42) {
            // This is a short hash from farcaster.xyz - resolve it
            console.log(`Detected short hash ${castInfo.hash} from farcaster.xyz, resolving...`);
            const fullHash = await resolveShortHash(castInfo.hash, castInfo.username);
            if (fullHash) {
              castHash = fullHash;
            } else {
              return {
                valid: false,
                error: `Could not resolve short hash ${castInfo.hash} for user @${castInfo.username}.\n\nThe cast may be older than recent history. Try using the full Warpcast URL instead.`
              };
            }
          }
        }

        console.log('Validating cast hash:', castHash);

        const response = await fetch(`https://api.neynar.com/v2/farcaster/cast?identifier=${castHash}&type=hash`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        const data = await response.json();
        console.log('Neynar API response:', data);

        if (!response.ok || data.code === 'NotFound') {
          return {
            valid: false,
            error: `Cast not found for hash: ${castHash}\n\nMake sure you copied the full URL from Warpcast.\nNew casts may take a few seconds to be indexed.`
          };
        }

        if (data.cast) {
          const authorFid = data.cast.author?.fid;
          const authorUsername = data.cast.author?.username || 'unknown';

          // Check if the connected wallet owns this cast
          // Get author's verified addresses from Neynar
          let isOwnCast = false;
          let authorAddresses = [];

          if (authorFid && state.userAddress) {
            try {
              const verifyResponse = await fetch(`https://api.neynar.com/v2/farcaster/user/bulk?fids=${authorFid}`, {
                headers: {
                  'accept': 'application/json',
                  'api_key': CONFIG.NEYNAR_API_KEY
                }
              });
              const verifyData = await verifyResponse.json();

              if (verifyData.users && verifyData.users[0]) {
                // Get all verified addresses for this user
                authorAddresses = verifyData.users[0].verified_addresses?.eth_addresses || [];
                // Also check custody address
                if (verifyData.users[0].custody_address) {
                  authorAddresses.push(verifyData.users[0].custody_address);
                }

                // Check if connected wallet matches any of author's addresses
                const connectedLower = state.userAddress.toLowerCase();
                isOwnCast = authorAddresses.some(addr => addr.toLowerCase() === connectedLower);

                console.log('Author addresses:', authorAddresses);
                console.log('Connected wallet:', state.userAddress);
                console.log('Is own cast:', isOwnCast);
              }
            } catch (e) {
              console.error('Error checking cast ownership:', e);
              // If we can't verify, allow it but warn
            }
          }

          return {
            valid: true,
            cast: data.cast,
            hash: castHash, // Return the resolved full hash
            author: authorUsername,
            authorFid: authorFid,
            authorAddresses: authorAddresses,
            isOwnCast: isOwnCast,
            text: data.cast.text?.substring(0, 100) || ''
          };
        }

        return { valid: false, error: 'Invalid cast data returned from API' };
      } catch (e) {
        console.error('Cast validation error:', e);
        return { valid: false, error: `Network error validating cast: ${e.message}\n\nPlease try again.` };
      }
    }

    // ===== BLOCKCHAIN FUNCTIONS =====
    async function connectWallet() {
      try {
        // Helper for timeout (no longer used for wallet connection - we wait indefinitely)
        const withTimeout = (promise, ms, errorMsg) => Promise.race([
          promise,
          new Promise((_, reject) => setTimeout(() => reject(new Error(errorMsg || 'Request timed out')), ms))
        ]);

        // Try to get Farcaster Mini App SDK provider first (for Warpcast)
        let ethProvider = null;
        let providerSource = 'none';

        // Check for Farcaster SDK first
        if (window.FarcasterSDK) {
          try {
            const sdk = window.FarcasterSDK;
            console.log('Farcaster SDK found');
            console.log('SDK wallet object:', sdk.wallet);
            console.log('SDK wallet methods:', sdk.wallet ? Object.keys(sdk.wallet) : 'no wallet');
            console.log('SDK context:', sdk.context);

            // Try to get user FID from SDK context (multiple approaches)
            const farcasterUser = window.FarcasterUser || window.FarcasterContext?.user || sdk.context?.user;
            if (farcasterUser?.fid) {
              state.userFid = farcasterUser.fid;
              state.userProfile = {
                fid: farcasterUser.fid,
                username: farcasterUser.username,
                displayName: farcasterUser.displayName || farcasterUser.display_name,
                pfpUrl: farcasterUser.pfpUrl || farcasterUser.pfp_url
              };
              console.log('Got user FID from Farcaster context:', state.userFid, state.userProfile);
            } else {
              console.log('No Farcaster user found in context. FarcasterUser:', window.FarcasterUser, 'FarcasterContext:', window.FarcasterContext);
            }

            // Get the provider - try different methods
            if (typeof sdk.wallet?.getEthereumProvider === 'function') {
              console.log('Calling getEthereumProvider()...');
              ethProvider = sdk.wallet.getEthereumProvider();
              // Check if it returns a promise
              if (ethProvider && typeof ethProvider.then === 'function') {
                ethProvider = await ethProvider;
              }
              providerSource = 'farcaster';
              console.log('Got Farcaster provider:', ethProvider);
              console.log('Provider methods:', ethProvider ? Object.keys(ethProvider) : 'null');
            } else {
              console.log('getEthereumProvider not found on sdk.wallet');
            }
          } catch (sdkError) {
            console.log('Farcaster SDK wallet error:', sdkError.message);
          }
        }

        // Fallback to window.ethereum (MetaMask, Coinbase Smart Wallet, etc)
        if (!ethProvider && window.ethereum) {
          ethProvider = window.ethereum;

          // Detect wallet type for better logging/analytics
          if (window.ethereum.isCoinbaseWallet) {
            providerSource = 'coinbase_smart_wallet';
            console.log('Using Coinbase Smart Wallet');
          } else if (window.ethereum.isMetaMask) {
            providerSource = 'metamask';
            console.log('Using MetaMask');
          } else {
            providerSource = 'injected';
            console.log('Using injected wallet (window.ethereum)');
          }
        }

        if (!ethProvider) {
          // Provide context-aware error message
          const isInBaseApp = isBaseAppContext();
          if (isInBaseApp) {
            showToast('Wallet not detected. Please ensure your Coinbase Smart Wallet is set up.', 'error');
          } else if (window.FarcasterSDK) {
            showToast('Farcaster SDK loaded but wallet not available. Try refreshing.', 'error');
          } else {
            showToast('No wallet found! Open in Warpcast or install a wallet extension.', 'error');
          }
          return false;
        }

        console.log('Using provider from:', providerSource);

        // Show "waiting for wallet" state - NO timeout, wait for user to unlock
        state.isCheckingWhitelist = true;
        // Context-aware status message
        if (providerSource === 'coinbase_smart_wallet') {
          state.walletStatus = 'Connecting Coinbase Smart Wallet...';
        } else if (providerSource === 'farcaster') {
          state.walletStatus = 'Connecting via Warpcast...';
        } else {
          state.walletStatus = 'Unlock your wallet to continue...';
        }
        render();

        // Connect to wallet - NO TIMEOUT, wait indefinitely for unlock
        let accounts;
        try {
          console.log('Requesting wallet accounts (waiting for unlock if needed)...');

          // Use a Promise wrapper to allow UI updates during the wait
          accounts = await new Promise((resolve, reject) => {
            // Update UI to show we're waiting - context-aware message
            setTimeout(() => {
              if (providerSource === 'coinbase_smart_wallet') {
                state.walletStatus = 'Confirming in Coinbase Wallet...';
              } else if (providerSource === 'farcaster') {
                state.walletStatus = 'Confirming in Warpcast...';
              } else {
                state.walletStatus = 'Waiting for wallet... Check your extension!';
              }
              render();
            }, 2000);

            ethProvider.request({ method: 'eth_requestAccounts' })
              .then(resolve)
              .catch(reject);
          });
        } catch (e) {
          state.isCheckingWhitelist = false;
          state.walletStatus = null;
          render();
          // User rejected or other error
          if (e.code === 4001) {
            showToast('Wallet connection rejected. Please try again.', 'error');
          } else if (e.code === -32002) {
            // Already pending - wallet popup might be hidden
            showToast('Wallet request already pending! Check your wallet extension.', 'warning');
            return false;
          } else {
            showToast(e.message || 'Failed to connect wallet. Please try again.', 'error');
          }
          return false;
        }

        // Store the provider for later use
        window.activeEthProvider = ethProvider;

        if (!accounts || accounts.length === 0) {
          state.isCheckingWhitelist = false;
          state.walletStatus = null;
          render();
          showToast('No accounts found. Please unlock your wallet and try again.', 'error');
          return false;
        }

        const address = accounts[0];
        state.userAddress = address;

        // Check network (use the active provider)
        const chainId = await ethProvider.request({ method: 'eth_chainId' });
        if (chainId !== '0x2105') { // Base mainnet
          state.walletStatus = 'Switching to Base...';
          render();
          try {
            await ethProvider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: '0x2105' }]
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              await ethProvider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: '0x2105',
                  chainName: 'Base',
                  nativeCurrency: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
                  rpcUrls: ['https://base-mainnet.g.alchemy.com/v2/QooWtq9nKQlkeqKF_-rvC'],
                  blockExplorerUrls: ['https://basescan.org']
                }]
              });
            } else {
              throw switchError;
            }
          }
        }

        // App is open to everyone - no whitelist/token gate!
        state.isWhitelisted = true;
        state.hasTokens = true;
        state.isLoggedIn = true;
        state.isCheckingWhitelist = false;
        state.walletStatus = null;

        // Immediately show logged-in state - run everything else in background
        render();
        console.log('User logged in, loading data in background...');

        // === BACKGROUND TASKS (non-blocking) ===
        // These run in parallel without blocking the UI

        // 1. Fetch token balance (for display only)
        (async () => {
          try {
            const neynartodeContract = new ethers.Contract(
              CONFIG.CONTRACTS.neynartodes,
              ['function balanceOf(address) external view returns (uint256)'],
              rpcProvider
            );
            const balance = await withTimeout(neynartodeContract.balanceOf(address), 10000);
            state.userBalance = ethers.utils.formatEther(balance);
            render(); // Update UI with balance
          } catch (e) {
            console.error('Balance check failed:', e);
            state.userBalance = '0';
          }
        })();

        // 2. Fetch user data from Neynar (either by FID if we have it, or by address)
        // This is needed even if we got FID from Farcaster context because we need verifiedAddresses for holder check
        const needsNeynarLookup = !state.userFid || !state.userProfile?.verifiedAddresses?.ethAddresses?.length;
        if (needsNeynarLookup) {
          (async () => {
            try {
              let user = null;

              // If we have FID from Farcaster context, use FID-based lookup
              if (state.userFid) {
                console.log('Have FID from Farcaster context, fetching verified addresses from Neynar for FID:', state.userFid);
                const response = await fetch(`https://api.neynar.com/v2/farcaster/user/bulk?fids=${state.userFid}`, {
                  headers: {
                    'accept': 'application/json',
                    'api_key': CONFIG.NEYNAR_API_KEY
                  }
                });
                if (response.ok) {
                  const data = await response.json();
                  if (data && data.users && data.users.length > 0) {
                    user = data.users[0];
                  }
                }
              } else {
                // No FID, lookup by wallet address
                console.log('No FID from Farcaster context, trying Neynar API lookup for address:', address);
                const response = await fetch(`https://api.neynar.com/v2/farcaster/user/by-verification?address=${address}`, {
                  headers: {
                    'accept': 'application/json',
                    'api_key': CONFIG.NEYNAR_API_KEY
                  }
                });
                if (response.ok) {
                  const data = await response.json();
                  if (data && data.users && data.users.length > 0) {
                    user = data.users[0];
                  }
                }
              }

              if (user) {
                state.userFid = user.fid;
                state.userProfile = {
                  fid: user.fid,
                  username: user.username,
                  displayName: user.display_name,
                  pfpUrl: user.pfp_url,
                  verifiedAddresses: {
                    ethAddresses: user.verified_addresses?.eth_addresses || []
                  }
                };
                console.log('Got user from Neynar API:', state.userFid, 'verified addresses:', user.verified_addresses?.eth_addresses);
                render();
              }
            } catch (e) {
              console.error('Neynar API error:', e);
            }
          })();
        }

        // 3. Load active contests (this is what users see on the main tab)
        // Delay to let wallet connection RPC calls complete (avoids rate limiting)
        setTimeout(() => {
          loadActiveContests().catch(e => console.error('Active contests load failed:', e));
        }, 1500);

        // NOTE: Leaderboard and votes are lazy-loaded when user visits that tab
        // This reduces initial API calls and prevents unnecessary re-renders

        // NOTE: Signer check is now lazy - handled when user tries to enter a raffle
        // This prevents blocking the app entry and unnecessary signer creation prompts

        // Track wallet connection
        if (window.analytics?.track) {
          window.analytics.track('Wallet Connected', {
            address,
            fid: state.userFid,
            balance: state.userBalance,
            provider: providerSource
          });
        }

        render();
        return true;
      } catch (error) {
        console.error('Wallet connection error:', error);
        state.isCheckingWhitelist = false;
        state.walletStatus = null;
        render();
        showToast('Failed to connect wallet: ' + error.message, 'error');
        return false;
      }
    }

    // Dedicated function to load burned tokens - checks all burn sources
    // Uses shared rpcProvider for efficiency
    async function loadBurnedTokens() {
      // All common burn addresses on Base/Ethereum
      const BURN_ADDRESSES = [
        '0x000000000000000000000000000000000000dEaD', // Most common burn address
        '0x0000000000000000000000000000000000000000', // Zero address
      ];

      try {
        // Token contract for checking burn address balances (uses shared provider)
        const neynartodeToken = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          ['function balanceOf(address) view returns (uint256)'],
          rpcProvider
        );

        // VotingManager contract for checking burned via burn() function (uses shared provider)
        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          ['function totalTokensBurned() view returns (uint256)'],
          rpcProvider
        );

        // Check all sources in parallel (batched RPC calls)
        const [burnAddressBalances, vmBurned] = await Promise.all([
          // Check burn addresses
          Promise.all(BURN_ADDRESSES.map(addr =>
            neynartodeToken.balanceOf(addr).catch(() => ethers.BigNumber.from(0))
          )),
          // Check VotingManager's tracked burns
          votingManager.totalTokensBurned().catch(() => ethers.BigNumber.from(0))
        ]);

        // Sum all burned tokens from burn addresses
        let totalBurned = ethers.BigNumber.from(0);
        for (const balance of burnAddressBalances) {
          totalBurned = totalBurned.add(balance);
        }

        // Add VotingManager tracked burns (these are actual burn() calls that reduce supply)
        totalBurned = totalBurned.add(vmBurned);

        state.totalTokensBurned = ethers.utils.formatEther(totalBurned);
        console.log('Total tokens burned (all sources):', state.totalTokensBurned, '| VM burned:', ethers.utils.formatEther(vmBurned));
      } catch (e) {
        console.error('Error fetching burned tokens:', e);
        state.totalTokensBurned = '0';
      }
    }

    async function loadPrizePools() {
      // FIRST: Load burned tokens - this runs independently and should always work
      await loadBurnedTokens();

      try {
        console.log('Loading prize pools from PrizeNFT:', CONFIG.CONTRACTS.prizeNFT);

        // Load current season and prize pools from PrizeNFT contract (V2 - no devPool)
        // Uses shared rpcProvider for efficiency
        const prizeNFTABI = [
          'function nextSeasonId() external view returns (uint256)',
          'function seasons(uint256) external view returns (string theme, uint256 startTime, uint256 endTime, uint256 hostPool, uint256 voterPool, bool distributed)'
        ];

        const prizeNFT = new ethers.Contract(
          CONFIG.CONTRACTS.prizeNFT,
          prizeNFTABI,
          rpcProvider
        );

        // Get current season ID (latest season)
        console.log('Calling nextSeasonId()...');
        const nextSeasonId = await prizeNFT.nextSeasonId();
        console.log('nextSeasonId result:', nextSeasonId.toString());
        state.currentSeason = nextSeasonId.toNumber() - 1;
        console.log('currentSeason:', state.currentSeason);

        if (state.currentSeason > 0) {
          // Get season data
          console.log('Calling seasons(' + state.currentSeason + ')...');
          const season = await prizeNFT.seasons(state.currentSeason);
          console.log('Season data:', {
            theme: season.theme,
            startTime: season.startTime.toString(),
            endTime: season.endTime.toString(),
            hostPool: season.hostPool.toString(),
            voterPool: season.voterPool.toString(),
            distributed: season.distributed
          });

          state.hostPoolETH = parseFloat(ethers.utils.formatEther(season.hostPool));
          state.voterPoolETH = parseFloat(ethers.utils.formatEther(season.voterPool));
          state.prizePoolETH = state.hostPoolETH + state.voterPoolETH; // Total
          state.seasonEndTime = season.endTime.toNumber(); // Store season end timestamp
          console.log('seasonEndTime set to:', state.seasonEndTime);
        }

        // Clanker fees now go direct to Treasury - no pending fees to track
        state.pendingClankerFees = '0';

        // Fetch all-time prizes from API (includes contest prizes + distributed season pools)
        try {
          const baseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
          const prizesResponse = await fetch(`${baseUrl}/api/all-time-prizes`);
          if (prizesResponse.ok) {
            const prizesData = await prizesResponse.json();
            state.totalPrizesGiven = prizesData.totalETH || 0;
            console.log('All-time prizes loaded:', prizesData);
          } else {
            // Fallback to current season pools
            state.totalPrizesGiven = state.hostPoolETH + state.voterPoolETH;
          }
        } catch (e) {
          console.log('Could not fetch all-time prizes, using season pools:', e.message);
          state.totalPrizesGiven = state.hostPoolETH + state.voterPoolETH;
        }

        console.log('Prize pools loaded successfully:', {
          season: state.currentSeason,
          hostPool: state.hostPoolETH,
          voterPool: state.voterPoolETH,
          seasonEndTime: state.seasonEndTime,
          pendingFees: state.pendingClankerFees,
          tokensBurned: state.totalTokensBurned,
          prizesGiven: state.totalPrizesGiven
        });
      } catch (error) {
        console.error('Failed to load prize pools:', error);
        console.error('Error details:', error.message, error.code);
      }
    }

    // Global flag to track if heavy API calls are in progress (prevents concurrent rate limit hits)
    let apiCallInProgress = false;

    async function loadLeaderboard() {
      // Mark API calls as in progress to prevent concurrent heavy calls
      apiCallInProgress = true;

      // Load prize pools from contracts
      await loadPrizePools();

      // RATE LIMIT STAGGER: Wait 500ms after prize pool RPC calls before hitting leaderboard API
      await new Promise(r => setTimeout(r, 500));

      try {
        // Fetch leaderboard data from API
        const baseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        const response = await fetch(`${baseUrl}/api/leaderboard?limit=10`);

        if (!response.ok) {
          console.error('Failed to fetch leaderboard:', response.status);
          state.leaderboardData = [];
          return;
        }

        const data = await response.json();
        const hosts = data.hosts || [];

        // Transform API data to match expected leaderboard format
        state.leaderboardData = hosts.map(host => {
          // Award Season 0 Beta badges to all participants
          awardSeasonBetaBadge(host.fid, host.username);

          // Build badges array
          const badges = [];
          if (hasSeasonBetaBadge(host.fid)) {
            badges.push('season0_beta');
          }

          // Get a pfp emoji based on username hash or use first letter
          const pfpEmoji = getPfpEmoji(host.username);

          return {
            rank: host.rank,
            fid: host.fid,
            username: host.username,
            displayName: host.displayName,
            pfp: pfpEmoji,
            pfpUrl: host.pfpUrl,
            badges,
            contests: host.contests,
            completedContests: host.completedContests,
            // Score breakdown
            likes: host.likes,
            recasts: host.recasts,
            replies: host.replies,
            volume: host.volume,
            upvotes: host.upvotes,
            downvotes: host.downvotes,
            socialScore: host.socialScore,
            tokenHoldings: host.tokenHoldings || 0,
            tokenScore: host.tokenScore || 0,
            hostBonus: host.hostBonus || 0,
            contestScore: host.contestScore,
            voteScore: host.voteScore || 0,
            totalScore: host.totalScore,
            neynarScore: host.neynarScore,
          };
        });

        // RATE LIMIT STAGGER: Wait 500ms before fetching on-chain vote scores
        await new Promise(r => setTimeout(r, 500));

        // Fetch on-chain vote scores and merge with leaderboard data
        await fetchOnChainVoteScores();

        // Mark leaderboard as loaded
        state.leaderboardLoaded = true;

      } catch (error) {
        console.error('Error loading leaderboard:', error);
        state.leaderboardData = [];
      }

      // Mark API calls as complete
      apiCallInProgress = false;

      // Re-render to show leaderboard
      render();
    }

    // Load active contests - called first for faster perceived loading
    async function loadActiveContests(forceRefresh = false) {
      // Check for cached contests first (for faster initial load)
      const cachedContests = sessionStorage.getItem('neynartodes_active_contests');
      const cachedTime = sessionStorage.getItem('neynartodes_contests_time');
      const cacheMaxAge = 15000; // 15 seconds (matches API cache)

      if (!forceRefresh && cachedContests && cachedTime && (Date.now() - parseInt(cachedTime)) < cacheMaxAge) {
        try {
          state.upcomingContests = JSON.parse(cachedContests);
          state.contestsLoading = false;
          console.log('Loaded contests from cache');
          render();
        } catch (e) {
          console.log('Cache parse error, fetching fresh');
        }
      }

      state.contestsLoading = !cachedContests;
      try {
        const baseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        // Add cache-buster timestamp when force refreshing to bypass CDN cache
        const cacheBuster = forceRefresh ? `&_t=${Date.now()}` : '';
        const historyResponse = await fetch(`${baseUrl}/api/contest-history?limit=50&includeUsers=true&status=active${cacheBuster}`);
        if (historyResponse.ok) {
          const historyData = await historyResponse.json();
          // API already filters to active/pending contests when status=active
          state.upcomingContests = (historyData.contests || [])
            .map(c => ({
              contestId: c.contestId,
              host: c.host,
              hostUser: c.hostUser,
              prize: c.isNft
                ? `${c.nftName || 'NFT'}`
                : `${c.prizeAmount.toLocaleString(undefined, { maximumFractionDigits: 4 })} $${c.prizeTokenSymbol}`,
              prizeToken: c.prizeTokenSymbol,
              prizeAmount: c.prizeAmount,
              startTime: new Date(c.startTime * 1000),
              endTime: new Date(c.endTime * 1000),
              volumeRequirement: c.volumeRequirement,
              tokenRequirementSymbol: c.tokenRequirementSymbol,
              status: c.status,
              statusText: c.statusText,
              participantCount: c.participantCount,
              castId: c.castId,
              // Social requirements from API
              requireRecast: c.requireRecast || false,
              requireLike: c.requireLike || false,
              requireReply: c.requireReply || false,
              // NFT fields
              isNft: c.isNft || false,
              nftAddress: c.nftAddress || '',
              nftTokenId: c.nftTokenId || '',
              nftImage: c.nftImage || '',
              nftName: c.nftName || '',
              nftCollection: c.nftCollection || '',
              nftType: c.nftType || '',
              winnerCount: c.winnerCount || 1,
            }));
          console.log(`Loaded ${state.upcomingContests.length} active/pending contests`);
          // Debug NFT contests
          state.upcomingContests.filter(c => c.isNft).forEach(c => {
            console.log('NFT Contest:', c.contestId, 'nftImage:', c.nftImage, 'nftName:', c.nftName);
          });
          // Debug multi-winner contests
          state.upcomingContests.filter(c => c.winnerCount > 1).forEach(c => {
            console.log('Multi-winner Contest:', c.contestId, 'winnerCount:', c.winnerCount);
          });
          // Cache contests for faster subsequent loads
          try {
            sessionStorage.setItem('neynartodes_active_contests', JSON.stringify(state.upcomingContests));
            sessionStorage.setItem('neynartodes_contests_time', Date.now().toString());
          } catch (e) {
            console.log('Could not cache contests:', e.message);
          }
          // Load user's contest entries and shares (delayed 1s to avoid RPC rate limiting)
          setTimeout(() => {
            loadContestEntries();
            loadContestShares();
          }, 1000);
          // Load participant PFPs for floating avatars (delayed 2s to avoid rate limiting)
          setTimeout(() => loadContestParticipants(), 2000);
        }
        state.contestsLoading = false;
      } catch (e) {
        console.error('Error fetching active contests:', e);
        state.upcomingContests = [];
        state.contestsLoading = false;
      }

      // Re-render to show active contests
      render();
    }

    // Force refresh contests (bypasses all caches)
    async function refreshContests() {
      showToast('Refreshing contests...', 'info', 2000);
      // Clear sessionStorage cache
      sessionStorage.removeItem('neynartodes_active_contests');
      sessionStorage.removeItem('neynartodes_contests_time');
      // Force fresh fetch with cache-buster
      await loadActiveContests(true);
      showToast('Contests refreshed!', 'success', 2000);
    }

    // Fetch participant PFPs for all active contests (for floating avatars)
    async function loadContestParticipants() {
      // Note: c.endTime is already a Date object from loadActiveContests()
      const activeContests = state.upcomingContests.filter(c => new Date(c.endTime) > new Date());
      if (activeContests.length === 0) return;

      // Fetch participants for each contest in parallel
      const fetchPromises = activeContests.map(async (contest) => {
        try {
          const response = await fetch(`/api/contest-participants?contestId=${contest.contestId}`);
          if (!response.ok) return;
          const data = await response.json();
          if (data.participants) {
            state.contestParticipants[contest.contestId] = {
              participants: data.participants,
              count: data.count || data.participants.length,
              hasMore: data.hasMore || false
            };
          }
        } catch (e) {
          console.log(`Could not fetch participants for contest ${contest.contestId}:`, e.message);
        }
      });

      await Promise.all(fetchPromises);
      // Re-render to show PFPs
      if (Object.keys(state.contestParticipants).length > 0) {
        render();
      }
    }

    // Fetch vote scores from VotingManager contract and update leaderboard
    async function fetchOnChainVoteScores() {
      if (state.leaderboardData.length === 0) return;

      try {
        // Uses shared rpcProvider for efficiency
        const votingManagerABI = [
          'function getHostVoteStats(uint256 hostFid) external view returns (uint256 upvotes, uint256 downvotes, int256 netScore)'
        ];
        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          rpcProvider
        );

        // Fetch vote stats for each host in parallel
        const votePromises = state.leaderboardData.map(async (host) => {
          try {
            const stats = await votingManager.getHostVoteStats(host.fid);
            return {
              fid: host.fid,
              upvotes: stats.upvotes.toNumber(),
              downvotes: stats.downvotes.toNumber(),
              netScore: stats.netScore.toNumber()
            };
          } catch (e) {
            console.warn(`Failed to get vote stats for FID ${host.fid}:`, e.message);
            return { fid: host.fid, upvotes: 0, downvotes: 0, netScore: 0 };
          }
        });

        const voteStats = await Promise.all(votePromises);

        // Update leaderboard with on-chain vote scores (200 points per net vote)
        state.leaderboardData = state.leaderboardData.map(host => {
          const stats = voteStats.find(s => s.fid === host.fid);
          if (stats) {
            const onChainVoteScore = stats.netScore * 200; // 200 points per net vote
            // Replace API vote score with on-chain score
            const adjustedTotal = host.totalScore - (host.voteScore || 0) + onChainVoteScore;
            return {
              ...host,
              upvotes: stats.upvotes,
              downvotes: stats.downvotes,
              voteScore: onChainVoteScore,
              totalScore: adjustedTotal
            };
          }
          return host;
        });

        // Re-sort and re-rank after updating scores
        state.leaderboardData = state.leaderboardData
          .sort((a, b) => b.totalScore - a.totalScore)
          .map((host, idx) => ({ ...host, rank: idx + 1 }));

        console.log('Updated leaderboard with on-chain vote scores');
        render();

      } catch (error) {
        console.error('Error fetching on-chain vote scores:', error);
      }
    }

    // Get a consistent emoji for a user based on their username
    function getPfpEmoji(username) {
      const emojis = ['ðŸ¦Ž', 'ðŸ¸', 'ðŸŠ', 'ðŸ¦–', 'ðŸ¢', 'ðŸ¦•', 'ðŸ', 'ðŸ²', 'ðŸŒŠ', 'ðŸª¸'];
      if (!username) return 'ðŸ¦Ž';
      const hash = username.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      return emojis[hash % emojis.length];
    }

    async function loadHistory() {
      // RATE LIMIT: Wait if another heavy API call is in progress
      if (apiCallInProgress) {
        console.log('Waiting for other API calls to complete before loading history...');
        // Wait up to 5 seconds for other calls to complete
        let waitTime = 0;
        while (apiCallInProgress && waitTime < 5000) {
          await new Promise(r => setTimeout(r, 200));
          waitTime += 200;
        }
      }

      state.historyLoading = true;
      state.historyError = null;
      apiCallInProgress = true;
      render();

      try {
        const baseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        const response = await fetch(`${baseUrl}/api/contest-history?limit=50&includeUsers=true`);

        if (!response.ok) {
          throw new Error(`Failed to fetch history: ${response.status}`);
        }

        const data = await response.json();
        state.historyData = data.contests || [];
        state.historyTotal = data.total || 0;
        state.historyTotalToken = data.totalToken || 0;
        state.historyTotalV2 = data.totalV2 || 0;
        state.historyLoading = false;
        apiCallInProgress = false;
        render();
      } catch (error) {
        console.error('Error loading history:', error);
        state.historyError = error.message;
        state.historyLoading = false;
        apiCallInProgress = false;
        render();
      }
    }

    // ===== ANONYMOUS SUGGESTIONS =====
    // Uses localStorage for storage - suggestions are completely anonymous (no user data stored)
    const SUGGESTIONS_KEY = 'neynartodes_suggestions';

    function loadSuggestions() {
      state.suggestionsLoading = true;
      render();

      try {
        const stored = localStorage.getItem(SUGGESTIONS_KEY);
        state.suggestions = stored ? JSON.parse(stored) : [];
        // Sort by newest first
        state.suggestions.sort((a, b) => b.timestamp - a.timestamp);
      } catch (error) {
        console.error('Error loading suggestions:', error);
        state.suggestions = [];
      }

      state.suggestionsLoading = false;
      render();
    }

    function submitAnonymousSuggestion() {
      const text = state.suggestionText.trim();

      if (text.length < 10) {
        showToast('Suggestion must be at least 10 characters', 'error');
        return;
      }

      try {
        // Load existing suggestions
        const stored = localStorage.getItem(SUGGESTIONS_KEY);
        const suggestions = stored ? JSON.parse(stored) : [];

        // Add new suggestion (completely anonymous - no user data)
        suggestions.push({
          id: Date.now().toString(36) + Math.random().toString(36).substr(2),
          text: text,
          timestamp: Date.now()
        });

        // Save back to localStorage
        localStorage.setItem(SUGGESTIONS_KEY, JSON.stringify(suggestions));

        // Clear the input and show success
        state.suggestionText = '';
        showToast('Suggestion submitted anonymously! Thank you for your feedback.', 'success');
        render();

        // Track analytics (without any identifying info)
        if (window.analytics?.track) {
          window.analytics.track('Suggestion Submitted', { anonymous: true });
        }
      } catch (error) {
        console.error('Error submitting suggestion:', error);
        showToast('Failed to submit suggestion. Please try again.', 'error');
      }
    }

    // History refresh is now manual only - triggered when entering the page or clicking Refresh button
    // Removed auto-refresh interval to reduce unnecessary API calls
    function stopHistoryAutoRefresh() {
      // No-op - kept for compatibility with existing view switching code
    }

    // Countdown timer interval for leaderboard
    let countdownInterval = null;

    function startCountdownTimer() {
      stopCountdownTimer();
      // Update countdown every minute (targeted update, not full render)
      countdownInterval = setInterval(() => {
        if (state.currentView === 'leaderboard') {
          updateCountdownDisplay();
        }
      }, 60000); // Update every minute
    }

    // Targeted countdown update - avoids rebuilding entire leaderboard DOM
    function updateCountdownDisplay() {
      const countdownEl = document.getElementById('countdown-text');
      if (!countdownEl) return;

      const countdown = getSeasonCountdown();
      if (!countdown) {
        countdownEl.textContent = 'Loading...';
      } else if (countdown.ended) {
        countdownEl.textContent = 'Season Ended!';
      } else {
        countdownEl.textContent = countdown.text;
      }
    }

    function stopCountdownTimer() {
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }

    // Format timestamp to readable date
    function formatDate(timestamp) {
      const date = new Date(timestamp * 1000);
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    // Get season countdown string
    function getSeasonCountdown() {
      if (!state.seasonEndTime) return null;

      const now = Math.floor(Date.now() / 1000);
      const remaining = state.seasonEndTime - now;

      if (remaining <= 0) return { text: 'Season Ended!', days: 0, hours: 0, minutes: 0, ended: true };

      const days = Math.floor(remaining / 86400);
      const hours = Math.floor((remaining % 86400) / 3600);
      const minutes = Math.floor((remaining % 3600) / 60);

      let text = '';
      if (days > 0) text += `${days}d `;
      if (hours > 0 || days > 0) text += `${hours}h `;
      text += `${minutes}m`;

      return { text: text.trim(), days, hours, minutes, ended: false };
    }

    // Format duration
    function formatDuration(hours, minutes) {
      if (hours === 0) return `${minutes}m`;
      if (minutes === 0) return `${hours}h`;
      return `${hours}h ${minutes}m`;
    }

    // Fetch user's recent casts from Neynar
    async function fetchRecentCasts() {
      if (!state.userFid) {
        showToast('Unable to fetch casts - no Farcaster ID found', 'error');
        console.log('fetchRecentCasts: No userFid available, userFid =', state.userFid);
        return;
      }

      state.loadingRecentCasts = true;
      render();

      try {
        console.log('Fetching casts for FID:', state.userFid);
        const response = await fetch(`https://api.neynar.com/v2/farcaster/feed/user/casts?fid=${state.userFid}&limit=3&include_replies=false`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        console.log('Neynar API response status:', response.status);

        if (response.ok) {
          const data = await response.json();
          console.log('Casts data:', data);
          state.recentCasts = (data.casts || []).map(cast => ({
            hash: cast.hash,
            text: cast.text?.substring(0, 80) + (cast.text?.length > 80 ? '...' : '') || '',
            timestamp: new Date(cast.timestamp).toLocaleDateString(),
            url: `https://farcaster.id/cast/${cast.hash}`
          }));
        } else {
          const errorText = await response.text();
          console.error('Neynar API error:', response.status, errorText);
          showToast('Failed to fetch casts', 'error');
          state.recentCasts = [];
        }
      } catch (error) {
        console.error('Error fetching recent casts:', error);
        showToast('Error fetching casts', 'error');
        state.recentCasts = [];
      }

      state.loadingRecentCasts = false;
      state.showRecentCasts = true;
      render();
    }

    // Copy cast hash to input and close dropdown
    function selectRecentCast(url) {
      state.castHash = url;
      state.showRecentCasts = false;
      render();
    }

    // Copy text to clipboard
    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        showToast('Copied to clipboard!', 'success', 2000);
      } catch (err) {
        showToast('Failed to copy', 'error');
      }
    }

    // Get status color class
    function getStatusColor(status) {
      switch (status) {
        case 0: return 'bg-blue-100 text-blue-700'; // Active
        case 1: return 'bg-yellow-100 text-yellow-700'; // PendingVRF
        case 2: return 'bg-green-100 text-green-700'; // Completed
        case 3: return 'bg-red-100 text-red-700'; // Cancelled
        default: return 'bg-gray-100 text-gray-700';
      }
    }

    // Get status emoji
    function getStatusEmoji(status) {
      switch (status) {
        case 0: return 'ðŸ”µ'; // Active
        case 1: return 'ðŸŽ²'; // PendingVRF
        case 2: return 'âœ…'; // Completed
        case 3: return 'âŒ'; // Cancelled
        default: return 'â“';
      }
    }

    async function voteForHost(hostFid, isUpvote) {
      // Check if dev wallet (unlimited voting)
      const isDev = isDevWallet(state.userAddress);

      // Block self-voting (except dev for testing)
      if (!isDev && state.userFid && state.userFid === hostFid) {
        showToast("You can't vote for yourself! Nice try though!", 'error');
        return;
      }

      if (!isDev && state.votesRemaining <= 0) {
        showToast('You have used all 10 votes for today! Come back tomorrow.', 'warning');
        return;
      }

      try {
        // Create provider and signer using stored provider
        const ethProvider = window.activeEthProvider || window.ethereum;
        if (!ethProvider) {
          showToast('Wallet not connected! Please reconnect.', 'error');
          return;
        }
        const walletProvider = new ethers.providers.Web3Provider(ethProvider);
        const signer = walletProvider.getSigner();

        // Use shared rpcProvider for read operations (Farcaster wallet doesn't support eth_call)

        // Contract ABIs - VotingManager V2 with upvote/downvote
        const votingManagerABI = [
          'function voteForHost(uint256 hostFid, bool isUpvote) external',
          'function getRemainingVotes(address user) external view returns (uint256)',
          'function canVote(address user) external view returns (bool)',
          'function getHostVoteStats(uint256 hostFid) external view returns (uint256 upvotes, uint256 downvotes, int256 netScore)',
          'function TOKENS_PER_VOTE() external view returns (uint256)'
        ];

        const tokenABI = [
          'function approve(address spender, uint256 amount) external returns (bool)',
          'function allowance(address owner, address spender) external view returns (uint256)',
          'function balanceOf(address account) external view returns (uint256)'
        ];

        // Read-only contract instances for checking balances/allowances (uses shared rpcProvider)
        const votingManagerRead = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          rpcProvider
        );

        const neynartodeTokenRead = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          tokenABI,
          rpcProvider
        );

        // Write contract instances for transactions
        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          signer
        );

        const neynartodeToken = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          tokenABI,
          signer
        );

        // Check if can vote (skip for dev wallet) - use read-only provider
        if (!isDev) {
          const canVoteResult = await votingManagerRead.canVote(state.userAddress);
          if (!canVoteResult) {
            showToast('Cannot vote! You may have used all votes today or have insufficient tokens.', 'error');
            return;
          }
        }

        // Get tokens per vote (1000 NEYNARTODES)
        const tokensPerVote = ethers.utils.parseEther('1000');

        // Check balance - use read-only provider
        const balance = await neynartodeTokenRead.balanceOf(state.userAddress);
        if (balance.lt(tokensPerVote)) {
          showToast(`Insufficient balance! You need 1,000 NEYNARTODES to vote. Your balance: ${ethers.utils.formatEther(balance)}`, 'error');
          return;
        }

        // Check and set approval if needed - use read-only provider for allowance check
        const currentAllowance = await neynartodeTokenRead.allowance(state.userAddress, CONFIG.CONTRACTS.votingManager);
        if (currentAllowance.lt(tokensPerVote)) {
          showToast('Approving voting contract... Confirm in wallet.', 'info', 8000);

          // Encode approve call manually for smart wallet compatibility
          const approveInterface = new ethers.utils.Interface(tokenABI);
          const approveData = approveInterface.encodeFunctionData('approve', [
            CONFIG.CONTRACTS.votingManager,
            ethers.constants.MaxUint256
          ]);

          // Send via raw eth_sendTransaction for Farcaster smart wallet
          const approveTxHash = await ethProvider.request({
            method: 'eth_sendTransaction',
            params: [{
              from: state.userAddress,
              to: CONFIG.CONTRACTS.neynartodes,
              data: approveData,
              gas: '0x' + (500000).toString(16) // 500k gas for smart wallet approve
            }]
          });

          showToast('Approval submitted! Waiting for confirmation...', 'info', 10000);

          // Wait for approval confirmation
          let approveReceipt = null;
          for (let i = 0; i < 30; i++) {
            await new Promise(r => setTimeout(r, 2000));
            approveReceipt = await rpcProvider.getTransactionReceipt(approveTxHash);
            if (approveReceipt) break;
          }

          if (approveReceipt) {
            showToast('Approval confirmed! Now submitting vote...', 'success');
          } else {
            showToast('Approval may still be pending. Continuing with vote...', 'warning');
          }
        }

        // Cast vote on-chain
        showToast('Submitting vote... Burns 500 + 500 to treasury. Confirm in wallet!', 'info', 8000);

        // Encode the function call manually (Farcaster provider doesn't support eth_estimateGas)
        const voteInterface = new ethers.utils.Interface(votingManagerABI);
        const voteData = voteInterface.encodeFunctionData('voteForHost', [hostFid, isUpvote]);

        // Send transaction via raw eth_sendTransaction (works with Farcaster wallet)
        const txHash = await ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: state.userAddress,
            to: CONFIG.CONTRACTS.votingManager,
            data: voteData,
            gas: '0x' + (800000).toString(16) // 800k gas for smart wallet vote (transferFrom + burn + transfer)
          }]
        });

        console.log('Vote tx hash:', txHash);

        // Track vote event
        if (window.analytics?.track) {
          window.analytics.track('Vote Cast', {
            hostFid,
            isUpvote,
            voteType: isUpvote ? 'upvote' : 'downvote',
            txHash: txHash
          });
        }

        showToast('Vote submitted! Waiting for confirmation...', 'info', 15000);

        // Wait for receipt using read provider
        let receipt = null;
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          receipt = await rpcProvider.getTransactionReceipt(txHash);
          if (receipt) break;
        }

        if (!receipt) {
          showToast('Vote submitted but not yet confirmed. Check BaseScan.', 'warning');
        }

        // Update UI after successful vote (200 points per vote to align with scoring system)
        const votePoints = isUpvote ? 200 : -200;
        const oldRankings = state.leaderboardData.map(h => ({ fid: h.fid, rank: h.rank }));

        // Update leaderboard locally
        state.leaderboardData = state.leaderboardData.map(host => {
          if (host.fid === hostFid) {
            return {
              ...host,
              voteScore: host.voteScore + votePoints,
              totalScore: host.totalScore + votePoints
            };
          }
          return host;
        }).sort((a, b) => b.totalScore - a.totalScore).map((host, idx) => ({ ...host, rank: idx + 1 }));

        // Refresh burned tokens counter
        await loadBurnedTokens();

        const votedHost = state.leaderboardData.find(h => h.fid === hostFid);
        const oldRank = oldRankings.find(h => h.fid === hostFid)?.rank;
        const newRank = votedHost.rank;
        const movement = oldRank - newRank;

        let movementText = '';
        if (movement > 0) {
          movementText = `\nðŸ“ˆ @${votedHost.username} moved UP ${movement} position${movement > 1 ? 's' : ''}! (${oldRank} â†’ ${newRank})`;
        } else if (movement < 0) {
          movementText = `\nðŸ“‰ @${votedHost.username} moved DOWN ${Math.abs(movement)} position${Math.abs(movement) > 1 ? 's' : ''}! (${oldRank} â†’ ${newRank})`;
        } else {
          movementText = `\nâž¡ï¸ @${votedHost.username} stayed at rank #${newRank}`;
        }

        // Refresh remaining votes from contract for non-dev wallets
        if (!isDevWallet) {
          try {
            const remainingVotes = await votingManagerRead.getRemainingVotes(state.userAddress);
            state.votesRemaining = Number(remainingVotes);
            state.votesUsedToday = 10 - state.votesRemaining;
          } catch (e) {
            // Fallback to local decrement if contract call fails
            state.votesUsedToday++;
            state.votesRemaining--;
          }
        }

        const ethFromVote = 0.00001;
        state.prizePoolETH += (ethFromVote * 0.5);

        showToast(`${isUpvote ? 'Upvote' : 'Downvote'} confirmed! 500 burned, 500 to treasury. ${isDevWallet ? 'Dev mode' : `${state.votesRemaining}/10 votes left`}`, 'success', 6000);

        render();
      } catch (error) {
        console.error('Voting error:', error);

        if (error.code === 4001) {
          showToast('Transaction rejected by user', 'error');
        } else if (error.message && error.message.includes('Daily vote limit')) {
          showToast('Daily vote limit reached! Come back tomorrow.', 'error');
        } else if (error.message && error.message.includes('Already voted')) {
          showToast('Already voted for this host!', 'error');
        } else {
          showToast('Vote failed: ' + (error.reason || error.message || 'Unknown error'), 'error');
        }
      }
    }

    // ===== RENDER FUNCTIONS =====
    function render() {
      const app = document.getElementById('app');

      // Check for maintenance mode (admins bypass)
      // Check both state.userFid and FarcasterContext since FID may not be in state yet
      const userFid = state.userFid || window.FarcasterContext?.user?.fid;
      const isAdmin = CONFIG.ADMIN_FIDS && userFid && CONFIG.ADMIN_FIDS.includes(userFid);
      if (CONFIG.MAINTENANCE_MODE && !isAdmin) {
        app.innerHTML = renderMaintenancePage();
        attachEventListeners();
        return;
      }

      // In PUBLIC_TESTING_MODE, redirect non-admins from restricted views
      const restrictedViews = ['create', 'leaderboard', 'history'];
      if (CONFIG.PUBLIC_TESTING_MODE && !isAdmin && restrictedViews.includes(state.currentView)) {
        state.currentView = 'active';
      }

      let pageHtml = '';
      if (!state.isLoggedIn) {
        pageHtml = renderLoginPage();
      } else if (state.launchSuccess) {
        pageHtml = renderLaunchSuccess();
      } else if (state.currentView === 'leaderboard') {
        pageHtml = renderLeaderboard();
      } else if (state.currentView === 'active') {
        pageHtml = renderActiveContests();
      } else if (state.currentView === 'history') {
        pageHtml = renderHistory();
      } else if (state.currentView === 'suggestions') {
        pageHtml = renderSuggestions();
      } else {
        pageHtml = renderCreateContest();
      }

      // Add modals on top of page content
      app.innerHTML = pageHtml + renderParticipantsModal() + renderBuyBurnHoldEarnModal();

      attachEventListeners();
    }

    function renderMaintenancePage() {
      return `
        <div style="min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; text-align: center; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);">
          <img src="/neynartode-sticker.png" alt="Neynartodes" style="width: 150px; height: 150px; margin-bottom: 2rem; animation: pulse 2s ease-in-out infinite;" />

          <h1 style="font-size: 2rem; font-weight: bold; color: #fff; margin-bottom: 1rem;">
            Under Construction
          </h1>

          <div style="font-size: 1.25rem; color: #a0aec0; margin-bottom: 2rem; max-width: 400px;">
            Preparing for Main Launch
          </div>

          <div style="background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); border-radius: 12px; padding: 1.5rem; max-width: 400px; margin-bottom: 2rem;">
            <div style="font-size: 1rem; color: #e2e8f0; margin-bottom: 1rem;">
              BETA Season has ended!
            </div>
            <div style="font-size: 0.9rem; color: #a0aec0; line-height: 1.6;">
              Thank you to all our amazing hosts and participants. We're working on exciting updates for Main Launch.
            </div>
          </div>

          <div style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;">
            <a href="https://warpcast.com/neynartodes" target="_blank" style="background: #667eea; color: white; padding: 0.75rem 1.5rem; border-radius: 8px; text-decoration: none; font-weight: 500; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
              Follow for Updates
            </a>
          </div>

          <div style="margin-top: 3rem; font-size: 0.8rem; color: #718096;">
            Main Launch coming soon...
          </div>
        </div>

        <style>
          @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
          }
        </style>
      `;
    }

    function renderLaunchSuccess() {
      const { contestId, txHash, txUrl, winnerCount, isNft, nftName, prizeAmount, prizeTicker } = state.launchSuccess;

      // Build prize display
      const prizeDisplay = isNft
        ? `ðŸ–¼ï¸ ${nftName}`
        : `ðŸŽ ${prizeAmount || '?'} $${prizeTicker || 'ETH'}`;

      // Multi-winner display
      const winnersDisplay = (winnerCount && winnerCount > 1)
        ? `<div>
            <p class="text-xs text-[var(--text-muted)]">Winners</p>
            <p class="text-sm text-[var(--accent-light)]">ðŸ‘¥ ${winnerCount} Winners!</p>
          </div>`
        : '';

      return `
        <div class="min-h-screen flex items-center justify-center p-6" style="background: var(--bg-primary);">
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at center, rgba(16, 185, 129, 0.15) 0%, transparent 60%);"></div>

          <div class="glass-card p-8 max-w-sm w-full text-center relative z-10 animate-fade-in">
            <div class="w-16 h-16 mx-auto mb-4 rounded-full bg-[var(--success-glow)] flex items-center justify-center text-3xl">
              ðŸŽ‰
            </div>
            <h1 class="text-2xl font-bold text-[var(--success)] mb-2">
              Contest Launched!
            </h1>
            <p class="text-sm text-[var(--text-secondary)] mb-6">
              ðŸ“£ Announcement ready to post on your profile
            </p>

            <div class="bg-[var(--bg-secondary)] rounded-xl p-4 mb-6 text-left space-y-3">
              <div>
                <p class="text-xs text-[var(--text-muted)]">Contest ID</p>
                <p class="text-lg font-bold text-[var(--text-primary)]">#${contestId}</p>
              </div>
              <div>
                <p class="text-xs text-[var(--text-muted)]">Prize</p>
                <p class="text-sm text-[var(--text-primary)]">${prizeDisplay}</p>
              </div>
              ${winnersDisplay}
              <div>
                <p class="text-xs text-[var(--text-muted)]">Status</p>
                <p class="text-sm text-[var(--success)]">Prize locked in escrow</p>
              </div>
              <div>
                <p class="text-xs text-[var(--text-muted)]">Winner Selection</p>
                <p class="text-sm text-[var(--text-secondary)]">Chainlink VRF at contest end</p>
              </div>
              <div>
                <p class="text-xs text-[var(--text-muted)]">Transaction</p>
                <a href="${txUrl}" target="_blank" class="text-sm text-[var(--accent-light)] hover:underline break-all">
                  ${txHash.slice(0, 20)}...
                </a>
              </div>
            </div>

            <button
              onclick="state.launchSuccess = null; state.currentView = 'active'; render();"
              class="btn-primary w-full py-3 mb-3"
            >
              View Active Contests
            </button>

            <button
              onclick="state.launchSuccess = null; render();"
              class="btn-ghost w-full py-3"
            >
              Create Another Contest
            </button>

            <a
              href="${txUrl}"
              target="_blank"
              class="block mt-4 text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-sm transition-colors"
            >
              View on BaseScan
            </a>
          </div>
        </div>
      `;
    }

    function renderLoginPage() {
      return `
        <div class="min-h-screen flex flex-col items-center justify-center p-6" style="background: var(--bg-primary);">
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.12) 0%, transparent 50%);"></div>

          <div class="max-w-md w-full text-center relative z-10 animate-fade-in">
            <!-- Logo -->
            <div class="w-28 h-28 mx-auto mb-6">
              <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-contain" style="filter: drop-shadow(0 0 30px rgba(139, 92, 246, 0.6)) drop-shadow(0 0 60px rgba(139, 92, 246, 0.4));" />
            </div>

            <!-- Header -->
            <h1 class="text-4xl font-bold text-gradient mb-2">Neynartodes</h1>
            <p class="text-xl text-[var(--text-primary)] font-medium mb-8">Trustless Onchain Gamified Raffle</p>

            <!-- Subheading list -->
            <div class="space-y-2 mb-10">
              <p class="text-[var(--text-secondary)]">Bless Your Followers</p>
              <p class="text-[var(--text-secondary)]">Promote Your Project</p>
              <p class="text-[var(--text-secondary)]">Claim the Leaderboard</p>
              <p class="text-[var(--accent-light)]">Feed The Neynartodes</p>
            </div>

            ${state.isCheckingWhitelist ? `
              <div class="mb-4 p-4 glass-card">
                <div class="animate-spin text-2xl mb-2">ðŸŒ€</div>
                <p class="text-sm font-medium text-[var(--text-primary)]">${state.walletStatus || 'Checking access...'}</p>
                <p class="text-xs text-[var(--text-muted)] mt-1">Unlock wallet if prompted</p>
              </div>
            ` : ''}

            <!-- Enter Button -->
            <button
              id="connectButton"
              ${state.isCheckingWhitelist ? 'disabled' : ''}
              class="btn-primary w-full py-4 text-xl font-semibold disabled:opacity-50 mb-4"
            >
              ${state.isCheckingWhitelist ? 'Connecting...' : 'FEED'}
            </button>

            <!-- Powered by -->
            <div class="mt-10 pt-6 border-t border-[var(--border-subtle)]">
              <p class="text-xs text-[var(--text-muted)] mb-2">Powered by</p>
              <button
                id="buyTokenButton"
                class="text-[var(--accent-light)] hover:text-[var(--accent)] font-semibold text-lg transition-colors bg-transparent border-none cursor-pointer"
              >
                $NEYNARTODES
              </button>
              <p class="font-mono text-xs text-[var(--text-muted)] mt-2 break-all">0x8de1622fe07f56cda2e2273e615a513f1d828b07</p>
              <p class="text-xs text-[var(--text-muted)] mt-1">Tap to buy tokens</p>
            </div>

            <!-- How to use -->
            <a
              href="https://github.com/95m6sbvh6c-byte/neynartode#readme"
              target="_blank"
              class="mt-6 inline-block text-[var(--text-muted)] hover:text-[var(--text-secondary)] text-sm transition-colors"
            >
              How to Use
            </a>
          </div>
        </div>
      `;
    }

    function renderHeader() {
      // Only animate on first render, then mark as animated
      const shouldAnimate = !state.headerAnimated;
      if (shouldAnimate) state.headerAnimated = true;

      return `
        <header class="glass-card p-4 mb-6${shouldAnimate ? ' animate-fade-in' : ''}">
          <!-- Top bar with logo and user info -->
          <div class="flex items-center justify-between mb-4">
            <div class="flex items-center gap-3">
              <div class="w-10 h-10 rounded-xl overflow-hidden">
                <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-cover" style="filter: drop-shadow(0 0 8px rgba(139, 92, 246, 0.6));" />
              </div>
              <div>
                <h1 class="text-xl font-bold text-gradient">NEYNARtodes</h1>
                <p class="text-xs text-[var(--text-muted)]">Season 0 Beta</p>
              </div>
            </div>
            <div class="flex items-center gap-3">
              <div class="text-right">
                <p class="text-sm font-medium text-[var(--text-primary)]">
                  ${parseFloat(state.userBalance).toLocaleString()} <span class="text-[var(--accent-light)]">$NEYNARTODES</span>
                </p>
                <p class="text-xs text-[var(--text-muted)]">
                  ${state.userAddress.substring(0, 6)}...${state.userAddress.substring(38)}
                  ${state.userBadges.length > 0 ? `<span class="ml-1">${state.userBadges.map(b => getBadgeEmoji(b)).join('')}</span>` : ''}
                </p>
              </div>
              <div class="w-2 h-2 rounded-full ${window.activeEthProvider ? 'bg-[var(--success)]' : 'bg-[var(--error)]'}"></div>
            </div>
          </div>

          <!-- Public Testing Mode Banner -->
          ${CONFIG.PUBLIC_TESTING_MODE && state.currentView === 'active' ? `
            <div class="mb-3 p-4 rounded-xl bg-gradient-to-r from-[var(--warning)]/20 to-[var(--accent)]/20 border border-[var(--warning)]/40">
              <div class="flex items-center gap-3 mb-2">
                <span class="text-2xl">ðŸ§ª</span>
                <div>
                  <h3 class="font-bold text-[var(--text-primary)]">Public Testing Phase</h3>
                  <p class="text-xs text-[var(--text-muted)]">Contest entries are now open!</p>
                </div>
              </div>
              <p class="text-sm text-[var(--text-secondary)] mb-2">
                We're testing contest entries before full launch. Enter contests to help us test!
              </p>
              <div class="flex items-center gap-2 text-xs text-[var(--warning)]">
                <span>ðŸš€</span>
                <span class="font-medium">Full app launch coming soon!</span>
              </div>
            </div>
          ` : ''}

          <!-- Buy Burn Hold Earn Banner (shown on active and create pages) -->
          ${state.currentView === 'active' || state.currentView === 'create' ? `
            <div class="mb-3 p-3 rounded-xl bg-gradient-to-r from-[var(--accent)]/10 to-[var(--success)]/10 border border-[var(--accent)]/20 cursor-pointer hover:border-[var(--accent)]/40 transition-all" onclick="showBuyBurnHoldEarnModal()">
              <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                  <span class="text-lg">ðŸ”¥</span>
                  <div>
                    <span class="font-semibold text-[var(--accent-light)]">Buy Burn Hold Earn</span>
                    <span class="text-xs text-[var(--text-muted)] ml-2">Tap for details</span>
                  </div>
                </div>
                <svg class="w-4 h-4 text-[var(--text-muted)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                </svg>
              </div>
              <div class="mt-2 flex flex-wrap gap-2 text-xs">
                <span class="px-2 py-0.5 rounded-full bg-[var(--accent)]/20 text-[var(--accent-light)]">25% to You</span>
                <span class="px-2 py-0.5 rounded-full bg-[var(--error)]/20 text-[var(--error)]">25% Burned</span>
                <span class="px-2 py-0.5 rounded-full bg-[var(--success)]/20 text-[var(--success)]">35% Treasury</span>
                <span class="px-2 py-0.5 rounded-full bg-[var(--warning)]/20 text-[var(--warning)]">15% to Host</span>
              </div>
            </div>
          ` : ''}

          <!-- Active page title -->
          <div class="mb-2 py-3 text-center">
            <h2 class="text-xl font-bold text-gradient">
              ${state.currentView === 'create' ? 'Create Contest' :
                state.currentView === 'history' ? 'Contest History' :
                state.currentView === 'leaderboard' ? 'Leaderboard' :
                state.currentView === 'active' ? 'Active Contests' :
                'Suggestions'}
            </h2>
            ${state.currentView === 'active' ? `
              <div class="mt-2 text-xs text-[var(--text-secondary)]">
                <p class="mb-1">Earn bonus entries in every raffle <span class="text-[var(--text-muted)]">(tap for details)</span>:</p>
                <div class="flex flex-wrap justify-center gap-x-3 gap-y-1">
                  <span class="bonus-tip cursor-pointer px-2 py-1 rounded-lg hover:bg-[var(--bg-tertiary)] transition-colors" onclick="showBonusTip('Hold 100M+ $NEYNARTODES across your verified wallets. DEX purchases qualify instantly. Wallet-to-wallet transfers have a 36hr cooldown.')">
                    ðŸ’Ž <span class="text-[var(--accent-light)]">100M Holder</span>
                  </span>
                  <span class="bonus-tip cursor-pointer px-2 py-1 rounded-lg hover:bg-[var(--bg-tertiary)] transition-colors" onclick="showBonusTip('Reply to the contest cast with 4 or more words. Engage with the community!')">
                    ðŸ’¬ Reply
                  </span>
                  <span class="bonus-tip cursor-pointer px-2 py-1 rounded-lg hover:bg-[var(--bg-tertiary)] transition-colors" onclick="showBonusTip('Click the Share button on any contest to spread the word and earn a bonus entry!')">
                    ðŸ“¤ Share
                  </span>
                  <span class="bonus-tip cursor-pointer px-2 py-1 rounded-lg hover:bg-[var(--bg-tertiary)] transition-colors" onclick="showBonusTip('Trade $20+ worth of $NEYNARTODES during the contest period. Volume is checked at finalization.')">
                    ðŸ“ˆ Volume
                  </span>
                </div>
                <div id="bonusTipDisplay" class="hidden mt-2 p-2 bg-[var(--bg-tertiary)] rounded-lg text-center text-[var(--text-primary)] border border-[var(--border-subtle)]"></div>
              </div>
            ` : ''}
          </div>

          <!-- Other navigation tabs (excluding current page) -->
          <!-- Order: Active, Create, Stats, History, Ideas -->
          <!-- In PUBLIC_TESTING_MODE, Create/Stats/History are admin-only -->
          <nav class="flex gap-1 p-1 bg-[var(--bg-secondary)] rounded-xl">
            ${state.currentView !== 'active' ? `
              <button id="viewActive" class="btn-ghost flex-1 text-[10px] py-2 px-1">Active</button>
            ` : ''}
            ${state.currentView !== 'create' && (!CONFIG.PUBLIC_TESTING_MODE || isUserAdmin()) ? `
              <button id="viewCreate" class="btn-ghost flex-1 text-[10px] py-2 px-1">Create</button>
            ` : ''}
            ${state.currentView !== 'leaderboard' && (!CONFIG.PUBLIC_TESTING_MODE || isUserAdmin()) ? `
              <button id="viewLeaderboard" class="btn-ghost flex-1 text-[10px] py-2 px-1">Stats</button>
            ` : ''}
            ${state.currentView !== 'history' && (!CONFIG.PUBLIC_TESTING_MODE || isUserAdmin()) ? `
              <button id="viewHistory" class="btn-ghost flex-1 text-[10px] py-2 px-1">History</button>
            ` : ''}
            ${state.currentView !== 'suggestions' ? `
              <button id="viewSuggestions" class="btn-ghost flex-1 text-[10px] py-2 px-1">Ideas</button>
            ` : ''}
          </nav>

          ${state.notificationsEnabled === false ? `
          <!-- Notification banner -->
          <div class="mt-3 p-3 rounded-xl ${state.notificationsWereReset ? 'bg-[var(--error)]/10 border-[var(--error)]/30' : 'bg-[var(--warning)]/10 border-[var(--warning)]/30'} border flex items-center justify-between gap-2">
            <div class="flex items-center gap-2 text-sm">
              <span>ðŸ””</span>
              <span class="text-[var(--text-secondary)]">
                ${state.notificationsWereReset ? 'Notifications reset! Tap to re-enable' : 'Notifications are off'}
              </span>
            </div>
            <button onclick="enableNotifications()" class="btn-ghost text-xs px-3 py-1 ${state.notificationsWereReset ? 'bg-[var(--error)]/20 hover:bg-[var(--error)]/30 animate-pulse' : 'bg-[var(--warning)]/20 hover:bg-[var(--warning)]/30'}">
              Enable
            </button>
          </div>
          ` : ''}
        </header>
      `;
    }

    function renderLeaderboard() {
      return `
        <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
          <!-- Subtle background gradient -->
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>

          <div class="max-w-6xl mx-auto relative z-10">
            ${renderHeader()}

            <div class="space-y-4">
              <!-- Current Leader - Full Width Row -->
              <div class="stat-card">
                <div class="stat-label text-center">Current Leader</div>
                ${state.leaderboardData.length > 0 ? `
                  <button onclick="openProfile('${state.leaderboardData[0].username}')" class="flex flex-col items-center hover:opacity-80 transition-opacity mt-2 cursor-pointer bg-transparent border-none w-full">
                    ${state.leaderboardData[0].pfpUrl
                      ? `<img src="${state.leaderboardData[0].pfpUrl}" alt="" class="w-12 h-12 rounded-full object-cover mb-2" onerror="this.style.display='none';" />`
                      : `<span class="w-12 h-12 rounded-full bg-[var(--bg-tertiary)] flex items-center justify-center text-xl mb-2">${state.leaderboardData[0].pfp}</span>`
                    }
                    <span class="stat-value stat-value-sm text-[var(--accent-light)]">@${state.leaderboardData[0].username}</span>
                    <div class="stat-subtitle">${state.leaderboardData[0].totalScore.toLocaleString()} points</div>
                  </button>
                ` : `
                  <div class="text-center mt-2">
                    <div class="stat-value stat-value-sm">TBA</div>
                    <div class="stat-subtitle">Be the first!</div>
                  </div>
                `}
              </div>

              <!-- Stats Grid -->
              <div class="grid grid-cols-3 gap-3">
                <!-- Season Countdown -->
                <div class="stat-card">
                  <div class="stat-label">Season Ends</div>
                  ${(() => {
                    const countdown = getSeasonCountdown();
                    if (!countdown) return '<div id="countdown-text" class="stat-value stat-value-sm">Loading...</div>';
                    if (countdown.ended) return '<div id="countdown-text" class="stat-value stat-value-sm">Ended</div>';
                    return `
                      <div id="countdown-text" class="stat-value stat-value-sm">${countdown.text}</div>
                      <div class="stat-subtitle">Season ${state.currentSeason}</div>
                    `;
                  })()}
                </div>

                <!-- Host Prize Pool -->
                <div class="stat-card">
                  <div class="stat-label">Prize Pool</div>
                  <div class="stat-value stat-value-sm">${state.hostPoolETH.toFixed(4)} <span class="text-[var(--text-muted)] text-lg">ETH</span></div>
                  <div class="stat-subtitle">For hosts</div>
                </div>

                <!-- Tokens Burned -->
                <div class="stat-card">
                  <div class="stat-label">Tokens Burned</div>
                  <div class="stat-value stat-value-sm">${Number(state.totalTokensBurned).toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                  <div class="stat-subtitle">From supply</div>
                </div>
              </div>

              <!-- All-Time Prizes - Full Width -->
              <div class="stat-card">
                <div class="flex items-center justify-between">
                  <div>
                    <div class="stat-label">All-Time Prizes Distributed</div>
                    <div class="stat-value">${state.totalPrizesGiven.toFixed(4)} <span class="text-[var(--text-muted)] text-xl">ETH</span></div>
                  </div>
                  <div class="flex items-center gap-3">
                    <button
                      onclick="shareSeasonStats()"
                      class="px-4 py-2 rounded-lg bg-[var(--bg-tertiary)] hover:bg-[var(--accent)] hover:bg-opacity-20 text-[var(--text-muted)] hover:text-[var(--accent-light)] transition-colors text-sm font-medium flex items-center gap-2"
                      title="Share season stats"
                    >ðŸ“¤ Share Stats</button>
                    <div class="text-4xl opacity-20">ðŸ’Ž</div>
                  </div>
                </div>
              </div>

              <!-- Feed the Neynartodes -->
              ${parseFloat(state.pendingClankerFees) > 0 ? `
                <div class="glass-card-accent p-5">
                  <div class="flex items-center justify-between gap-4">
                    <div class="flex-1">
                      <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-1">Feed the Neynartodes</h3>
                      <p class="text-sm text-[var(--text-secondary)]">
                        ${parseFloat(state.pendingClankerFees).toFixed(2)} tokens available from Clanker fees
                      </p>
                    </div>
                    <button onclick="feedTheNeynartodes()" class="btn-primary whitespace-nowrap">
                      Feed Now
                    </button>
                  </div>
                </div>
              ` : ''}

              <!-- Voting Power -->
              <div class="glass-card p-5">
                <div class="flex items-center justify-between mb-4">
                  <div>
                    <h3 class="text-lg font-semibold text-[var(--accent-light)]">Your Voting Power</h3>
                    <p class="text-sm text-[var(--text-secondary)]">1000 tokens per vote â€¢ Resets daily</p>
                  </div>
                  <div class="text-right">
                    <div class="text-3xl font-bold text-[var(--accent-light)]">${state.votesRemaining}<span class="text-[var(--text-muted)] text-lg">/10</span></div>
                    <div class="text-xs text-[var(--text-muted)]">votes remaining</div>
                  </div>
                </div>
                <div class="divider"></div>
                <div class="grid grid-cols-3 gap-4 text-center text-sm">
                  <div>
                    <div class="text-[var(--text-muted)] mb-1">Cost</div>
                    <div class="text-[var(--text-primary)] font-medium">1000 tokens</div>
                  </div>
                  <div>
                    <div class="text-[var(--text-muted)] mb-1">Upvote</div>
                    <div class="text-[var(--success)] font-medium">+200 pts</div>
                  </div>
                  <div>
                    <div class="text-[var(--text-muted)] mb-1">Downvote</div>
                    <div class="text-[var(--error)] font-medium">-200 pts</div>
                  </div>
                </div>
              </div>

              <!-- Leaderboard Table -->
              <div class="glass-card p-5">
                <div class="flex items-center justify-between mb-5">
                  <div>
                    <h2 class="text-xl font-bold"><span class="text-gradient">NEYNARtodes</span> <span class="text-[var(--text-primary)]">Leaderboard</span></h2>
                    <p class="text-sm text-[var(--text-muted)]">Season ${state.currentSeason} Rankings</p>
                  </div>
                  <a
                    href="https://github.com/95m6sbvh6c-byte/neynartode/blob/main/docs/GUIDE_LEADERBOARD.md"
                    target="_blank"
                    class="btn-ghost text-sm"
                  >Guide</a>
                </div>

                <div class="overflow-x-auto">
                  ${state.leaderboardData.length === 0 ? `
                    <div class="text-center py-12">
                      <div class="w-16 h-16 mx-auto mb-4">
                        <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-contain" style="filter: drop-shadow(0 0 15px rgba(139, 92, 246, 0.5));" />
                      </div>
                      <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-2">No Hosts Yet</h3>
                      <p class="text-[var(--text-secondary)] text-sm">Be the first to launch a contest!</p>
                    </div>
                  ` : `
                  <table class="w-full">
                    <thead>
                      <tr class="border-b border-[var(--border-subtle)]">
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Rank</th>
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Host</th>
                        <th class="text-right py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Score</th>
                        <th class="text-center py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Vote</th>
                        <th class="text-right py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Contests</th>
                        <th class="text-right py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Neynar</th>
                        <th class="text-center py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider"></th>
                      </tr>
                    </thead>
                    <tbody>
                      ${state.leaderboardData.map(host => `
                        <tr class="border-b border-[var(--border-subtle)] hover:bg-[var(--bg-secondary)] transition-colors">
                          <td class="py-4 px-2">
                            <div class="font-bold text-lg ${
                              host.rank === 1 ? 'text-yellow-400' :
                              host.rank === 2 ? 'text-gray-400' :
                              host.rank === 3 ? 'text-orange-400' :
                              'text-[var(--text-muted)]'
                            }">
                              ${host.rank <= 3 ? ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][host.rank - 1] : host.rank}
                            </div>
                          </td>
                          <td class="py-4 px-2">
                            <button onclick="openProfile('${host.username}')" class="flex flex-col items-center hover:opacity-80 transition-opacity cursor-pointer bg-transparent border-none">
                              ${host.pfpUrl
                                ? `<img src="${host.pfpUrl}" alt="" class="w-8 h-8 rounded-full object-cover mb-1" onerror="this.style.display='none';" />`
                                : `<span class="w-8 h-8 rounded-full bg-[var(--bg-tertiary)] flex items-center justify-center text-sm mb-1">${host.pfp}</span>`
                              }
                              <div class="text-xs font-medium text-[var(--accent-light)] text-center hover:underline">
                                @${host.username}
                                ${host.badges.map(badge => `<span title="${getBadgeTitle(badge)}">${getBadgeEmoji(badge)}</span>`).join('')}
                              </div>
                            </button>
                          </td>
                          <td class="py-4 px-2 text-right">
                            <div class="font-semibold text-[var(--accent-light)]" title="Contest: ${(host.contestScore || 0).toLocaleString()} | Votes: ${(host.voteScore || 0).toLocaleString()}">
                              ${(host.totalScore || 0).toLocaleString()}
                            </div>
                            <div class="text-xs text-[var(--text-muted)] mt-0.5">
                              ${(host.socialScore || 0).toLocaleString()} social Â· ${(host.tokenScore || 0).toLocaleString()} token
                            </div>
                          </td>
                          <td class="py-4 px-2">
                            <div class="flex gap-1 justify-center">
                              <button
                                onclick="voteForHost(${host.fid}, true)"
                                ${state.votesRemaining <= 0 ? 'disabled' : ''}
                                class="w-8 h-8 flex items-center justify-center rounded-lg bg-[var(--success-glow)] hover:bg-[var(--success)] hover:bg-opacity-30 disabled:opacity-30 disabled:cursor-not-allowed text-[var(--success)] transition-colors text-sm"
                                title="Upvote (+200 pts)"
                              >â–²</button>
                              <button
                                onclick="voteForHost(${host.fid}, false)"
                                ${state.votesRemaining <= 0 ? 'disabled' : ''}
                                class="w-8 h-8 flex items-center justify-center rounded-lg bg-[var(--error-glow)] hover:bg-[var(--error)] hover:bg-opacity-30 disabled:opacity-30 disabled:cursor-not-allowed text-[var(--error)] transition-colors text-sm"
                                title="Downvote (-200 pts)"
                              >â–¼</button>
                            </div>
                          </td>
                          <td class="py-4 px-2 text-right">
                            <div class="font-medium text-[var(--text-primary)]">${host.completedContests || host.contests || 0}</div>
                            <div class="text-xs text-[var(--text-muted)]">${host.contests || 0} total</div>
                          </td>
                          <td class="py-4 px-2 text-right">
                            <span class="tag tag-accent">${host.neynarScore}</span>
                          </td>
                          <td class="py-4 px-2 text-center">
                            <button
                              onclick='shareHostStats(${JSON.stringify(host).replace(/'/g, "\\'")})'
                              class="w-8 h-8 flex items-center justify-center rounded-lg bg-[var(--bg-tertiary)] hover:bg-[var(--accent)] hover:bg-opacity-20 text-[var(--text-muted)] hover:text-[var(--accent-light)] transition-colors text-sm"
                              title="Share stats"
                            >ðŸ“¤</button>
                          </td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                  `}
                </div>

                <!-- Scoring Info - Collapsed by default -->
                <details class="mt-4">
                  <summary class="text-sm text-[var(--text-muted)] cursor-pointer hover:text-[var(--text-secondary)] transition-colors">
                    How scoring works
                  </summary>
                  <div class="mt-3 p-4 bg-[var(--bg-secondary)] rounded-xl text-sm text-[var(--text-secondary)] space-y-1">
                    <div><span class="text-[var(--text-primary)]">Total Score</span> = Contest Score + Vote Score</div>
                    <div><span class="text-[var(--text-primary)]">Contest Score</span> = (Social Ã— 3) + Token</div>
                    <div><span class="text-[var(--text-primary)]">Vote Score</span> = (Upvotes - Downvotes) Ã— 200</div>
                  </div>
                </details>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // Generate floating avatars (PFPs) in synchronized rows at top-right
    // Rows fill from right to left, new rows start below when full
    function generateEntryStickers(participantCount, contestId) {
      const count = participantCount || 0;
      if (count === 0) return '';

      // Get participant data from state (now includes count and hasMore)
      const participantData = state.contestParticipants[contestId] || { participants: [], count: 0, hasMore: false };
      const participants = participantData.participants || [];
      const totalCount = participantData.count || count;

      const hasPfps = participants.length > 0;

      // Use contestId as seed for consistent animation timing
      const seededRandom = (seed, i) => {
        const x = Math.sin(seed * 9999 + i * 7777) * 10000;
        return x - Math.floor(x);
      };

      // Layout settings
      const pfpSize = 26;
      const overlap = 8; // Horizontal overlap
      const rowGap = 4; // Vertical gap between rows
      const maxPerRow = 6; // Max PFPs per row before wrapping
      const maxRows = 3; // Max number of rows
      const maxDisplay = maxPerRow * maxRows; // Total max display

      const displayCount = Math.min(participants.length, maxDisplay);

      // Group PFPs into rows
      const rows = [];
      for (let i = 0; i < displayCount; i += maxPerRow) {
        rows.push(participants.slice(i, Math.min(i + maxPerRow, displayCount)));
      }

      // Build rows HTML
      let rowsHtml = '';
      rows.forEach((rowParticipants, rowIndex) => {
        let rowPfps = '';
        rowParticipants.forEach((participant, colIndex) => {
          const imgSrc = participant?.pfpUrl || '/neynartode-sticker.png';
          const isPfp = hasPfps && participant?.pfpUrl;
          const title = participant?.username ? `title="@${participant.username}"` : '';
          // Simple accent border for all participants
          const borderColor = 'rgba(139, 92, 246, 0.6)';
          const shadowColor = 'rgba(139, 92, 246, 0.4)';

          rowPfps += `<img
            src="${imgSrc}"
            alt=""
            ${title}
            class="pointer-events-none"
            style="
              width: ${pfpSize}px;
              height: ${pfpSize}px;
              ${isPfp ? 'border-radius: 50%;' : ''}
              ${isPfp ? `border: 2px solid ${borderColor};` : ''}
              ${isPfp ? `box-shadow: 0 0 6px ${shadowColor};` : ''}
              margin-left: ${colIndex === 0 ? '0' : `-${overlap}px`};
              z-index: ${rowParticipants.length - colIndex};
              object-fit: cover;
              flex-shrink: 0;
            "
            onerror="this.src='/neynartode-sticker.png'; this.style.borderRadius='0'; this.style.border='none';"
          />`;
        });

        // Odd rows (1, 3) drift right, even rows (2) drift left
        // rowIndex is 0-based, so index 0 = row 1 (odd), index 1 = row 2 (even)
        const driftClass = rowIndex % 2 === 0 ? 'drift-right' : 'drift-left';
        rowsHtml += `<div class="flex items-center justify-end ${driftClass}" style="margin-top: ${rowIndex === 0 ? '0' : rowGap + 'px'}; --drift-duration: ${3 + rowIndex * 0.5}s;">${rowPfps}</div>`;
      });

      // Add "+X more" indicator if there are more participants than displayed
      const remaining = totalCount - displayCount;
      if (remaining > 0) {
        rowsHtml += `<div
          class="text-xs text-[var(--accent)] text-right mt-1 cursor-pointer hover:underline"
          onclick="event.stopPropagation(); showParticipantsModal('${contestId}')"
        >+${remaining} more</div>`;
      }

      // Container for rows - each row animates independently
      return `<div
        class="absolute flex flex-col items-end"
        style="
          top: 6px;
          right: 6px;
          opacity: 0.95;
          z-index: 10;
        "
      >${rowsHtml}</div>`;
    }

    function renderActiveContests() {
      const activeContests = state.upcomingContests.filter(c => new Date(c.endTime) > new Date()).slice(0, 50);

      let contestsHtml = '';
      if (activeContests.length > 0) {
        contestsHtml = activeContests.map(contest => {
          const now = new Date();
          const isLive = contest.status === 0 && new Date(contest.endTime) > now;
          const isPending = contest.status === 1;
          const timeLeft = Math.max(0, Math.floor((new Date(contest.endTime) - now) / 1000));
          const hoursLeft = Math.floor(timeLeft / 3600);
          const minutesLeft = Math.floor((timeLeft % 3600) / 60);

          const statusTag = isLive
            ? '<span class="tag tag-success"><span class="w-1.5 h-1.5 rounded-full bg-[var(--success)] animate-pulse"></span>Live</span>'
            : isPending
            ? '<span class="tag tag-warning">Pending</span>'
            : '<span class="tag tag-accent">Upcoming</span>';

          const hostImg = contest.hostUser?.pfpUrl ? `<img src="${contest.hostUser.pfpUrl}" class="w-7 h-7 rounded-full" onerror="this.style.display='none'" />` : '';
          const hostName = contest.hostUser?.username ? '@' + contest.hostUser.username : contest.host.slice(0, 10) + '...';

          let prizeHtml = '';
          if (contest.isNft) {
            const nftImg = contest.nftImage
              ? `<img src="${proxyImage(contest.nftImage)}" alt="${contest.nftName || ''}" class="w-10 h-10 rounded-lg object-cover" onerror="this.onerror=null; this.src='https://via.placeholder.com/40/8b5cf6/ffffff?text=NFT'" />`
              : `<div class="w-10 h-10 rounded-lg bg-purple-500/20 flex items-center justify-center text-purple-400 text-xs">NFT</div>`;
            prizeHtml = `
              <div class="flex items-center gap-2">
                ${nftImg}
                <div>
                  <div class="text-sm font-semibold text-[var(--success)]">${contest.nftName || contest.prize || 'NFT Prize'}</div>
                  <span class="text-xs text-[var(--text-muted)]">${contest.nftCollection || contest.nftType || 'NFT'}</span>
                </div>
              </div>
            `;
          } else {
            prizeHtml = `<div class="text-sm font-semibold text-[var(--success)]">${contest.prize}</div>`;
          }

          // Generate entry stickers for this contest
          const entryStickers = generateEntryStickers(contest.participantCount, contest.contestId);

          return `
            <div class="p-4 rounded-xl bg-[var(--bg-secondary)] border border-[var(--border-subtle)] hover:border-[var(--border-light)] transition-all relative overflow-hidden">
              <!-- Entry stickers background -->
              ${entryStickers}
              <div class="flex items-start justify-between gap-4 relative z-10">
                <div class="flex-1 min-w-0">
                  <div class="flex items-center gap-2 mb-3">
                    ${statusTag}
                    <span class="text-sm text-[var(--text-muted)]">#${contest.contestId}</span>
                  </div>
                  <div class="flex items-center gap-2 mb-3">
                    ${hostImg}
                    <span class="font-medium text-[var(--text-primary)]">${hostName}</span>
                  </div>
                  <div class="grid grid-cols-2 gap-3 mb-3">
                    <div>
                      <div class="text-xs text-[var(--text-muted)] mb-0.5">Prize</div>
                      ${prizeHtml}
                    </div>
                    <div>
                      <div class="text-xs text-[var(--text-muted)] mb-0.5">Time Left</div>
                      <div class="text-sm font-semibold text-[var(--text-primary)]">${hoursLeft}h ${minutesLeft}m</div>
                    </div>
                  </div>
                  <div class="flex items-center gap-4 mb-3">
                    <div class="flex items-center gap-1">
                      <span class="text-xs text-[var(--text-muted)]">Entries:</span>
                      <span class="text-sm font-semibold text-[var(--accent)]">${contest.participantCount || 0}</span>
                    </div>
                    <div class="flex items-center gap-1">
                      <span class="text-xs text-[var(--text-muted)]">Winners:</span>
                      <span class="text-sm font-semibold ${(contest.winnerCount || 1) > 1 ? 'text-yellow-400' : 'text-[var(--text-primary)]'}">${contest.winnerCount || 1}</span>
                    </div>
                  </div>
                  <div class="flex gap-2 flex-wrap">
                    <button
                      data-contest-id="${contest.contestId}"
                      data-cast-id="${contest.castId || ''}"
                      data-prize="${encodeURIComponent(contest.prize)}"
                      data-hours="${hoursLeft}"
                      data-minutes="${minutesLeft}"
                      data-host="${encodeURIComponent(contest.hostUser?.username || '')}"
                      data-is-nft="${contest.isNft || false}"
                      data-nft-image="${encodeURIComponent(contest.nftImage || '')}"
                      data-nft-name="${encodeURIComponent(contest.nftName || '')}"
                      onclick="enterRaffle(this)"
                      class="btn-primary text-sm py-2 px-4 enter-raffle-btn"
                      id="enter-btn-${contest.contestId}"
                      ${state.contestEntries?.[contest.contestId]?.entered ? 'disabled style="opacity: 0.6; cursor: default;"' : ''}
                    >
                      ${state.contestEntries?.[contest.contestId]?.entered ? 'Entered âœ“' : 'Enter Raffle'}
                    </button>
                    <button
                      onclick="viewCast('${(contest.castId || '').split('|')[0]}')"
                      class="btn-secondary text-sm py-2 px-4"
                      ${!contest.castId ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}
                    >
                      <svg class="w-4 h-4 inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/>
                      </svg>
                      View Cast
                    </button>
                    <button
                      data-contest-id="${contest.contestId}"
                      data-prize="${encodeURIComponent(contest.prize)}"
                      data-hours="${hoursLeft}"
                      data-minutes="${minutesLeft}"
                      data-volume="${contest.volumeRequirement || 0}"
                      data-token="${encodeURIComponent(contest.tokenRequirementSymbol || '')}"
                      data-host="${encodeURIComponent(contest.hostUser?.username || '')}"
                      data-cast-id="${contest.castId || ''}"
                      data-is-nft="${contest.isNft || false}"
                      data-nft-image="${encodeURIComponent(contest.nftImage || '')}"
                      data-winner-count="${contest.winnerCount || 1}"
                      data-participant-count="${contest.participantCount || 0}"
                      onclick="openCastModalFromData(this)"
                      class="${state.contestShares?.[contest.contestId] ? 'btn-success' : 'btn-secondary'} text-sm py-2 px-4"
                      id="share-btn-${contest.contestId}"
                      ${state.contestShares?.[contest.contestId] ? 'style="opacity: 0.8;"' : ''}
                    >
                      ${state.contestShares?.[contest.contestId] ? 'Shared âœ“' : 'Share'}
                    </button>
                  </div>
                </div>
              </div>
            </div>
          `;
        }).join('');
      }

      const moreText = state.upcomingContests.length > 50
        ? `<div class="mt-4 text-center text-sm text-[var(--text-muted)]">+ ${state.upcomingContests.length - 50} more contests</div>`
        : '';

      // Loading skeleton for contests
      const loadingSkeleton = `
        <div class="space-y-3">
          ${[1,2,3].map(() => `
            <div class="p-4 rounded-xl bg-[var(--bg-secondary)] border border-[var(--border-subtle)]">
              <div class="flex items-start justify-between gap-4">
                <div class="flex-1">
                  <div class="flex items-center gap-2 mb-3">
                    <div class="skeleton w-16 h-5"></div>
                    <div class="skeleton w-10 h-4"></div>
                  </div>
                  <div class="flex items-center gap-2 mb-3">
                    <div class="skeleton w-6 h-6 rounded-full"></div>
                    <div class="skeleton w-24 h-4"></div>
                  </div>
                  <div class="grid grid-cols-2 gap-3 mb-3">
                    <div>
                      <div class="skeleton w-12 h-3 mb-1"></div>
                      <div class="skeleton w-20 h-5"></div>
                    </div>
                    <div>
                      <div class="skeleton w-16 h-3 mb-1"></div>
                      <div class="skeleton w-14 h-5"></div>
                    </div>
                  </div>
                  <div class="flex gap-2">
                    <div class="skeleton w-24 h-9 rounded-xl"></div>
                    <div class="skeleton w-16 h-9 rounded-xl"></div>
                  </div>
                </div>
              </div>
            </div>
          `).join('')}
        </div>
      `;

      // Show loading state
      if (state.contestsLoading) {
        return `
          <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
            <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>
            <div class="max-w-6xl mx-auto relative z-10">
              ${renderHeader()}
              <div class="glass-card p-5">
                <div class="flex items-center justify-between mb-4">
                  <div>
                    <h2 class="text-xl font-bold"><span class="text-[var(--text-primary)]">Active</span> <span class="text-gradient">Contests</span></h2>
                    <p class="text-sm text-[var(--text-muted)]">Loading contests...</p>
                  </div>
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 border-2 border-[var(--accent)] border-t-transparent rounded-full animate-spin"></div>
                  </div>
                </div>
                ${loadingSkeleton}
              </div>
            </div>
          </div>
        `;
      }

      if (state.upcomingContests.length > 0) {
        return `
          <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
            <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>
            <div class="max-w-6xl mx-auto relative z-10">
              ${renderHeader()}
              <div class="glass-card p-5">
                <div class="flex items-center justify-between mb-4">
                  <div>
                    <h2 class="text-xl font-bold"><span class="text-[var(--text-primary)]">Active</span> <span class="text-gradient">Contests</span></h2>
                    <p class="text-sm text-[var(--text-muted)]">${state.upcomingContests.length} live now</p>
                  </div>
                  <div class="flex items-center gap-3">
                    <button onclick="refreshContests()" class="p-1.5 rounded-lg hover:bg-[var(--bg-tertiary)] transition-colors" title="Refresh contests">
                      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-[var(--text-muted)]"><path d="M21 2v6h-6"></path><path d="M3 12a9 9 0 0 1 15-6.7L21 8"></path><path d="M3 22v-6h6"></path><path d="M21 12a9 9 0 0 1-15 6.7L3 16"></path></svg>
                    </button>
                    <div class="flex items-center gap-2">
                      <div class="w-2 h-2 rounded-full bg-[var(--success)] animate-pulse"></div>
                      <span class="text-sm text-[var(--text-muted)]">Live</span>
                    </div>
                  </div>
                </div>
                <div class="space-y-3">${contestsHtml}</div>
                ${moreText}
              </div>
            </div>
          </div>
        `;
      } else {
        return `
          <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
            <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>
            <div class="max-w-6xl mx-auto relative z-10">
              ${renderHeader()}
              <div class="glass-card p-8 text-center">
                <div class="text-4xl mb-4">ðŸ¸</div>
                <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-2">No Active Contests</h3>
                <p class="text-sm text-[var(--text-muted)] mb-4">Be the first to create one!</p>
                <button onclick="state.currentView = 'create'; render();" class="btn-primary">Create Contest</button>
              </div>
            </div>
          </div>
        `;
      }
    }

    function renderHistory() {
      return `
        <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>

          <div class="max-w-6xl mx-auto relative z-10">
            ${renderHeader()}

            <!-- Stats Summary -->
            <div class="grid grid-cols-3 gap-3 mb-4">
              <div class="stat-card">
                <div class="stat-label">Season 2 Contests</div>
                <div class="stat-value stat-value-sm">${state.historyTotal || 0}</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Token Contests</div>
                <div class="stat-value stat-value-sm">${state.historyTotalToken || 0}</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">V2 Contests</div>
                <div class="stat-value stat-value-sm">${state.historyTotalV2 || 0}</div>
              </div>
            </div>

            <!-- Contest History Table -->
            <div class="glass-card p-5">
              <div class="flex items-center justify-between mb-5">
                <div>
                  <h2 class="text-xl font-bold text-[var(--text-primary)]">Contest History</h2>
                  <p class="text-sm text-[var(--text-muted)]">Last 20 contests</p>
                </div>
                <div class="flex items-center gap-2">
                  <a
                    href="https://github.com/95m6sbvh6c-byte/neynartode/blob/main/docs/GUIDE_HISTORY.md"
                    target="_blank"
                    class="btn-ghost text-sm"
                  >Guide</a>
                  <button onclick="loadHistory()" class="btn-secondary text-sm py-2 px-3">
                    Refresh
                  </button>
                </div>
              </div>

              ${state.historyLoading ? `
                <div class="text-center py-12">
                  <div class="w-16 h-16 mx-auto mb-4 animate-bounce">
                    <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-contain" style="filter: drop-shadow(0 0 15px rgba(139, 92, 246, 0.5));" />
                  </div>
                  <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-2">Loading Contests...</h3>
                  <p class="text-[var(--text-muted)] text-sm">Fetching on-chain data</p>
                </div>
              ` : state.historyError ? `
                <div class="text-center py-12">
                  <div class="text-5xl mb-4 opacity-50">âŒ</div>
                  <h3 class="text-lg font-semibold text-[var(--error)] mb-2">Error Loading History</h3>
                  <p class="text-[var(--text-muted)] text-sm mb-4">${state.historyError}</p>
                  <button onclick="loadHistory()" class="btn-secondary text-sm">
                    Try Again
                  </button>
                </div>
              ` : state.historyData.length === 0 ? `
                <div class="text-center py-12">
                  <div class="w-16 h-16 mx-auto mb-4">
                    <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-contain" style="filter: drop-shadow(0 0 15px rgba(139, 92, 246, 0.5));" />
                  </div>
                  <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-2">No Contests Yet</h3>
                  <p class="text-[var(--text-secondary)] text-sm">Be the first to launch a contest!</p>
                </div>
              ` : `
                <div class="overflow-x-auto">
                  <table class="w-full">
                    <thead>
                      <tr class="border-b border-[var(--border-subtle)]">
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">#</th>
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Host</th>
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Prize</th>
                        <th class="text-center py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Duration</th>
                        <th class="text-center py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Entries</th>
                        <th class="text-center py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Status</th>
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Winner</th>
                        <th class="text-right py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Ended</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${state.historyData.map(contest => `
                        <tr class="border-b border-[var(--border-subtle)] hover:bg-[var(--bg-secondary)] transition-colors">
                          <td class="py-4 px-2">
                            <div class="font-medium text-[var(--accent-light)]">${contest.contestId}</div>
                          </td>
                          <td class="py-4 px-2">
                            ${contest.hostUser ? `
                              <a href="https://warpcast.com/${contest.hostUser.username}" target="_blank" class="flex flex-col items-center hover:opacity-80 transition-opacity">
                                ${contest.hostUser.pfpUrl
                                  ? `<img src="${contest.hostUser.pfpUrl}" alt="" class="w-7 h-7 rounded-full object-cover mb-1" onerror="this.style.display='none';" />`
                                  : `<span class="w-7 h-7 rounded-full bg-[var(--bg-tertiary)] flex items-center justify-center text-xs mb-1">ðŸ‘¤</span>`
                                }
                                <span class="text-xs font-medium text-[var(--text-primary)]">@${contest.hostUser.username}</span>
                              </a>
                            ` : `
                              <span class="font-mono text-xs text-[var(--text-muted)]">${contest.host.slice(0, 8)}...</span>
                            `}
                          </td>
                          <td class="py-4 px-2">
                            <div class="font-medium text-[var(--success)]">
                              ${contest.prizeAmount.toLocaleString(undefined, { maximumFractionDigits: 4 })} $${contest.prizeTokenSymbol}
                            </div>
                          </td>
                          <td class="py-4 px-2 text-center">
                            <span class="text-[var(--text-secondary)]">
                              ${formatDuration(contest.durationHours, contest.durationMinutes)}
                            </span>
                          </td>
                          <td class="py-4 px-2 text-center">
                            <span class="tag tag-accent">${contest.participantCount}</span>
                          </td>
                          <td class="py-4 px-2 text-center">
                            <span class="tag ${contest.status === 0 ? 'tag-accent' : contest.status === 1 ? 'tag-warning' : contest.status === 2 ? 'tag-success' : 'tag-error'}">
                              ${contest.statusText}
                            </span>
                          </td>
                          <td class="py-4 px-2">
                            ${contest.status === 2 && contest.winner !== '0x0000000000000000000000000000000000000000' ? `
                              ${contest.winnerUser ? `
                                <a href="https://warpcast.com/${contest.winnerUser.username}" target="_blank" class="flex flex-col items-center hover:opacity-80 transition-opacity">
                                  ${contest.winnerUser.pfpUrl
                                    ? `<img src="${contest.winnerUser.pfpUrl}" alt="" class="w-7 h-7 rounded-full object-cover mb-1" onerror="this.style.display='none';" />`
                                    : `<span class="w-7 h-7 rounded-full bg-[var(--bg-tertiary)] flex items-center justify-center text-xs mb-1">ðŸ†</span>`
                                  }
                                  <span class="text-xs font-medium text-yellow-400">@${contest.winnerUser.username}</span>
                                </a>
                              ` : `
                                <span class="font-mono text-xs text-[var(--text-muted)]">${contest.winner.slice(0, 8)}...</span>
                              `}
                            ` : `
                              <span class="text-[var(--text-muted)]">â€”</span>
                            `}
                          </td>
                          <td class="py-4 px-2 text-right">
                            <span class="text-sm text-[var(--text-muted)]">
                              ${formatDate(contest.endTime)}
                            </span>
                          </td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>

                <!-- Legend - collapsed -->
                <details class="mt-4">
                  <summary class="text-sm text-[var(--text-muted)] cursor-pointer hover:text-[var(--text-secondary)] transition-colors">
                    Status legend
                  </summary>
                  <div class="mt-3 flex flex-wrap gap-2 text-xs">
                    <span class="tag tag-accent">Active</span>
                    <span class="tag tag-warning">PendingVRF</span>
                    <span class="tag tag-success">Completed</span>
                    <span class="tag tag-error">Cancelled</span>
                  </div>
                </details>
              `}
            </div>
          </div>
        </div>
      `;
    }

    function renderSuggestions() {
      const isDev = isDevWallet(state.userAddress);

      // Build DEV-only suggestions list
      let suggestionsHtml = '';
      if (isDev) {
        if (state.suggestionsLoading) {
          suggestionsHtml = `
            <div class="text-center py-8">
              <div class="text-3xl mb-2 animate-bounce opacity-50">ðŸ’¡</div>
              <p class="text-[var(--text-muted)]">Loading...</p>
            </div>
          `;
        } else if (state.suggestions.length === 0) {
          suggestionsHtml = `
            <div class="text-center py-8">
              <div class="text-3xl mb-2 opacity-50">ðŸ“­</div>
              <p class="text-[var(--text-muted)]">No suggestions yet</p>
            </div>
          `;
        } else {
          suggestionsHtml = `
            <div class="space-y-3 max-h-80 overflow-y-auto">
              ${state.suggestions.map(s => `
                <div class="bg-[var(--bg-tertiary)] rounded-lg p-4">
                  <div class="flex items-start justify-between gap-3">
                    <p class="text-[var(--text-primary)] flex-1 text-sm">${s.text}</p>
                    <span class="text-xs text-[var(--text-muted)] whitespace-nowrap">${new Date(s.timestamp).toLocaleDateString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
            <p class="text-xs text-[var(--text-muted)] mt-4">${state.suggestions.length} total</p>
          `;
        }
      }

      return `
        <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>

          <div class="max-w-2xl mx-auto relative z-10">
            ${renderHeader()}

            <div class="glass-card p-5">
              <div class="mb-6">
                <h2 class="text-xl font-bold text-[var(--text-primary)]">Suggestion Box</h2>
                <p class="text-sm text-[var(--text-muted)]">Help us improve NEYNARtodes</p>
              </div>

              <!-- Submission Form -->
              <div class="space-y-4 mb-6">
                <p class="text-sm text-[var(--text-secondary)]">
                  Submissions are <span class="text-[var(--accent-light)]">completely anonymous</span>
                </p>
                <textarea
                  id="suggestionInput"
                  placeholder="Share your idea, feedback, or suggestion..."
                  class="input-modern resize-none h-28"
                  maxlength="1000"
                >${state.suggestionText}</textarea>
                <div class="flex items-center justify-between">
                  <span class="text-xs text-[var(--text-muted)]">${state.suggestionText.length}/1000</span>
                  <button
                    id="submitSuggestion"
                    class="btn-primary py-2 px-5 text-sm disabled:opacity-50"
                    ${state.suggestionText.trim().length < 10 ? 'disabled' : ''}
                  >
                    Submit
                  </button>
                </div>
              </div>

              ${isDev ? `
              <!-- DEV Only: View All Suggestions -->
              <div class="p-4 bg-[var(--bg-secondary)] rounded-xl border border-[var(--warning)] border-opacity-30">
                <div class="flex items-center justify-between mb-4">
                  <h3 class="text-sm font-medium text-[var(--warning)]">Dev: All Suggestions</h3>
                  <button id="refreshSuggestions" class="btn-ghost text-xs">
                    Refresh
                  </button>
                </div>
                ${suggestionsHtml}
              </div>
              ` : `
              <!-- Non-DEV: Thank you message -->
              <div class="p-4 bg-[var(--bg-secondary)] rounded-xl text-center">
                <p class="text-[var(--text-secondary)] text-sm">
                  Thank you for helping improve NEYNARtodes
                </p>
              </div>
              `}
            </div>
          </div>
        </div>
      `;
    }

    function renderCreateContest() {
      return `
        <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>

          <div class="max-w-2xl mx-auto relative z-10">
            ${renderHeader()}

            <div class="glass-card p-5">
              <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold text-[var(--text-primary)]">Create Contest</h2>
                <a
                  href="https://github.com/95m6sbvh6c-byte/neynartode/blob/main/docs/GUIDE_CREATE.md"
                  target="_blank"
                  class="btn-ghost text-sm"
                >Guide</a>
              </div>

              <!-- Requirements Info -->
              <div class="bg-[var(--bg-tertiary)] border border-[var(--border-subtle)] rounded-xl p-3 mb-6">
                <div class="flex items-start gap-2">
                  <span class="text-[var(--accent)] text-sm">â„¹ï¸</span>
                  <div class="text-sm text-[var(--text-secondary)]">
                    <span class="text-[var(--text-primary)] font-medium">Requirements:</span>
                    Hold 100M $NEYNARTODES to create contests. Minimum prize: $0.50 USD equivalent.
                  </div>
                </div>
              </div>

              <div class="space-y-6">
                <!-- Contest Period -->
                <div class="space-y-4">
                  <h3 class="text-sm font-medium text-[var(--accent-light)] uppercase tracking-wider">Duration</h3>

                  <div>
                    <label class="block text-sm text-[var(--text-secondary)] mb-2">Start Mode</label>
                    <div class="flex gap-2">
                      <button id="startNow" class="flex-1 py-2.5 rounded-xl font-medium transition-all ${state.startMode === 'now' ? 'bg-[var(--accent)] text-white' : 'bg-[var(--bg-tertiary)] text-[var(--text-secondary)] hover:text-[var(--text-primary)]'}">
                        Start Now
                      </button>
                      <button id="startScheduled" class="flex-1 py-2.5 rounded-xl font-medium transition-all ${state.startMode === 'scheduled' ? 'bg-[var(--accent)] text-white' : 'bg-[var(--bg-tertiary)] text-[var(--text-secondary)] hover:text-[var(--text-primary)]'}">
                        Schedule
                      </button>
                    </div>
                  </div>

                  ${state.startMode === 'scheduled' ? `
                    <div>
                      <label class="block text-sm text-[var(--text-secondary)] mb-2">Start Date & Time</label>
                      <input type="datetime-local" id="startDate" value="${state.startDate}" class="input-modern" />
                    </div>
                  ` : ''}

                  <div>
                    <label class="block text-sm text-[var(--text-secondary)] mb-2">Contest Duration</label>
                    <div class="grid grid-cols-2 gap-3">
                      <div>
                        <label class="block text-xs text-[var(--text-muted)] mb-1">Hours</label>
                        <input type="number" id="durationHours" value="${state.durationHours}" min="0" max="720" class="input-modern" />
                      </div>
                      <div>
                        <label class="block text-xs text-[var(--text-muted)] mb-1">Minutes</label>
                        <input type="number" id="durationMinutes" value="${state.durationMinutes}" min="0" max="59" class="input-modern" />
                      </div>
                    </div>
                    ${state.seasonEndTime ? (() => {
                      const seasonCutoffMs = (state.seasonEndTime * 1000) - (5 * 60 * 1000);
                      const contestStartMs = state.startMode === 'scheduled' && state.startDate
                        ? new Date(state.startDate).getTime()
                        : Date.now();
                      const maxDurationMs = seasonCutoffMs - contestStartMs;
                      const maxDurationMins = Math.floor(maxDurationMs / (60 * 1000));
                      const maxHours = Math.floor(maxDurationMins / 60);
                      const maxMins = maxDurationMins % 60;
                      const seasonEndDate = new Date(state.seasonEndTime * 1000);

                      if (maxDurationMins <= 0) {
                        return `<div class="text-xs text-[var(--warning)] mt-2">Season ends ${seasonEndDate.toLocaleDateString()}. New contests unavailable.</div>`;
                      } else if (maxDurationMins < 60 * 24) {
                        return `<div class="text-xs text-[var(--text-muted)] mt-2">Season ends ${seasonEndDate.toLocaleDateString()} - Max duration: ${maxHours}h ${maxMins}m</div>`;
                      }
                      return '';
                    })() : ''}
                  </div>

                  ${state.startMode === 'scheduled' && state.startDate && state.durationHours !== '' && state.durationMinutes !== '' ? `
                    <div class="p-3 bg-[var(--bg-secondary)] rounded-xl text-sm">
                      <div class="text-[var(--text-muted)] mb-1">Timeline</div>
                      <div class="text-[var(--text-primary)]">
                        Starts: ${new Date(state.startDate).toLocaleString()}<br/>
                        Duration: ${state.durationHours}h ${state.durationMinutes}m<br/>
                        Ends: ${(() => {
                          const start = new Date(state.startDate);
                          const hours = parseInt(state.durationHours) || 0;
                          const minutes = parseInt(state.durationMinutes) || 0;
                          const end = new Date(start.getTime() + (hours * 60 + minutes) * 60 * 1000);
                          return end.toLocaleString();
                        })()}
                      </div>
                    </div>
                  ` : state.startMode === 'now' && state.durationHours !== '' && state.durationMinutes !== '' ? `
                    <div class="p-3 bg-[var(--bg-secondary)] rounded-xl text-sm">
                      <div class="text-[var(--text-muted)] mb-1">Timeline</div>
                      <div class="text-[var(--text-primary)]">
                        Starts immediately â€¢ Duration: ${state.durationHours}h ${state.durationMinutes}m
                      </div>
                    </div>
                  ` : ''}
                </div>

                <div class="divider"></div>

                <!-- Prize Settings -->
                <div class="space-y-4">
                  <h3 class="text-sm font-medium text-[var(--accent-light)] uppercase tracking-wider">Prize</h3>

                  <!-- Prize Type Toggle -->
                  <div class="flex gap-2">
                    <button onclick="state.prizeType = 'token'; render();" class="flex-1 py-3 px-4 rounded-xl text-sm font-medium transition-all ${state.prizeType === 'token' ? 'bg-[var(--accent)] text-white' : 'bg-[var(--bg-secondary)] text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)]'}">
                      Token
                    </button>
                    <button onclick="state.prizeType = 'nft'; render();" class="flex-1 py-3 px-4 rounded-xl text-sm font-medium transition-all ${state.prizeType === 'nft' ? 'bg-[var(--accent)] text-white' : 'bg-[var(--bg-secondary)] text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)]'}">
                      NFT
                    </button>
                  </div>

                  ${state.prizeType === 'token' ? `
                    <!-- Token Prize -->
                    <div class="relative">
                      <label class="block text-sm text-[var(--text-secondary)] mb-2">Search Token</label>
                      <input type="text" id="prizeTokenSearch" value="${state.prizeTokenSearch}" placeholder="USDC, ETH, NEYNARTODES..." class="input-modern" />
                      ${state.showPrizeTokenSuggestions ? `
                        <div class="absolute z-10 w-full mt-1 bg-[var(--bg-secondary)] border border-[var(--border-light)] rounded-xl shadow-lg max-h-64 overflow-y-auto">
                          ${searchTokens(state.prizeTokenSearch).map((token, idx) => `
                            <button onclick="selectPrizeToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-[var(--bg-tertiary)] border-b border-[var(--border-subtle)] transition-colors flex items-center gap-3">
                              <img src="${token.image}" alt="${token.ticker}" class="w-8 h-8 rounded-full object-cover" onerror="this.src='https://via.placeholder.com/32/8b5cf6/ffffff?text=${token.ticker[0]}'" />
                              <div class="flex-1 min-w-0">
                                <div class="font-medium text-[var(--text-primary)]">${token.ticker}</div>
                                <div class="text-xs text-[var(--text-muted)] truncate">${token.name}</div>
                              </div>
                              <div class="text-right">
                                <div class="text-sm font-medium text-[var(--success)]">$${(token.mcap / 1000000).toFixed(1)}M</div>
                              </div>
                            </button>
                          `).join('')}
                        </div>
                      ` : ''}
                    </div>

                    ${state.prizeTokenAddress ? `
                      <div class="p-4 bg-[var(--bg-secondary)] rounded-xl flex items-center gap-3">
                        <img src="${state.prizeTokenImage}" alt="${state.prizeTokenTicker}" class="w-10 h-10 rounded-full object-cover" onerror="this.src='https://via.placeholder.com/40/8b5cf6/ffffff?text=${state.prizeTokenTicker[0]}'" />
                        <div class="flex-1">
                          <div class="text-xs text-[var(--success)] mb-0.5">Selected</div>
                          <div class="font-medium text-[var(--text-primary)]">${state.prizeTokenTicker}</div>
                        </div>
                      </div>
                    ` : ''}

                    <div>
                      <label class="block text-sm text-[var(--text-secondary)] mb-2">Prize Amount</label>
                      <input type="number" id="prizeTokenAmount" value="${state.prizeTokenAmount}" placeholder="1000" class="input-modern" />
                    </div>
                  ` : `
                    <!-- NFT Prize -->
                    <div class="space-y-3">
                      <!-- Mode Toggle -->
                      <div class="flex gap-2 mb-2">
                        <button onclick="state.nftPickerMode = 'picker'; render();" class="flex-1 py-2 px-3 text-sm rounded-lg transition-colors ${state.nftPickerMode === 'picker' ? 'bg-[var(--accent)] text-white' : 'bg-[var(--bg-tertiary)] text-[var(--text-secondary)] hover:text-[var(--text-primary)]'}">
                          My NFTs
                        </button>
                        <button onclick="state.nftPickerMode = 'manual'; render();" class="flex-1 py-2 px-3 text-sm rounded-lg transition-colors ${state.nftPickerMode === 'manual' ? 'bg-[var(--accent)] text-white' : 'bg-[var(--bg-tertiary)] text-[var(--text-secondary)] hover:text-[var(--text-primary)]'}">
                          Enter Manually
                        </button>
                      </div>

                      ${state.nftPickerMode === 'picker' ? `
                        <!-- NFT Picker Mode -->
                        <div class="p-4 bg-[var(--bg-secondary)] rounded-xl">
                          <div class="flex items-center justify-between mb-3">
                            <span class="text-sm font-medium text-[var(--text-primary)]">Select from your wallet</span>
                            <button onclick="fetchUserNfts()" class="text-xs px-3 py-1 rounded-lg bg-[var(--accent)] text-white hover:bg-[var(--accent-dark)] transition-colors flex items-center gap-1" ${state.loadingUserNfts ? 'disabled' : ''}>
                              ${state.loadingUserNfts ? '<span class="animate-spin">â³</span> Loading...' : 'ðŸ”„ Refresh'}
                            </button>
                          </div>

                          ${state.loadingUserNfts && state.userNfts.length === 0 ? `
                            <div class="text-center py-8">
                              <div class="animate-spin text-2xl mb-2">â³</div>
                              <div class="text-sm text-[var(--text-muted)]">Loading your NFTs...</div>
                            </div>
                          ` : state.userNfts.length === 0 ? `
                            <div class="text-center py-6 text-[var(--text-muted)]">
                              <div class="text-3xl mb-2">ðŸ–¼ï¸</div>
                              <div class="text-sm">No NFTs found in your wallet</div>
                              <button onclick="fetchUserNfts()" class="mt-3 text-xs px-4 py-2 rounded-lg bg-[var(--accent)] text-white hover:bg-[var(--accent-dark)] transition-colors">
                                Load NFTs
                              </button>
                            </div>
                          ` : `
                            <div class="grid grid-cols-3 gap-2 max-h-64 overflow-y-auto">
                              ${state.userNfts.map((nft, idx) => `
                                <button onclick="selectNftFromPicker(state.userNfts[${idx}])" class="p-2 rounded-lg bg-[var(--bg-tertiary)] hover:bg-[var(--accent)] hover:bg-opacity-20 transition-colors text-left group ${state.prizeNftAddress === nft.contractAddress && state.prizeNftTokenId === nft.tokenId ? 'ring-2 ring-[var(--accent)]' : ''}">
                                  <div class="aspect-square rounded-lg overflow-hidden mb-1 bg-[var(--bg-primary)]">
                                    ${nft.image ? `
                                      <img src="${proxyImage(nft.image)}" alt="${nft.name}" class="w-full h-full object-cover" onerror="this.parentElement.innerHTML='<div class=\\'flex items-center justify-center h-full text-2xl\\'>ðŸ–¼ï¸</div>'" />
                                    ` : `
                                      <div class="flex items-center justify-center h-full text-2xl">ðŸ–¼ï¸</div>
                                    `}
                                  </div>
                                  <div class="text-xs font-medium text-[var(--text-primary)] truncate">${nft.name}</div>
                                  <div class="text-xs text-[var(--text-muted)] truncate">${nft.collection}</div>
                                </button>
                              `).join('')}
                            </div>
                            ${state.nftPickerPageKey ? `
                              <button onclick="fetchUserNfts(true)" class="w-full mt-3 py-2 text-sm text-[var(--accent-light)] hover:text-[var(--accent)] transition-colors" ${state.loadingUserNfts ? 'disabled' : ''}>
                                ${state.loadingUserNfts ? 'Loading more...' : 'Load More NFTs'}
                              </button>
                            ` : ''}
                          `}
                        </div>
                      ` : `
                        <!-- Manual Entry Mode -->
                        <div>
                          <label class="block text-sm text-[var(--text-secondary)] mb-2">NFT Contract Address</label>
                          <input type="text" id="prizeNftAddress" value="${state.prizeNftAddress}" placeholder="0x..." class="input-modern" />
                        </div>
                        <div>
                          <label class="block text-sm text-[var(--text-secondary)] mb-2">Token ID</label>
                          <div class="flex gap-2">
                            <input type="text" id="prizeNftTokenId" value="${state.prizeNftTokenId}" placeholder="1" class="input-modern flex-1" />
                            <button onclick="loadNftMetadata()" class="btn-primary px-4 py-2 text-sm whitespace-nowrap" ${state.loadingNftMetadata ? 'disabled' : ''}>
                              ${state.loadingNftMetadata ? '<span class="animate-spin">...</span>' : 'Load NFT'}
                            </button>
                          </div>
                        </div>
                      `}

                      ${state.prizeNftImage ? `
                        <div class="p-4 bg-[var(--bg-secondary)] rounded-xl">
                          <div class="flex gap-4">
                            <img src="${proxyImage(state.prizeNftImage)}" alt="${state.prizeNftName}" class="w-24 h-24 rounded-xl object-cover" onerror="this.src='https://via.placeholder.com/96/8b5cf6/ffffff?text=NFT'" />
                            <div class="flex-1">
                              <div class="text-xs text-[var(--success)] mb-1">NFT Selected</div>
                              <div class="font-medium text-[var(--text-primary)] mb-1">${state.prizeNftName}</div>
                              <div class="text-xs text-[var(--text-muted)]">${state.prizeNftCollection}</div>
                              <div class="text-xs text-[var(--text-muted)] font-mono mt-1">#${state.prizeNftTokenId}</div>
                              <div class="mt-2">
                                <span class="tag tag-accent">${state.prizeNftType}</span>
                              </div>
                            </div>
                            <button onclick="state.prizeNftAddress=''; state.prizeNftTokenId=''; state.prizeNftImage=''; state.prizeNftName=''; state.prizeNftCollection=''; state.prizeNftType=''; state.nftApprovalStatus='none'; render();" class="text-[var(--text-muted)] hover:text-[var(--error)] transition-colors self-start" title="Clear selection">âœ•</button>
                          </div>
                        </div>
                      ` : state.nftPickerMode === 'manual' ? `
                        <div class="p-4 bg-[var(--bg-secondary)] rounded-xl text-center text-[var(--text-muted)] text-sm">
                          Enter contract address and token ID, then click "Load NFT" to preview
                        </div>
                      ` : ''}

                      ${state.prizeNftType === 'ERC1155' ? `
                        <div>
                          <label class="block text-sm text-[var(--text-secondary)] mb-2">Amount (ERC1155)</label>
                          <input type="number" id="prizeNftAmount" value="${state.prizeNftAmount}" placeholder="1" min="1" class="input-modern" />
                        </div>
                      ` : ''}

                      <!-- NFT Approval Step -->
                      ${state.prizeNftImage ? `
                        <div class="p-4 bg-[var(--bg-tertiary)] rounded-xl border ${state.nftApprovalStatus === 'approved' ? 'border-[var(--success)]' : 'border-[var(--warning)]'}">
                          <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium ${state.nftApprovalStatus === 'approved' ? 'text-[var(--success)]' : 'text-[var(--warning)]'}">
                              ${state.nftApprovalStatus === 'approved' ? 'NFT Approved' : state.nftApprovalStatus === 'pending' ? 'Approving...' : 'Step 1: Approve NFT'}
                            </span>
                            ${state.nftApprovalStatus === 'approved' ? '<span class="text-[var(--success)]">&#10003;</span>' : ''}
                          </div>
                          ${state.nftApprovalStatus !== 'approved' ? `
                            <p class="text-xs text-[var(--text-muted)] mb-3">
                              Before creating the contest, you must approve the escrow contract to transfer your NFT.
                            </p>
                            <button onclick="approveNftForEscrow()" class="btn-primary w-full py-2 text-sm ${state.nftApprovalStatus === 'pending' ? 'opacity-50 cursor-not-allowed' : ''}" ${state.nftApprovalStatus === 'pending' ? 'disabled' : ''}>
                              ${state.nftApprovalStatus === 'pending' ? 'Approving... Check Wallet' : 'Approve NFT for Escrow'}
                            </button>
                            ${state.nftApprovalTxHash ? `
                              <a href="https://basescan.org/tx/${state.nftApprovalTxHash}" target="_blank" class="block text-center text-xs text-[var(--accent-light)] mt-2 hover:underline">
                                View approval tx on BaseScan
                              </a>
                            ` : ''}
                          ` : `
                            <p class="text-xs text-[var(--success)]">
                              Escrow contract can transfer your NFT. You can now launch the contest.
                            </p>
                          `}
                        </div>
                      ` : ''}
                    </div>
                  `}
                </div>

                <div class="divider"></div>

                <!-- Contest Settings -->
                <div class="space-y-4">
                  <!-- Cast URL/Hash -->
                  <div class="p-4 bg-[var(--warning-glow)] rounded-xl border border-[var(--warning)] relative">
                    <div class="flex items-center justify-between mb-2">
                      <label class="text-sm font-medium text-[var(--warning)]">Contest Cast URL</label>
                      <button onclick="fetchRecentCasts()" class="text-xs px-3 py-1 rounded-lg bg-[var(--accent)] text-white hover:bg-[var(--accent-dark)] transition-colors flex items-center gap-1">
                        ${state.loadingRecentCasts ? '<span class="animate-spin">â³</span>' : 'ðŸ“‹'} My Recent Casts
                      </button>
                    </div>
                    <input type="text" id="castHash" value="${state.castHash}" placeholder="https://farcaster.id/username/0x1234abcd" class="input-modern" />

                    ${state.showRecentCasts ? `
                      <div class="absolute z-20 left-4 right-4 mt-2 bg-[var(--bg-secondary)] border border-[var(--border-light)] rounded-xl shadow-lg overflow-hidden">
                        <div class="flex items-center justify-between px-3 py-2 border-b border-[var(--border-subtle)]">
                          <span class="text-xs font-medium text-[var(--text-secondary)]">Select a cast</span>
                          <button onclick="state.showRecentCasts = false; render();" class="text-[var(--text-muted)] hover:text-[var(--text-primary)] text-lg">&times;</button>
                        </div>
                        ${state.recentCasts.length > 0 ? state.recentCasts.map(cast => `
                          <div class="p-3 border-b border-[var(--border-subtle)] hover:bg-[var(--bg-tertiary)] transition-colors">
                            <div class="flex items-start justify-between gap-2 mb-2">
                              <p class="text-sm text-[var(--text-primary)] flex-1">${cast.text || '(No text)'}</p>
                              <span class="text-xs text-[var(--text-muted)] whitespace-nowrap">${cast.timestamp}</span>
                            </div>
                            <div class="flex items-center gap-2">
                              <code class="text-xs text-[var(--accent-light)] bg-[var(--bg-tertiary)] px-2 py-1 rounded flex-1 truncate">${cast.hash}</code>
                              <button onclick="copyToClipboard('${cast.hash}')" class="text-xs px-2 py-1 rounded bg-[var(--bg-tertiary)] text-[var(--text-secondary)] hover:text-[var(--text-primary)] transition-colors" title="Copy hash">ðŸ“‹</button>
                              <button onclick="selectRecentCast('${cast.url}')" class="text-xs px-2 py-1 rounded bg-[var(--accent)] text-white hover:bg-[var(--accent-dark)] transition-colors">Use</button>
                            </div>
                          </div>
                        `).join('') : `
                          <div class="p-4 text-center text-[var(--text-muted)] text-sm">No recent casts found</div>
                        `}
                      </div>
                    ` : ''}

                    <p class="text-xs text-[var(--text-muted)] mt-2">Post your contest on Farcaster first, then paste the URL here</p>
                  </div>

                  <!-- Winner Count (for non-NFT prizes) -->
                  ${state.prizeType !== 'nft' ? `
                  <div class="p-3 bg-[var(--bg-tertiary)] rounded-xl border border-[var(--border-subtle)]">
                    <div class="flex items-center justify-between">
                      <div>
                        <label class="block text-sm font-medium text-[var(--text-primary)]">Number of Winners</label>
                        <p class="text-xs text-[var(--text-muted)]">Prize split equally among winners (1-5)</p>
                      </div>
                      <div class="flex items-center gap-2">
                        <button onclick="state.winnerCount = Math.max(1, state.winnerCount - 1); render();" class="w-8 h-8 rounded-lg bg-[var(--bg-secondary)] border border-[var(--border-light)] text-[var(--text-primary)] hover:bg-[var(--accent)] hover:text-white transition-colors font-bold">-</button>
                        <input type="number" id="winnerCount" value="${state.winnerCount}" min="1" max="5" class="w-16 text-center input-modern font-bold text-lg" />
                        <button onclick="state.winnerCount = Math.min(5, state.winnerCount + 1); render();" class="w-8 h-8 rounded-lg bg-[var(--bg-secondary)] border border-[var(--border-light)] text-[var(--text-primary)] hover:bg-[var(--accent)] hover:text-white transition-colors font-bold">+</button>
                      </div>
                    </div>
                  </div>
                  ` : ''}
                </div>

                <div class="divider"></div>

                <!-- Free Entries Toggle -->
                <div class="space-y-4">
                  <div class="p-4 bg-[var(--bg-secondary)] rounded-xl">
                    <div class="flex items-center justify-between">
                      <div>
                        <div class="flex items-center gap-2">
                          <h3 class="text-sm font-medium text-[var(--text-primary)]">Enable Free Entries</h3>
                          ${!state.freeEntriesEnabled ? '<span class="text-xs text-[var(--warning)]">(0.001 ETH)</span>' : ''}
                        </div>
                        <p class="text-xs text-[var(--text-secondary)] mt-1">
                          ${state.freeEntriesEnabled
                            ? 'Anyone can enter this contest'
                            : 'Only $NEYNARTODES holders can enter'}
                        </p>
                      </div>
                      <label for="freeEntriesToggle" class="flex items-center gap-2 cursor-pointer">
                        <div class="relative">
                          <input type="checkbox" id="freeEntriesToggle" ${state.freeEntriesEnabled ? 'checked' : ''} class="sr-only peer" />
                          <div class="w-11 h-6 bg-[var(--bg-tertiary)] peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-[var(--success)]"></div>
                        </div>
                      </label>
                    </div>
                  </div>
                </div>

                <div class="divider"></div>

                <!-- Winner Announcement -->
                <div class="space-y-3">
                  <h3 class="text-sm font-medium text-[var(--accent-light)] uppercase tracking-wider">Winner Message</h3>
                  <textarea id="customMessage" rows="2" placeholder="You just won our amazing contest!" class="input-modern resize-none">${state.customMessage}</textarea>
                </div>

                <!-- Pending Transaction -->
                ${state.pendingTx ? `
                  <div class="p-4 bg-[var(--warning-glow)] border border-[var(--warning)] rounded-xl">
                    <div class="flex items-center justify-center gap-2 text-[var(--warning)] font-medium">
                      <span class="animate-spin">â³</span>
                      <span>Transaction pending...</span>
                    </div>
                    <a href="https://basescan.org/tx/${state.pendingTx}" target="_blank" class="block text-center text-sm text-[var(--accent-light)] mt-2 hover:underline">
                      View on BaseScan
                    </a>
                  </div>
                ` : ''}

                <!-- Launch Button -->
                ${(() => {
                  // Check if NFT contest needs approval first
                  const isNftContest = state.prizeType === 'nft';
                  const nftNeedsApproval = isNftContest && state.prizeNftImage && state.nftApprovalStatus !== 'approved';
                  const isDisabled = state.pendingTx || nftNeedsApproval;

                  return `
                    <button id="launchButton" class="btn-primary w-full py-4 text-lg font-semibold ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}" ${isDisabled ? 'disabled' : ''}>
                      ${state.pendingTx ? 'Launching...' : nftNeedsApproval ? 'Approve NFT First' : 'Launch Contest'}
                    </button>
                    ${nftNeedsApproval ? `
                      <p class="text-center text-sm text-[var(--warning)] mt-2">
                        Please approve your NFT above before launching
                      </p>
                    ` : ''}
                  `;
                })()}
                <p id="launchStatus" class="text-center text-sm text-[var(--accent-light)] mt-2"></p>
                <p class="text-center text-xs text-[var(--text-muted)]">
                  Prize will be locked in escrow
                </p>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // ===== DROPDOWN HELPERS =====
    function updatePrizeTokenDropdown() {
      const container = document.getElementById('prizeTokenSearch')?.parentElement;
      if (!container) return;

      // Remove old dropdown if exists
      const oldDropdown = container.querySelector('.absolute');
      if (oldDropdown) oldDropdown.remove();

      // Create new dropdown if needed
      if (state.showPrizeTokenSuggestions && state.prizeTokenSearch.length >= 2) {
        const results = searchTokens(state.prizeTokenSearch);
        const dropdown = document.createElement('div');
        dropdown.className = 'absolute z-10 w-full mt-1 bg-[var(--bg-secondary)] border border-[var(--border-light)] rounded-xl shadow-2xl max-h-80 overflow-y-auto';
        dropdown.style.top = '100%';
        dropdown.style.left = '0';

        // Show loading state if searching DexScreener
        if (state.prizeTokenSearching) {
          dropdown.innerHTML = `
            <div class="p-4 text-center">
              <div class="flex items-center justify-center gap-2 text-[var(--text-muted)]">
                <span class="animate-spin">ðŸ”</span>
                <span>Searching DexScreener...</span>
              </div>
              ${results.length > 0 ? `
                <div class="mt-3 text-xs text-[var(--text-muted)]">Showing ${results.length} local result${results.length !== 1 ? 's' : ''}</div>
              ` : ''}
            </div>
            ${results.length > 0 ? results.map((token, idx) => `
              <button onclick="selectPrizeToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-[var(--bg-tertiary)] border-t border-[var(--border-subtle)] transition-colors flex items-center gap-3">
                <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-[var(--accent)]" onerror="this.src='https://via.placeholder.com/40/8b5cf6/ffffff?text=${token.ticker?.[0] || '?'}'" />
                <div class="flex-1">
                  <div class="font-semibold text-[var(--text-primary)]">${token.name} <span class="text-[var(--accent)]">(${token.ticker})</span></div>
                  <div class="text-xs text-[var(--text-muted)] font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
                </div>
                <div class="text-right">
                  <div class="text-xs text-[var(--text-muted)]">MCap</div>
                  <div class="text-sm font-bold text-[var(--success)]">$${(token.mcap / 1000000).toFixed(1)}M</div>
                </div>
              </button>
            `).join('') : ''}
          `;
        } else if (results.length === 0 && lastDexScreenerResults.length === 0) {
          // Show "no results" message with option to use custom address
          dropdown.innerHTML = `
            <div class="p-4 text-center">
              <div class="text-[var(--text-muted)] mb-2">No tokens found for "${state.prizeTokenSearch}"</div>
              <div class="text-xs text-[var(--text-muted)] mb-3">
                Try searching by contract address, or add a custom token.
              </div>
              <button onclick="showCustomPrizeToken()" class="px-4 py-2 bg-[var(--accent)] text-white rounded-lg hover:opacity-90 transition-colors text-sm font-semibold">
                + Add Custom Token
              </button>
            </div>
          `;
        } else {
          // Combine local results with DexScreener results
          const allResults = [...results];
          const existingAddresses = new Set(results.map(t => t.address.toLowerCase()));
          lastDexScreenerResults.forEach(t => {
            if (!existingAddresses.has(t.address.toLowerCase())) {
              allResults.push(t);
            }
          });

          dropdown.innerHTML = allResults.map((token, idx) => `
            <button onclick="selectPrizeTokenByAddress('${token.address}')" class="w-full text-left px-4 py-3 hover:bg-[var(--bg-tertiary)] border-b border-[var(--border-subtle)] transition-colors flex items-center gap-3">
              <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-[var(--accent)]" onerror="this.src='https://via.placeholder.com/40/8b5cf6/ffffff?text=${token.ticker?.[0] || '?'}'" />
              <div class="flex-1">
                <div class="font-semibold text-[var(--text-primary)]">${token.name} <span class="text-[var(--accent)]">(${token.ticker})</span></div>
                <div class="text-xs text-[var(--text-muted)] font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
                ${token.source === 'dexscreener' ? '<div class="text-xs text-[var(--success)]">via DexScreener</div>' : ''}
              </div>
              <div class="text-right">
                <div class="text-xs text-[var(--text-muted)]">MCap</div>
                <div class="text-sm font-bold text-[var(--success)]">$${(token.mcap / 1000000).toFixed(1)}M</div>
              </div>
            </button>
          `).join('') + `
            <button onclick="showCustomPrizeToken()" class="w-full text-left px-4 py-3 bg-[var(--bg-tertiary)] hover:bg-[var(--bg-secondary)] transition-colors border-t border-[var(--border-light)]">
              <div class="font-semibold text-[var(--accent)] text-center">+ Add Custom Token Address</div>
            </button>
          `;
        }

        container.appendChild(dropdown);
      }
    }

    function updateTokenDropdown() {
      const container = document.getElementById('tokenSearch')?.parentElement;
      if (!container) return;

      // Remove old dropdown if exists
      const oldDropdown = container.querySelector('.absolute');
      if (oldDropdown) oldDropdown.remove();

      // Create new dropdown if needed
      if (state.showTokenSuggestions && state.tokenSearch.length >= 2) {
        const results = searchTokens(state.tokenSearch);
        const dropdown = document.createElement('div');
        dropdown.className = 'absolute z-10 w-full mt-1 bg-white border-2 border-green-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto';
        dropdown.style.top = '100%';
        dropdown.style.left = '0';

        if (results.length === 0) {
          // Show "no results" message with option to use custom address
          dropdown.innerHTML = `
            <div class="p-4 text-center">
              <div class="text-gray-600 mb-2">No tokens found for "${state.tokenSearch}"</div>
              <div class="text-xs text-gray-500 mb-3">
                Token not listed? You can use a custom address below after closing this.
              </div>
              <button onclick="showCustomToken()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-semibold">
                âž• Use Custom Token Address
              </button>
            </div>
          `;
        } else {
          dropdown.innerHTML = results.map((token, idx) => `
            <button onclick="selectToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-green-50 border-b border-gray-100 transition-colors flex items-center gap-3">
              <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-green-200" onerror="this.src='https://via.placeholder.com/40/22c55e/ffffff?text=${token.ticker[0]}'" />
              <div class="flex-1">
                <div class="font-semibold text-gray-800">${token.name} <span class="text-green-600">(${token.ticker})</span></div>
                <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
              </div>
              <div class="text-right">
                <div class="text-xs text-gray-600">Market Cap</div>
                <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
              </div>
            </button>
          `).join('') + `
            <button onclick="showCustomToken()" class="w-full text-left px-4 py-3 bg-green-50 hover:bg-green-100 transition-colors border-t-2 border-green-200">
              <div class="font-semibold text-green-700 text-center">âž• Use Custom Token Address</div>
            </button>
          `;
        }

        container.appendChild(dropdown);
      }
    }

    // ===== EVENT LISTENERS =====
    function attachEventListeners() {
      // Splash audio - plays on first tap (Enter button)
      if (!state.isLoggedIn && !window.splashAudioSetup) {
        window.splashAudioSetup = true;
        console.log('Setting up splash audio click handler');

        const playOnClick = async (e) => {
          if (window.splashAudioPlayed) return;
          window.splashAudioPlayed = true;
          console.log('User clicked, attempting to play audio...');

          try {
            const audio = new Audio('/splash-sound.mp3');
            audio.volume = 0.5;

            // Log audio element state
            console.log('Audio element created, src:', audio.src);
            console.log('Audio canPlayType mp3:', audio.canPlayType('audio/mpeg'));

            audio.onerror = (err) => {
              console.log('Audio error event:', err, audio.error?.message || audio.error?.code);
            };

            await audio.play();
            console.log('Splash audio playing!');
          } catch (e) {
            console.log('Audio play error:', e.name, e.message);
          }
        };

        document.addEventListener('click', playOnClick, { once: true, capture: true });
      }

      // Login page
      const connectButton = document.getElementById('connectButton');
      if (connectButton) {
        connectButton.onclick = connectWallet;
      }

      // Buy token function - opens Warpcast wallet swap directly in-app
      window.openBuyToken = async () => {
        const tokenAddress = CONFIG.CONTRACTS.neynartodes;
        // CAIP-19 format: eip155:{chainId}/erc20:{tokenAddress}
        const buyTokenCaip19 = `eip155:${CONFIG.CHAIN_ID}/erc20:${tokenAddress}`;
        const sdk = window.FarcasterSDK;

        if (sdk && sdk.actions && sdk.actions.swapToken) {
          try {
            // Use native SDK swapToken action - opens swap form in-app
            await sdk.actions.swapToken({
              buyToken: buyTokenCaip19
            });
          } catch (e) {
            console.log('Swap error:', e);
            showToast(`$NEYNARTODES: ${tokenAddress}`, 'info', 8000);
          }
        } else {
          // SDK not available - show contract address
          showToast(`$NEYNARTODES Contract: ${tokenAddress}`, 'info', 8000);
        }
      };

      // Buy token button on splash page
      const buyTokenButton = document.getElementById('buyTokenButton');
      if (buyTokenButton) {
        buyTokenButton.onclick = window.openBuyToken;
      }

      // Open profile function - opens Warpcast profile using SDK
      window.openProfile = async (username) => {
        const url = `https://warpcast.com/${username}`;
        const sdk = window.FarcasterSDK;

        if (sdk && sdk.actions && sdk.actions.openUrl) {
          try {
            await sdk.actions.openUrl(url);
          } catch (e) {
            console.log('Open URL error:', e);
            window.open(url, '_blank');
          }
        } else {
          window.open(url, '_blank');
        }
      };

      // (Cast success button removed - compose modal opens automatically on contest creation)

      // View switching
      const viewCreate = document.getElementById('viewCreate');
      const viewHistory = document.getElementById('viewHistory');
      const viewLeaderboard = document.getElementById('viewLeaderboard');

      if (viewCreate) viewCreate.onclick = () => {
        state.currentView = 'create';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'create' });
        stopHistoryAutoRefresh();
        stopCountdownTimer();
        render();
      };
      if (viewHistory) viewHistory.onclick = () => {
        state.currentView = 'history';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'history' });
        stopCountdownTimer();
        // Refresh history when switching to this view (manual refresh via Refresh button also available)
        loadHistory();
      };
      if (viewLeaderboard) viewLeaderboard.onclick = async () => {
        state.currentView = 'leaderboard';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'leaderboard' });
        stopHistoryAutoRefresh();
        startCountdownTimer();
        render();

        // Lazy-load leaderboard data and votes if not already loaded
        if (!state.leaderboardLoaded) {
          loadLeaderboard().catch(e => console.error('Leaderboard load failed:', e));
        }

        // Lazy-load remaining votes if not already fetched
        if (state.votesRemaining === 10 && state.votesUsedToday === 0 && state.userAddress) {
          try {
            const votingManagerRead = new ethers.Contract(
              CONFIG.CONTRACTS.votingManager,
              ['function getRemainingVotes(address user) external view returns (uint256)'],
              rpcProvider
            );
            const remainingVotes = await votingManagerRead.getRemainingVotes(state.userAddress);
            state.votesRemaining = Number(remainingVotes);
            state.votesUsedToday = 10 - state.votesRemaining;
            console.log(`Lazy-loaded remaining votes: ${state.votesRemaining}`);
            render();
          } catch (e) {
            console.error('Failed to fetch remaining votes:', e);
          }
        }
      };

      // Active contests tab
      const viewActive = document.getElementById('viewActive');
      if (viewActive) viewActive.onclick = () => {
        state.currentView = 'active';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'active' });
        stopHistoryAutoRefresh();
        stopCountdownTimer();
        render();
      };

      // Suggestions tab
      const viewSuggestions = document.getElementById('viewSuggestions');
      if (viewSuggestions) viewSuggestions.onclick = () => {
        state.currentView = 'suggestions';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'suggestions' });
        stopHistoryAutoRefresh();
        stopCountdownTimer();
        // Load suggestions for DEV
        if (isDevWallet(state.userAddress)) {
          loadSuggestions();
        }
        render();
      };

      // Suggestions form handlers
      const suggestionInput = document.getElementById('suggestionInput');
      if (suggestionInput) {
        // Restore value from state (preserves text across renders)
        suggestionInput.value = state.suggestionText;
        // Update state on input but DON'T re-render (prevents keyboard closing on mobile)
        suggestionInput.oninput = (e) => {
          state.suggestionText = e.target.value;
          // Update character count without full re-render
          const charCount = document.querySelector('#suggestionInput + div .text-xs');
          if (charCount) charCount.textContent = `${e.target.value.length}/1000`;
          // Update button disabled state
          const submitBtn = document.getElementById('submitSuggestion');
          if (submitBtn) submitBtn.disabled = e.target.value.trim().length < 10;
        };
      }

      const submitSuggestion = document.getElementById('submitSuggestion');
      if (submitSuggestion) {
        submitSuggestion.onclick = () => submitAnonymousSuggestion();
      }

      const refreshSuggestions = document.getElementById('refreshSuggestions');
      if (refreshSuggestions) {
        refreshSuggestions.onclick = () => loadSuggestions();
      }

      // Create contest form
      const startNow = document.getElementById('startNow');
      const startScheduled = document.getElementById('startScheduled');
      if (startNow) startNow.onclick = () => { state.startMode = 'now'; render(); };
      if (startScheduled) startScheduled.onclick = () => { state.startMode = 'scheduled'; render(); };

      // Free Entries toggle handler - charges 0.001 ETH to enable
      const freeEntriesToggle = document.getElementById('freeEntriesToggle');
      if (freeEntriesToggle) {
        freeEntriesToggle.onchange = async (e) => {
          const wantsEnable = e.target.checked;

          // Disabling is always free
          if (!wantsEnable) {
            state.freeEntriesEnabled = false;
            console.log('Free entries: disabled');
            render();
            return;
          }

          // Dev wallet can enable freely
          if (isDevWallet(state.userAddress)) {
            state.freeEntriesEnabled = true;
            console.log('Free entries: enabled (dev mode)');
            render();
            return;
          }

          // Regular users must pay 0.001 ETH to enable
          const confirmed = confirm('ðŸ’° Enable Free Entries?\n\nThis allows anyone to enter (no token requirement).\n\nCost: 0.001 ETH\n\nProceed?');
          if (!confirmed) {
            e.target.checked = false; // Revert toggle
            return;
          }

          try {
            const ethProvider = window.activeEthProvider || window.ethereum;
            if (!ethProvider) {
              showToast('No wallet connected!', 'error');
              e.target.checked = false;
              return;
            }

            const fee = ethers.utils.parseEther('0.001');
            showToast('Sending 0.001 ETH fee... Confirm in wallet!', 'info');

            const txHash = await ethProvider.request({
              method: 'eth_sendTransaction',
              params: [{
                from: state.userAddress,
                to: CONFIG.CONTRACTS.treasury,
                value: '0x' + fee.toBigInt().toString(16)
              }]
            });

            showToast('Transaction submitted! Waiting for confirmation...', 'info', 10000);

            const provider = new ethers.providers.Web3Provider(ethProvider);
            const receipt = await provider.waitForTransaction(txHash, 1, 60000);

            if (receipt && receipt.status === 1) {
              state.freeEntriesEnabled = true;
              showToast('Free entries enabled! Anyone can now enter this contest.', 'success');
              render();
            } else {
              throw new Error('Transaction failed on-chain');
            }
          } catch (error) {
            console.error('Fee payment error:', error);
            showToast('Fee payment failed: ' + error.message, 'error');
            e.target.checked = false; // Revert toggle
          }
        };
      }

      const prizeTokenSearch = document.getElementById('prizeTokenSearch');
      if (prizeTokenSearch) {
        prizeTokenSearch.oninput = (e) => {
          state.prizeTokenSearch = e.target.value;
          state.showPrizeTokenSuggestions = e.target.value.length >= 2;
          // Clear previous DexScreener results
          lastDexScreenerResults = [];
          // Update dropdown immediately with local results
          updatePrizeTokenDropdown();
          // Trigger debounced DexScreener search if local results are insufficient
          if (e.target.value.length >= 2) {
            const localResults = searchTokens(e.target.value);
            const isAddress = e.target.value.startsWith('0x') && e.target.value.length >= 10;
            if (localResults.length < 3 || isAddress) {
              debouncedEnhancedSearch(e.target.value, 'prize');
            }
          }
        };
        prizeTokenSearch.onfocus = (e) => {
          if (e.target.value.length >= 2) {
            state.showPrizeTokenSuggestions = true;
            updatePrizeTokenDropdown();
          }
        };
      }

      // Form inputs
      const startDate = document.getElementById('startDate');
      const endDate = document.getElementById('endDate');
      const durationHours = document.getElementById('durationHours');
      const durationMinutes = document.getElementById('durationMinutes');
      const castHash = document.getElementById('castHash');
      const customMessage = document.getElementById('customMessage');
      const prizeTokenAmount = document.getElementById('prizeTokenAmount');

      if (startDate) startDate.onchange = (e) => { state.startDate = e.target.value; render(); };
      if (endDate) endDate.onchange = (e) => { state.endDate = e.target.value; };
      if (durationHours) {
        durationHours.oninput = (e) => {
          state.durationHours = e.target.value;
        };
        durationHours.onchange = (e) => {
          state.durationHours = e.target.value;
          render();
        };
        durationHours.onblur = () => { render(); };
      }
      if (durationMinutes) {
        durationMinutes.oninput = (e) => {
          state.durationMinutes = e.target.value;
        };
        durationMinutes.onchange = (e) => {
          state.durationMinutes = e.target.value;
          render();
        };
        durationMinutes.onblur = () => { render(); };
      }
      if (castHash) castHash.oninput = (e) => { state.castHash = e.target.value; };
      const winnerCountInput = document.getElementById('winnerCount');
      if (winnerCountInput) winnerCountInput.oninput = (e) => { state.winnerCount = Math.min(5, Math.max(1, parseInt(e.target.value) || 1)); };
      if (customMessage) customMessage.oninput = (e) => { state.customMessage = e.target.value; };
      if (prizeTokenAmount) prizeTokenAmount.oninput = (e) => { state.prizeTokenAmount = e.target.value; };

      // NFT Prize inputs
      const prizeNftAddress = document.getElementById('prizeNftAddress');
      const prizeNftTokenId = document.getElementById('prizeNftTokenId');
      const prizeNftAmount = document.getElementById('prizeNftAmount');
      if (prizeNftAddress) prizeNftAddress.oninput = (e) => { state.prizeNftAddress = e.target.value; };
      if (prizeNftTokenId) prizeNftTokenId.oninput = (e) => { state.prizeNftTokenId = e.target.value; };
      if (prizeNftAmount) prizeNftAmount.oninput = (e) => { state.prizeNftAmount = e.target.value; };

      const launchButton = document.getElementById('launchButton');
      if (launchButton) {
        launchButton.onclick = async () => {
          try {
            console.log('ðŸ”˜ Launch button clicked');

            // Show status in UI since alerts don't work in Warpcast
            const statusDiv = document.getElementById('launchStatus');
            if (statusDiv) statusDiv.textContent = 'Step 1: Launch clicked...';

          // Check if user is dev wallet (bypasses own cast check)
          const isDev = isDevWallet(state.userAddress);

          // Validate duration
          const hours = parseInt(state.durationHours) || 0;
          const minutes = parseInt(state.durationMinutes) || 0;
          const totalMinutes = hours * 60 + minutes;

          if (totalMinutes < 1) {
            showToast('Contest duration must be at least 1 minute!', 'error');
            return;
          }

          // NOTE: Season end restriction removed - unified ContestManager handles its own timing

          // Validate scheduled start date
          if (state.startMode === 'scheduled' && !state.startDate) {
            showToast('Please set contest start date!', 'error');
            return;
          }

          // Validate prize based on type (token or NFT)
          if (state.prizeType === 'nft') {
            if (!state.prizeNftAddress || !state.prizeNftTokenId) {
              showToast('Please enter NFT contract address and token ID!', 'error');
              return;
            }
            if (!state.prizeNftImage) {
              showToast('Could not load NFT metadata. Please verify the contract address and token ID.', 'error');
              return;
            }
          } else {
            if (!state.prizeTokenAddress || !state.prizeTokenAmount) {
              showToast('Please select a prize token and enter the amount!', 'error');
              return;
            }
          }

          // Cast hash is ALWAYS required
          if (!state.castHash) {
            showToast('Cast Required! Post your contest announcement on Warpcast first, then paste the URL.', 'warning');
            return;
          }

          // Extract and validate cast hash
          const extractedHash = extractCastHash(state.castHash);
          if (!extractedHash) {
            showToast('Invalid cast URL/hash format. Please enter a valid Warpcast or Farcaster URL.', 'error');
            return;
          }

          // Validate cast exists (pass raw input for short hash resolution from farcaster.xyz)
          if (statusDiv) statusDiv.textContent = 'Step 2: Validating cast...';
          const castValidation = await validateCast(extractedHash, state.castHash);
          if (!castValidation.valid) {
            if (statusDiv) statusDiv.textContent = 'âŒ Cast validation failed: ' + castValidation.error;
            return;
          }

          // Check if this is the user's own cast (required for leaderboard integrity)
          if (!castValidation.isOwnCast && !isDev) {
            if (statusDiv) statusDiv.textContent = 'âŒ Not your cast! Must be your own post.';
            return;
          }

          if (statusDiv) statusDiv.textContent = 'Step 3: Cast verified âœ“ Preparing transaction...';

          // Store the validated hash (use resolved full hash if available)
          state.castHash = castValidation.hash || extractedHash;

          // Volume requirement is optional - $20 trading volume gives bonus entry, not a requirement
          // No minimum validation needed since volume bonus is handled in finalization

          // Ensure token address defaults to NEYNARTODES if not set
          if (!state.tokenAddress) {
            state.tokenAddress = CONFIG.CONTRACTS.neynartodes;
            state.tokenTicker = 'NEYNARTODES';
          }

          // Calculate end time
          let startTime, endTime;
          if (state.startMode === 'scheduled') {
            startTime = new Date(state.startDate);
            endTime = new Date(startTime.getTime() + totalMinutes * 60 * 1000);
          } else {
            startTime = new Date();
            endTime = new Date(startTime.getTime() + totalMinutes * 60 * 1000);
          }

          // Add to upcoming contests
          const newContest = {
            id: Date.now(),
            contestId: null, // Will be set after on-chain tx
            host: state.userAddress,
            hostUser: state.userProfile ? {
              fid: state.userProfile.fid,
              username: state.userProfile.username,
              displayName: state.userProfile.displayName,
              pfpUrl: state.userProfile.pfpUrl
            } : null,
            prize: state.prizeType === 'token' ? `${state.prizeTokenAmount} ${state.prizeTokenTicker}` : `${state.prizeNftName || 'NFT'} #${state.prizeNftTokenId || '?'}`,
            startTime: startTime,
            endTime: endTime,
            duration: `${hours}h ${minutes}m`,
            // Token requirement: enabled unless free entries is on
            tokenEnabled: !state.freeEntriesEnabled,
            tokenRequirementSymbol: !state.freeEntriesEnabled ? 'NEYNARTODES' : null,
            status: 0, // Active
            participantCount: 0
          };

          // Launch contest on ContestEscrow contract
          // Contest is only added to state AFTER successful on-chain tx (inside launchContestOnChain)
          if (statusDiv) statusDiv.textContent = 'Step 4: Calling contract...';
          await launchContestOnChain(newContest, totalMinutes * 60);

          } catch (error) {
            console.error('âŒ Launch button error:', error);
            const statusDiv = document.getElementById('launchStatus');
            if (statusDiv) statusDiv.textContent = 'âŒ Error: ' + (error.message || error);
          }
        };
      }

      // Note: Document-level click listener for dropdown close is attached once in initDropdownCloseHandler()
    }

    // Close dropdowns when clicking outside - attached ONCE, not on every render
    let dropdownCloseHandlerAttached = false;
    function initDropdownCloseHandler() {
      if (dropdownCloseHandlerAttached) return;
      dropdownCloseHandlerAttached = true;

      document.addEventListener('click', (e) => {
        const prizeTokenSearch = document.getElementById('prizeTokenSearch');
        const tokenSearch = document.getElementById('tokenSearch');

        // Close prize token dropdown if clicking outside
        if (prizeTokenSearch && !prizeTokenSearch.parentElement.contains(e.target)) {
          state.showPrizeTokenSuggestions = false;
          updatePrizeTokenDropdown();
        }

        // Close tokenomics dropdown if clicking outside
        if (tokenSearch && !tokenSearch.parentElement.contains(e.target)) {
          state.showTokenSuggestions = false;
          updateTokenDropdown();
        }
      });
    }

    // ===== UNIFIED CONTEST MANAGER ABI (New System - M- and T- prefixes) =====
    const UNIFIED_CONTEST_MANAGER_ABI = [
      // Main contest creation (M- prefix)
      'function createContestETH(uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement, uint8 _winnerCount) external payable returns (uint256 contestId)',
      'function createContestERC20(address _prizeToken, uint256 _prizeAmount, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement, uint8 _winnerCount) external payable returns (uint256 contestId)',
      'function registerContest(uint256 depositId, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',

      // Test contest creation (T- prefix)
      'function createTestContestETH(uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement, uint8 _winnerCount) external payable returns (uint256 contestId)',
      'function createTestContestERC20(address _prizeToken, uint256 _prizeAmount, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement, uint8 _winnerCount) external payable returns (uint256 contestId)',
      'function registerTestContest(uint256 depositId, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',

      // NFT deposit functions
      'function withdrawDeposit(uint256 depositId) external',
      'function nftToDepositId(address nftContract, uint256 tokenId) external view returns (uint256)',
      'function getPendingDeposit(uint256 depositId) external view returns (address depositor, uint8 nftType, address nftContract, uint256 tokenId, uint256 amount, uint256 depositTime, bool claimed)',

      // View functions
      'function getContest(uint256 _contestId) external view returns (address host, uint8 contestType, uint8 status, string memory castId, uint256 endTime, address prizeToken, uint256 prizeAmount, uint8 winnerCount, address[] memory winners)',
      'function getTestContest(uint256 _contestId) external view returns (address host, uint8 contestType, uint8 status, string memory castId, uint256 endTime, address prizeToken, uint256 prizeAmount, uint8 winnerCount, address[] memory winners)',
      'function mainNextContestId() external view returns (uint256)',
      'function testNextContestId() external view returns (uint256)',
      'function canFinalize(uint256 _contestId) external view returns (bool)',

      // Config
      'function contestFee() external view returns (uint256)',
      'function customTokenFee() external view returns (uint256)',
      'function defaultToken() external view returns (address)',

      // Events
      'event ContestCreated(uint256 indexed contestId, address indexed host, uint8 contestType, uint256 endTime, string castId, bool isTest)',
      'event NFTDeposited(uint256 indexed depositId, address indexed depositor, address nftContract, uint256 tokenId, uint256 amount, uint8 nftType)',
      'event WinnersSelected(uint256 indexed contestId, address[] winners, uint256 prizePerWinner, bool isTest)'
    ];

    // ===== LEGACY ABIs (for reading historical contest data only) =====
    // ContestEscrow ABI (Legacy V1 - token contests 1-65)
    const CONTEST_ESCROW_ABI = [
      'function createContestETH(uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function createContestERC20(address _prizeToken, uint256 _prizeAmount, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function getContest(uint256 _contestId) external view returns (address host, address prizeToken, uint256 prizeAmount, uint256 startTime, uint256 endTime, string memory castId, address tokenRequirement, uint256 volumeRequirement, uint8 status, address winner)',
      'function customTokenFee() external view returns (uint256)',
      'function defaultToken() external view returns (address)',
      'event ContestCreated(uint256 indexed contestId, address indexed host, address prizeToken, uint256 prizeAmount, uint256 endTime, string castId)'
    ];

    const ERC20_ABI = [
      'function approve(address spender, uint256 amount) external returns (bool)',
      'function allowance(address owner, address spender) external view returns (uint256)',
      'function balanceOf(address account) external view returns (uint256)',
      'function decimals() external view returns (uint8)'
    ];

    const NFT_CONTEST_ESCROW_ABI = [
      // Legacy functions (may fail for restricted NFTs)
      'function createContestERC721(address _nftContract, uint256 _tokenId, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function createContestERC1155(address _nftContract, uint256 _tokenId, uint256 _amount, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      // V3 functions for two-step flow (user transfers NFT first, then registers)
      'function registerContest(uint256 depositId, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function withdrawDeposit(uint256 depositId) external',
      'function nftToDepositId(address nftContract, uint256 tokenId) external view returns (uint256)',
      'function getPendingDeposit(uint256 depositId) external view returns (address depositor, uint8 nftType, address nftContract, uint256 tokenId, uint256 amount, uint256 depositTime, bool claimed)',
      // Common functions
      'function contestFee() external view returns (uint256)',
      'function defaultToken() external view returns (address)',
      // Events
      'event NFTDeposited(uint256 indexed depositId, address indexed depositor, address nftContract, uint256 tokenId, uint256 amount, uint8 nftType)',
      'event NFTContestCreated(uint256 indexed contestId, address indexed host, uint8 nftType, address nftContract, uint256 tokenId, uint256 amount, uint256 endTime, string castId)'
    ];

    // ===== V2 CONTRACT ABIs =====

    // ContestManager V2 - Unified contest manager for all contest types
    const CONTEST_MANAGER_ABI = [
      // Create contests
      'function createContestETH(uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement, uint8 _winnerCount) external payable returns (uint256 contestId)',
      'function createContestERC20(address _prizeToken, uint256 _prizeAmount, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement, uint8 _winnerCount) external payable returns (uint256 contestId)',
      'function createContestBaseNFT(address _nftContract, uint256 _tokenId, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',

      // Read functions
      'function getContest(uint256 _contestId) external view returns (address host, uint8 contestType, uint8 status, string memory castId, uint256 endTime, address prizeToken, uint256 prizeAmount, uint8 winnerCount, address[] memory winners)',
      'function getWinners(uint256 _contestId) external view returns (address[] memory)',
      'function canFinalize(uint256 _contestId) external view returns (bool)',
      'function nextContestId() external view returns (uint256)',
      'function currentSeason() external view returns (uint256)',

      // Config
      'function customTokenFee() external view returns (uint256)',
      'function defaultToken() external view returns (address)',

      // Events
      'event ContestCreated(uint256 indexed contestId, address indexed host, uint8 contestType, uint256 endTime, string castId)',
      'event WinnersSelected(uint256 indexed contestId, address[] winners, uint256 prizePerWinner)'
    ];

    // BuyBurnHoldEarn - Distributes tokens for contest entry
    // Non-holder: buys 1M tokens, distributes 25% entrant, 25% burn, 35% treasury, 15% host
    // Holder: sends 150K from treasury to host
    const BUYBURNHOLDEARN_ABI = [
      'function buyAndDistribute(address entrant, address host) external payable',
      'function rewardHostForHolderEntry(address host) external',
      'function getQuote() external returns (uint256)',
      'function buyAmount() external view returns (uint256)',
      'function holderHostReward() external view returns (uint256)',
      'function getStats() external view returns (uint256 bought, uint256 burned, uint256 toEntrants, uint256 toTreasuryTotal, uint256 toHostsTotal, uint256 holderHostRewardsTotal)',
      'event BuyBurnHoldEarnExecuted(address indexed entrant, address indexed host, uint256 tokensBought, uint256 toEntrant, uint256 burned, uint256 toTreasury, uint256 toHost, uint256 ethSpent, uint256 timestamp)',
      'event HolderEntryReward(address indexed host, uint256 amount, uint256 timestamp)'
    ];

    // ERC721_ABI and ERC1155_ABI are defined at the top of the file near CONFIG

    // Launch contest on Unified ContestManager contract
    async function launchContestOnChain(contest, durationSeconds) {
      const statusDiv = document.getElementById('launchStatus');
      try {
        console.log('ðŸš€ launchContestOnChain() called');

        // Check if user is banned from creating contests
        if (CONFIG.BANNED_FIDS && CONFIG.BANNED_FIDS.includes(state.userFid)) {
          showToast('Your account has been suspended from creating contests.', 'error');
          if (statusDiv) statusDiv.textContent = 'âŒ Account suspended';
          return;
        }

        // Determine if we're in test mode (T- prefix) or main mode (M- prefix)
        const isTestMode = CONFIG.TEST_MODE;
        const contestPrefix = isTestMode ? CONFIG.TEST_PREFIX : CONFIG.MAIN_PREFIX;
        console.log(`   Mode: ${isTestMode ? 'TEST (T-)' : 'MAIN (M-)'}`);

        // Determine if this is an NFT contest (used for announcement text)
        const isNftContest = state.prizeType === 'nft';

        if (statusDiv) statusDiv.textContent = 'Step 5: Getting wallet provider...';

        // Use the stored provider (Farcaster or MetaMask)
        const ethProvider = window.activeEthProvider || window.ethereum;
        if (!ethProvider) {
          if (statusDiv) statusDiv.textContent = 'âŒ No wallet provider found!';
          return;
        }

        if (statusDiv) statusDiv.textContent = 'Step 6: Getting account from provider...';

        // For smart wallets, get address directly from provider first
        let signerAddress;
        try {
          const accounts = await ethProvider.request({ method: 'eth_accounts' });
          signerAddress = accounts[0];
          if (statusDiv) statusDiv.textContent = 'Step 6b: Got address: ' + signerAddress.slice(0,10) + '...';
        } catch (e) {
          if (statusDiv) statusDiv.textContent = 'Step 6b ERROR: ' + e.message;
          throw e;
        }

        // Check if user holds 100M NEYNARTODES to launch a contest
        if (statusDiv) statusDiv.textContent = 'Checking NEYNARTODES balance...';
        const HOLDER_REQUIREMENT = ethers.BigNumber.from('100000000000000000000000000'); // 100M tokens (18 decimals)
        const neynartodes = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          ['function balanceOf(address) view returns (uint256)'],
          rpcProvider
        );
        const holderBalance = await neynartodes.balanceOf(signerAddress);
        if (holderBalance.lt(HOLDER_REQUIREMENT)) {
          const balanceFormatted = parseFloat(ethers.utils.formatUnits(holderBalance, 18)).toLocaleString(undefined, { maximumFractionDigits: 0 });
          showToast(`You need 100M NEYNARTODES to launch a contest. You have ${balanceFormatted}.`, 'error');
          if (statusDiv) statusDiv.textContent = 'âŒ Insufficient NEYNARTODES balance';
          return;
        }
        console.log('   Holder check passed:', ethers.utils.formatUnits(holderBalance, 18), 'NEYNARTODES');

        if (statusDiv) statusDiv.textContent = 'Step 7: Creating ethers provider/signer...';
        const provider = new ethers.providers.Web3Provider(ethProvider);
        const signer = provider.getSigner(signerAddress);
        if (statusDiv) statusDiv.textContent = 'Step 7b: Signer ready for ' + signerAddress.slice(0,10) + '...';

        if (statusDiv) statusDiv.textContent = 'Step 7c: Creating contract...';

        // Use Unified ContestManager for all new contests
        const contestManagerRead = new ethers.Contract(
          CONFIG.CONTRACTS.contestManager,
          UNIFIED_CONTEST_MANAGER_ABI,
          rpcProvider
        );
        console.log('   ContestManager contract:', CONFIG.CONTRACTS.contestManager);

        if (statusDiv) statusDiv.textContent = 'Step 7d: Reading contract config...';

        // Get fees and default token from unified ContestManager
        const contestFee = await contestManagerRead.contestFee();
        const customTokenFee = await contestManagerRead.customTokenFee();
        const defaultToken = await contestManagerRead.defaultToken();
        console.log('   Contest fee:', ethers.utils.formatEther(contestFee), 'ETH');
        console.log('   Custom token fee:', ethers.utils.formatEther(customTokenFee), 'ETH');
        console.log('   Default token:', defaultToken);

        // Determine token requirement based on free entries toggle
        // If free entries enabled: no token requirement (zero address)
        // If free entries disabled: require NEYNARTODES (default token)
        const tokenRequirement = state.freeEntriesEnabled
          ? '0x0000000000000000000000000000000000000000'
          : defaultToken;
        const isCustomToken = false; // No custom tokens anymore
        console.log('   Token requirement:', tokenRequirement);
        console.log('   Free entries:', state.freeEntriesEnabled);

        // Volume requirement is always 0 - volume bonus is handled at finalization
        const volumeRequirement = ethers.BigNumber.from(0);
        console.log('   Volume requirement:', ethers.utils.formatEther(volumeRequirement));

        // Cast ID - validated cast hash from user input (REQUIRED)
        // No social requirements - users enter via the Enter button
        // Format: castHash|R0L0P0|imageUrl (image URL is optional, only for NFT)
        const requirementsCode = 'R0L0P0';
        let castId = `${state.castHash}|${requirementsCode}`;
        if (state.prizeType === 'nft' && state.prizeNftImage) {
          // Encode image URL (truncate if too long to fit in string storage)
          const imageUrl = state.prizeNftImage.slice(0, 200); // Limit to 200 chars
          castId = `${state.castHash}|${requirementsCode}|${imageUrl}`;
          console.log('   NFT image URL cached in castId');
        }
        console.log('   Cast ID to send:', castId);
        if (!state.castHash || !state.castHash.startsWith('0x')) {
          console.error('âŒ Invalid cast hash - empty or doesnt start with 0x');
          showToast('Invalid cast hash. Please start over and enter a valid cast URL/hash.', 'error');
          return;
        }

        // Minimum prize validation ($0.50 USD minimum for all token types)
        const MIN_PRIZE_USD = 0.50;
        const STABLECOIN_ADDRESSES = [
          '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913', // USDC on Base
          '0x50c5725949a6f0c72e6c4a641f24049a917db0cb', // DAI on Base
          '0xfde4c96c8593536e31f229ea8f37b2ada2699bb2', // USDT on Base
        ];
        const ETH_ADDRESSES = [
          '0x0000000000000000000000000000000000000000', // Native ETH
          '0x4200000000000000000000000000000000000006', // WETH on Base
        ];

        if (state.prizeType === 'token' && state.prizeTokenAddress) {
          const tokenAddr = state.prizeTokenAddress.toLowerCase();
          const prizeAmount = parseFloat(state.prizeTokenAmount);
          let prizeUSD = 0;

          if (statusDiv) statusDiv.textContent = 'Validating prize value...';

          if (STABLECOIN_ADDRESSES.includes(tokenAddr)) {
            // Stablecoins: 1:1 with USD
            prizeUSD = prizeAmount;
            console.log('   Stablecoin prize:', prizeUSD, 'USD');
          } else if (ETH_ADDRESSES.includes(tokenAddr) || state.prizeTokenTicker === 'ETH') {
            // ETH: Get price from Chainlink
            try {
              const chainlink = new ethers.Contract(
                '0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70', // Chainlink ETH/USD on Base
                ['function latestRoundData() view returns (uint80, int256, uint256, uint256, uint80)'],
                rpcProvider
              );
              const roundData = await chainlink.latestRoundData();
              const ethPriceUSD = Number(roundData[1]) / 1e8;
              prizeUSD = prizeAmount * ethPriceUSD;
              console.log('   ETH prize:', prizeAmount, 'ETH @', ethPriceUSD, '=', prizeUSD, 'USD');
            } catch (e) {
              console.error('Failed to get ETH price:', e.message);
              // Skip validation if price fetch fails
              prizeUSD = MIN_PRIZE_USD;
            }
          } else {
            // Other ERC20: Get price from DexScreener API
            try {
              const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${state.prizeTokenAddress}`);
              const data = await response.json();
              if (data.pairs && data.pairs.length > 0) {
                // Find Base chain pair, prefer highest liquidity
                const basePairs = data.pairs.filter(p => p.chainId === 'base');
                const pair = basePairs.length > 0 ? basePairs[0] : data.pairs[0];
                const tokenPriceUSD = parseFloat(pair.priceUsd) || 0;
                prizeUSD = prizeAmount * tokenPriceUSD;
                console.log('   ERC20 prize:', prizeAmount, state.prizeTokenTicker, '@', tokenPriceUSD, '=', prizeUSD, 'USD');
              } else {
                console.warn('No price data found for token:', state.prizeTokenAddress);
                // Skip validation if no price data
                prizeUSD = MIN_PRIZE_USD;
              }
            } catch (e) {
              console.error('Failed to get token price:', e.message);
              // Skip validation if price fetch fails
              prizeUSD = MIN_PRIZE_USD;
            }
          }

          if (prizeUSD < MIN_PRIZE_USD) {
            showToast(`Minimum prize is $${MIN_PRIZE_USD.toFixed(2)}. Your prize is worth ~$${prizeUSD.toFixed(2)}.`, 'error');
            if (statusDiv) statusDiv.textContent = 'âŒ Prize below minimum ($0.50)';
            return;
          }
          console.log('   Prize validation passed:', prizeUSD.toFixed(2), 'USD');
        }

        let tx;

        if (state.prizeType === 'token') {
          // Check if prize is ETH (address(0) or WETH)
          const isETHPrize = state.prizeTokenAddress.toLowerCase() === '0x0000000000000000000000000000000000000000' ||
                            state.prizeTokenAddress.toLowerCase() === '0x4200000000000000000000000000000000000006'; // WETH on Base

          console.log('   Prize type: token');
          console.log('   Is ETH prize:', isETHPrize);
          console.log('   Prize token ticker:', state.prizeTokenTicker);

          if (isETHPrize || state.prizeTokenTicker === 'ETH') {
            // ETH prize - call createContestETH or createTestContestETH
            // Sanitize prize amount
            const cleanPrize = parseFloat(state.prizeTokenAmount).toFixed(18).replace(/\.?0+$/, '');
            if (!cleanPrize || isNaN(parseFloat(cleanPrize))) {
              showToast('Invalid prize amount. Please enter a valid number.', 'error');
              return;
            }
            const prizeAmount = ethers.utils.parseEther(cleanPrize);
            // Test mode has no fees, main mode adds contest fee + optional custom token fee
            const totalFee = isTestMode ? ethers.BigNumber.from(0) : (isCustomToken ? contestFee.add(customTokenFee) : contestFee);
            const totalValue = prizeAmount.add(totalFee);

            // Use unified ContestManager for all contests
            const contractAddress = CONFIG.CONTRACTS.contestManager;
            const contractABI = UNIFIED_CONTEST_MANAGER_ABI;
            const winnerCount = Math.min(5, Math.max(1, parseInt(state.winnerCount) || 1));
            const functionName = isTestMode ? 'createTestContestETH' : 'createContestETH';

            console.log('ðŸ“ Calling ' + functionName + ' with:');
            console.log('   Test Mode:', isTestMode);
            console.log('   Contract:', contractAddress);
            console.log('   _duration:', durationSeconds);
            console.log('   _castId:', castId);
            console.log('   _tokenRequirement:', tokenRequirement);
            console.log('   _volumeRequirement:', volumeRequirement.toString());
            console.log('   _winnerCount:', winnerCount);
            console.log('   value (ETH):', ethers.utils.formatEther(totalValue));

            if (statusDiv) statusDiv.textContent = 'Step 8: Building transaction...';

            // Encode the function call
            const iface = new ethers.utils.Interface(contractABI);
            const txData = iface.encodeFunctionData(functionName, [durationSeconds, castId, tokenRequirement, volumeRequirement, winnerCount]);

            if (statusDiv) statusDiv.textContent = 'Step 8b: Sending transaction...';
            console.log('â³ Waiting for wallet confirmation...');

            // Try eth_sendTransaction first (smart wallets), fall back to ethers signer (EOA)
            try {
              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [{
                  from: signerAddress,
                  to: contractAddress,
                  value: '0x' + totalValue.toBigInt().toString(16),
                  data: txData
                }]
              });
              tx = { hash: txHash };
              if (statusDiv) statusDiv.textContent = 'Step 9: TX sent! Hash: ' + txHash.slice(0,15) + '...';
              console.log('âœ… Wallet confirmed (smart wallet)! TX:', txHash);
            } catch (txError) {
              // If eth_sendTransaction fails, try ethers.js signer (EOA wallets)
              if (txError.message?.includes('unsupported') || txError.message?.includes('not supported')) {
                console.log('Smart wallet method failed, trying EOA signer...');
                if (statusDiv) statusDiv.textContent = 'Step 8c: Trying EOA signer...';
                try {
                  const contractSigner = new ethers.Contract(contractAddress, contractABI, signer);
                  tx = isTestMode
                    ? await contractSigner.createTestContestETH(durationSeconds, castId, tokenRequirement, volumeRequirement, winnerCount, { value: totalValue })
                    : await contractSigner.createContestETH(durationSeconds, castId, tokenRequirement, volumeRequirement, winnerCount, { value: totalValue });
                  if (statusDiv) statusDiv.textContent = 'Step 9: TX sent! Hash: ' + tx.hash.slice(0,15) + '...';
                  console.log('âœ… Wallet confirmed (EOA)! TX:', tx.hash);
                } catch (eoaError) {
                  if (statusDiv) statusDiv.textContent = 'âŒ TX Error: ' + (eoaError.message || eoaError).slice(0, 50);
                  console.error('EOA TX Error:', eoaError);
                  throw eoaError;
                }
              } else {
                if (statusDiv) statusDiv.textContent = 'âŒ TX Error: ' + (txError.message || txError).slice(0, 50);
                console.error('TX Error:', txError);
                throw txError;
              }
            }
          } else {
            // ERC20 prize - need to approve then call createContestERC20
            if (statusDiv) statusDiv.textContent = 'Step 8: Preparing ERC20 prize...';

            // Get decimals using read-only provider
            const prizeTokenRead = new ethers.Contract(state.prizeTokenAddress, ERC20_ABI, rpcProvider);
            let decimals;
            try {
              decimals = await prizeTokenRead.decimals();
            } catch {
              decimals = 18; // Default to 18 decimals
            }

            // Sanitize prize amount - limit to token's decimal places
            const cleanPrize = parseFloat(state.prizeTokenAmount).toFixed(decimals).replace(/\.?0+$/, '');
            if (!cleanPrize || isNaN(parseFloat(cleanPrize))) {
              if (statusDiv) statusDiv.textContent = 'âŒ Invalid prize amount';
              return;
            }
            const prizeAmount = ethers.utils.parseUnits(cleanPrize, decimals);

            // Use unified ContestManager for approval
            const approvalContract = CONFIG.CONTRACTS.contestManager;

            // Check allowance using read-only provider
            if (statusDiv) statusDiv.textContent = 'Step 8b: Checking allowance...';
            const allowance = await prizeTokenRead.allowance(signerAddress, approvalContract);

            if (allowance.lt(prizeAmount)) {
              if (statusDiv) statusDiv.textContent = 'Step 8c: Approval needed - check wallet!';

              // Encode approve function call
              const approveIface = new ethers.utils.Interface(ERC20_ABI);
              const approveData = approveIface.encodeFunctionData('approve', [
                approvalContract,
                prizeAmount
              ]);

              // Try eth_sendTransaction first (smart wallets), fall back to ethers signer (EOA)
              try {
                await ethProvider.request({
                  method: 'eth_sendTransaction',
                  params: [{
                    from: signerAddress,
                    to: state.prizeTokenAddress,
                    data: approveData
                  }]
                });
              } catch (approveError) {
                // If eth_sendTransaction fails, try ethers.js signer (EOA wallets)
                if (approveError.message?.includes('unsupported') || approveError.message?.includes('not supported')) {
                  console.log('Smart wallet approve failed, trying EOA signer...');
                  const prizeToken = new ethers.Contract(state.prizeTokenAddress, ERC20_ABI, signer);
                  const approveTx = await prizeToken.approve(approvalContract, prizeAmount);
                  await approveTx.wait();
                } else {
                  if (statusDiv) statusDiv.textContent = 'âŒ Approve Error: ' + (approveError.message || approveError).slice(0, 50);
                  throw approveError;
                }
              }

              if (statusDiv) statusDiv.textContent = 'Step 8d: Waiting for approval confirmation...';

              // Wait for approval tx to be mined
              let approved = false;
              for (let i = 0; i < 60; i++) {
                await new Promise(r => setTimeout(r, 2000));
                const newAllowance = await prizeTokenRead.allowance(signerAddress, approvalContract);
                if (newAllowance.gte(prizeAmount)) {
                  approved = true;
                  break;
                }
              }
              if (!approved) {
                if (statusDiv) statusDiv.textContent = 'âŒ Approval not confirmed after 2 minutes';
                return;
              }
              if (statusDiv) statusDiv.textContent = 'Step 8e: Approval confirmed!';
            }

            // Test mode has no fees, main mode adds contest fee + optional custom token fee
            const ethValue = isTestMode ? ethers.BigNumber.from(0) : (isCustomToken ? contestFee.add(customTokenFee) : contestFee);

            // Use unified ContestManager for all contests
            const contractAddress = CONFIG.CONTRACTS.contestManager;
            const contractABI = UNIFIED_CONTEST_MANAGER_ABI;
            const winnerCount = Math.min(5, Math.max(1, parseInt(state.winnerCount) || 1));
            const functionName = isTestMode ? 'createTestContestERC20' : 'createContestERC20';

            console.log('ðŸ“ Calling ' + functionName + ' with:');
            console.log('   Test Mode:', isTestMode);
            console.log('   Contract:', contractAddress);
            console.log('   _prizeToken:', state.prizeTokenAddress);
            console.log('   _prizeAmount:', prizeAmount.toString());
            console.log('   _duration:', durationSeconds);
            console.log('   _castId:', castId);
            console.log('   _tokenRequirement:', tokenRequirement);
            console.log('   _volumeRequirement:', volumeRequirement.toString());
            console.log('   _winnerCount:', winnerCount);
            console.log('   value (ETH for fee):', ethers.utils.formatEther(ethValue));

            if (statusDiv) statusDiv.textContent = 'Step 9: Sending ERC20 contest tx... Check wallet!';

            // Encode function call
            const createIface = new ethers.utils.Interface(contractABI);
            const createData = createIface.encodeFunctionData(functionName, [state.prizeTokenAddress, prizeAmount, durationSeconds, castId, tokenRequirement, volumeRequirement, winnerCount]);

            // Try eth_sendTransaction first (smart wallets), fall back to ethers signer (EOA)
            try {
              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [{
                  from: signerAddress,
                  to: contractAddress,
                  value: ethValue.gt(0) ? '0x' + ethValue.toBigInt().toString(16) : '0x0',
                  data: createData
                }]
              });
              tx = { hash: txHash };
              if (statusDiv) statusDiv.textContent = 'Step 10: TX sent! Hash: ' + txHash.slice(0,15) + '...';
              console.log('âœ… Wallet confirmed! TX:', txHash);
            } catch (txError) {
              // If eth_sendTransaction fails with "unsupported", try ethers.js signer (EOA wallets)
              if (txError.message?.includes('unsupported') || txError.message?.includes('not supported')) {
                console.log('Smart wallet ' + functionName + ' failed, trying EOA signer...');
                if (statusDiv) statusDiv.textContent = 'Step 9b: Trying EOA signer...';
                const contractSigner = new ethers.Contract(contractAddress, contractABI, signer);
                tx = isTestMode
                  ? await contractSigner.createTestContestERC20(state.prizeTokenAddress, prizeAmount, durationSeconds, castId, tokenRequirement, volumeRequirement, winnerCount, { value: ethValue })
                  : await contractSigner.createContestERC20(state.prizeTokenAddress, prizeAmount, durationSeconds, castId, tokenRequirement, volumeRequirement, winnerCount, { value: ethValue });
                if (statusDiv) statusDiv.textContent = 'Step 10: TX sent! Hash: ' + tx.hash.slice(0,15) + '...';
                console.log('âœ… EOA wallet confirmed! TX:', tx.hash);
              } else {
                if (statusDiv) statusDiv.textContent = 'âŒ TX Error: ' + (txError.message || txError).slice(0, 50);
                console.error('TX Error:', txError);
                throw txError;
              }
            }
          }
        } else {
          // NFT prize - use Unified ContestManager with 2-step deposit flow
          // Approval should already be done via the separate "Approve NFT" button
          if (statusDiv) statusDiv.textContent = 'Step 8: Preparing NFT prize...';

          if (!state.prizeNftAddress || !state.prizeNftTokenId || !state.prizeNftType) {
            showToast('Please load NFT metadata first by clicking "Load NFT"', 'error');
            return;
          }

          // Verify approval status (should already be approved from separate step)
          if (state.nftApprovalStatus !== 'approved') {
            showToast('Please approve your NFT first using the "Approve NFT" button', 'error');
            return;
          }

          // Use BigInt for large token IDs (e.g., Basenames)
          const tokenId = state.prizeNftTokenId ? BigInt(state.prizeNftTokenId) : 0n;

          // Get contest fee - test mode has no fees
          const nftContestFee = isTestMode ? ethers.BigNumber.from(0) : contestFee;
          console.log('NFT Contest Fee:', ethers.utils.formatEther(nftContestFee), 'ETH');
          console.log('Test Mode:', isTestMode);

          if (state.prizeNftType === 'ERC721') {
            // ERC721 NFT - V3 uses two-step flow for restricted NFTs
            if (statusDiv) statusDiv.textContent = 'Step 8b: Verifying NFT ownership...';

            const nft721Read = new ethers.Contract(state.prizeNftAddress, ERC721_ABI, rpcProvider);
            let owner;
            try {
              owner = await nft721Read.ownerOf(tokenId);
              console.log('NFT Owner:', owner);
              console.log('Connected wallet:', signerAddress);
            } catch (ownerError) {
              console.error('Error checking NFT ownership:', ownerError);
              showToast('Could not verify NFT ownership. Check if token ID is correct.', 'error');
              if (statusDiv) statusDiv.textContent = 'Error: Could not read NFT owner';
              return;
            }

            if (owner.toLowerCase() !== signerAddress.toLowerCase()) {
              console.log('Ownership mismatch! NFT owned by:', owner, 'Connected wallet:', signerAddress);
              showToast(`NFT owned by ${owner.slice(0,6)}...${owner.slice(-4)}, but connected wallet is ${signerAddress.slice(0,6)}...${signerAddress.slice(-4)}`, 'error');
              if (statusDiv) statusDiv.textContent = 'Ownership mismatch - connect correct wallet';
              return;
            }

            console.log('NFT Contest params:', {
              nftContract: state.prizeNftAddress,
              tokenId: tokenId,
              duration: durationSeconds,
              castId: castId,
              volumeReq: volumeRequirement.toString(),
              fee: ethers.utils.formatEther(nftContestFee),
              signerAddress: signerAddress,
              isTestMode: isTestMode
            });

            // Two-Step Flow: Transfer NFT directly to ContestManager, then register contest
            // This works with NFTs that have transfer restrictions
            showToast('NFT Contest requires 2 transactions: Transfer + Register', 'info');
            if (statusDiv) statusDiv.textContent = 'TX 1 of 2: Transfer NFT to ContestManager... Check wallet!';

            // Step 1: User transfers NFT directly to ContestManager
            const nftIface = new ethers.utils.Interface(ERC721_ABI);
            const transferData = nftIface.encodeFunctionData('safeTransferFrom(address,address,uint256)', [
              signerAddress,
              CONFIG.CONTRACTS.contestManager,
              tokenId
            ]);

            console.log('Step 1: Transferring NFT directly to ContestManager...');
            console.log('From:', signerAddress);
            console.log('To:', CONFIG.CONTRACTS.contestManager);
            console.log('TokenId:', tokenId);

            const transferTxParams = {
              from: signerAddress,
              to: state.prizeNftAddress,
              data: transferData,
              gas: '0x493E0' // 300,000 gas for transfer (proxy NFTs + escrow onReceived can use ~200k)
            };

            let transferTxHash;
            try {
              transferTxHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [transferTxParams]
              });
              console.log('NFT Transfer TX sent:', transferTxHash);
              if (statusDiv) statusDiv.textContent = 'TX 1 of 2: Transfer sent! Confirming...';
            } catch (transferErr) {
              console.error('NFT transfer failed:', transferErr);
              showToast('NFT transfer failed: ' + (transferErr.message || transferErr), 'error');
              if (statusDiv) statusDiv.textContent = 'FAILED: ' + (transferErr.message || 'Transfer rejected');
              return;
            }

            // Wait for transfer to be mined
            if (statusDiv) statusDiv.textContent = 'TX 1 of 2: Waiting for blockchain confirmation...';
            let transferConfirmed = false;
            for (let i = 0; i < 60; i++) {
              try {
                const receipt = await rpcProvider.getTransactionReceipt(transferTxHash);
                if (receipt && receipt.blockNumber) {
                  if (receipt.status === 0) {
                    showToast('NFT transfer failed on-chain', 'error');
                    if (statusDiv) statusDiv.textContent = 'FAILED: NFT transfer reverted';
                    return;
                  }
                  console.log('NFT Transfer confirmed in block:', receipt.blockNumber);
                  transferConfirmed = true;
                  break;
                }
              } catch (e) { }
              await new Promise(r => setTimeout(r, 2000));
            }

            if (!transferConfirmed) {
              showToast('NFT transfer not confirmed in time. Check your wallet.', 'warning');
              if (statusDiv) statusDiv.textContent = 'WARNING: Transfer not confirmed yet';
              return;
            }

            // Step 2: Get the deposit ID from the ContestManager
            showToast('NFT transferred! Now registering contest...', 'success');
            if (statusDiv) statusDiv.textContent = 'TX 1 complete! Preparing TX 2...';
            await new Promise(r => setTimeout(r, 2000)); // Wait for state to update

            const depositId = await contestManagerRead.nftToDepositId(state.prizeNftAddress, tokenId);
            console.log('Deposit ID:', depositId.toString());

            if (depositId.eq(0)) {
              showToast('Deposit not found. NFT may not have been received properly.', 'error');
              if (statusDiv) statusDiv.textContent = 'FAILED: Deposit not found';
              return;
            }

            // Step 3: Register the contest (test or main)
            const registerFunctionName = isTestMode ? 'registerTestContest' : 'registerContest';
            if (statusDiv) statusDiv.textContent = 'TX 2 of 2: Register contest... Check wallet!';

            const registerIface = new ethers.utils.Interface(UNIFIED_CONTEST_MANAGER_ABI);
            const registerData = registerIface.encodeFunctionData(registerFunctionName, [
              depositId,
              durationSeconds,
              castId,
              tokenRequirement,
              volumeRequirement
            ]);

            const registerTxParams = {
              from: signerAddress,
              to: CONFIG.CONTRACTS.contestManager,
              data: registerData,
              gas: '0x7A120' // 500,000 gas
            };
            if (nftContestFee.gt(0)) {
              registerTxParams.value = nftContestFee.toHexString();
            }

            try {
              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [registerTxParams]
              });
              tx = { hash: txHash };
              if (statusDiv) statusDiv.textContent = 'TX 2 of 2: Registration sent! Confirming...';
            } catch (regError) {
              console.error('Contest registration failed:', regError);
              // If registration fails, user can withdraw their NFT
              showToast('Contest registration failed. Your NFT is safe - you can withdraw it.', 'error');
              if (statusDiv) statusDiv.textContent = 'FAILED: ' + (regError.message || 'Registration rejected');
              return;
            }

          } else if (state.prizeNftType === 'ERC1155') {
            // ERC1155 NFT - uses same 2-step flow as ERC721
            if (statusDiv) statusDiv.textContent = 'Step 8b: Checking NFT balance...';

            const nft1155Read = new ethers.Contract(state.prizeNftAddress, ERC1155_ABI, rpcProvider);
            const amount = parseInt(state.prizeNftAmount) || 1;
            let balance;
            try {
              balance = await nft1155Read.balanceOf(signerAddress, tokenId);
              console.log('ERC1155 Balance check - Wallet:', signerAddress, 'TokenId:', tokenId, 'Balance:', balance.toString());
            } catch (balanceError) {
              console.error('Error checking ERC1155 balance:', balanceError);
              showToast('Could not verify NFT balance. Check contract address and token ID.', 'error');
              if (statusDiv) statusDiv.textContent = 'Error: Could not read NFT balance';
              return;
            }

            if (balance.lt(amount)) {
              showToast(`Wallet ${signerAddress.slice(0,6)}...${signerAddress.slice(-4)} doesn't have enough (need ${amount}, have ${balance})`, 'error');
              if (statusDiv) statusDiv.textContent = 'Insufficient NFT balance';
              return;
            }

            // Verify approval is still valid (double check - should be done in separate step)
            if (statusDiv) statusDiv.textContent = 'Step 8c: Verifying approval...';
            const isApproved = await nft1155Read.isApprovedForAll(signerAddress, CONFIG.CONTRACTS.contestManager);
            if (!isApproved) {
              showToast('NFT approval expired. Please approve again.', 'error');
              state.nftApprovalStatus = 'none';
              render();
              return;
            }

            // ERC1155 also uses 2-step flow for unified contract
            showToast('NFT Contest requires 2 transactions: Transfer + Register', 'info');
            if (statusDiv) statusDiv.textContent = 'TX 1 of 2: Transfer NFT to ContestManager... Check wallet!';

            // Step 1: Transfer ERC1155 to ContestManager
            const erc1155Iface = new ethers.utils.Interface([
              'function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) external'
            ]);
            const transferData1155 = erc1155Iface.encodeFunctionData('safeTransferFrom', [
              signerAddress,
              CONFIG.CONTRACTS.contestManager,
              tokenId,
              amount,
              '0x' // empty data
            ]);

            const transferTxParams1155 = {
              from: signerAddress,
              to: state.prizeNftAddress,
              data: transferData1155,
              gas: '0x493E0' // 300,000 gas
            };

            let transferTxHash1155;
            try {
              transferTxHash1155 = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [transferTxParams1155]
              });
              console.log('ERC1155 Transfer TX sent:', transferTxHash1155);
              if (statusDiv) statusDiv.textContent = 'TX 1 of 2: Transfer sent! Confirming...';
            } catch (transferErr1155) {
              console.error('ERC1155 transfer failed:', transferErr1155);
              showToast('NFT transfer failed: ' + (transferErr1155.message || transferErr1155), 'error');
              if (statusDiv) statusDiv.textContent = 'FAILED: ' + (transferErr1155.message || 'Transfer rejected');
              return;
            }

            // Wait for transfer confirmation
            if (statusDiv) statusDiv.textContent = 'TX 1 of 2: Waiting for blockchain confirmation...';
            let transferConfirmed1155 = false;
            for (let i = 0; i < 60; i++) {
              try {
                const receipt1155 = await rpcProvider.getTransactionReceipt(transferTxHash1155);
                if (receipt1155 && receipt1155.blockNumber) {
                  if (receipt1155.status === 0) {
                    showToast('NFT transfer failed on-chain', 'error');
                    if (statusDiv) statusDiv.textContent = 'FAILED: NFT transfer reverted';
                    return;
                  }
                  console.log('ERC1155 Transfer confirmed in block:', receipt1155.blockNumber);
                  transferConfirmed1155 = true;
                  break;
                }
              } catch (e) { }
              await new Promise(r => setTimeout(r, 2000));
            }

            if (!transferConfirmed1155) {
              showToast('NFT transfer not confirmed in time. Check your wallet.', 'warning');
              if (statusDiv) statusDiv.textContent = 'WARNING: Transfer not confirmed yet';
              return;
            }

            // Step 2: Get deposit ID and register contest
            showToast('NFT transferred! Now registering contest...', 'success');
            if (statusDiv) statusDiv.textContent = 'TX 1 complete! Preparing TX 2...';
            await new Promise(r => setTimeout(r, 2000));

            const depositId1155 = await contestManagerRead.nftToDepositId(state.prizeNftAddress, tokenId);
            console.log('Deposit ID:', depositId1155.toString());

            if (depositId1155.eq(0)) {
              showToast('Deposit not found. NFT may not have been received properly.', 'error');
              if (statusDiv) statusDiv.textContent = 'FAILED: Deposit not found';
              return;
            }

            // Step 3: Register the contest (test or main)
            const registerFunctionName1155 = isTestMode ? 'registerTestContest' : 'registerContest';
            if (statusDiv) statusDiv.textContent = 'TX 2 of 2: Register contest... Check wallet!';

            const registerIface1155 = new ethers.utils.Interface(UNIFIED_CONTEST_MANAGER_ABI);
            const registerData1155 = registerIface1155.encodeFunctionData(registerFunctionName1155, [
              depositId1155,
              durationSeconds,
              castId,
              tokenRequirement,
              volumeRequirement
            ]);

            const registerTxParams1155 = {
              from: signerAddress,
              to: CONFIG.CONTRACTS.contestManager,
              data: registerData1155,
              gas: '0x7A120' // 500,000 gas
            };
            if (nftContestFee.gt(0)) {
              registerTxParams1155.value = nftContestFee.toHexString();
            }

            try {
              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [registerTxParams1155]
              });
              tx = { hash: txHash };
              if (statusDiv) statusDiv.textContent = 'TX 2 of 2: Registration sent! Confirming...';
            } catch (regError1155) {
              console.error('ERC1155 Contest registration failed:', regError1155);
              showToast('Contest registration failed. Your NFT is safe - you can withdraw it.', 'error');
              if (statusDiv) statusDiv.textContent = 'FAILED: ' + (regError1155.message || 'Registration rejected');
              return;
            }

          } else {
            showToast('Unknown NFT type. Please reload the NFT.', 'error');
            return;
          }
        }

        console.log('ðŸ“¤ Transaction submitted:', tx.hash);

        // Show persistent notification while waiting
        const txUrl = `https://basescan.org/tx/${tx.hash}`;
        state.pendingTx = tx.hash;
        if (statusDiv) statusDiv.textContent = 'Waiting for confirmation...';

        // Wait for transaction receipt using read provider (since tx.wait() doesn't work with raw hashes)
        let receipt = null;
        for (let i = 0; i < 60; i++) {
          await new Promise(r => setTimeout(r, 2000));
          receipt = await rpcProvider.getTransactionReceipt(tx.hash);
          if (receipt) break;
        }

        if (!receipt) {
          if (statusDiv) statusDiv.textContent = 'â³ TX submitted but not confirmed yet. Check Basescan.';
          console.log('â³ TX not confirmed after 2 min, but was submitted');
        } else {
          console.log('âœ… Transaction confirmed:', receipt.transactionHash);
          console.log('ðŸ“œ Receipt logs:', receipt.logs);
        }

        // Parse contest ID from event
        let contestId = 'Unknown';

        if (receipt?.logs) {
          // Parse from raw logs using unified ContestManager interface
          const parseIface = new ethers.utils.Interface(UNIFIED_CONTEST_MANAGER_ABI);
          const eventName = 'ContestCreated';

          for (const log of receipt.logs) {
            try {
              const parsed = parseIface.parseLog(log);
              if (parsed.name === eventName) {
                // contestId from event is the numeric ID, we need to prefix it
                const numericId = parsed.args.contestId.toString();
                contestId = contestPrefix + numericId;
                console.log(`âœ… Found contestId via interface.parseLog (${eventName}, isTest=${isTestMode}):`, contestId);
                break;
              }
            } catch (e) {
              // Log doesn't match our event, skip
            }
          }

          // Method 2: Direct topic parsing as last resort
          if (contestId === 'Unknown' && receipt.logs.length > 0) {
            // New unified event signature: ContestCreated(uint256,address,uint8,uint256,string,bool)
            const unifiedContestCreatedTopic = ethers.utils.id('ContestCreated(uint256,address,uint8,uint256,string,bool)');

            const eventLog = receipt.logs.find(log =>
              log.topics[0] === unifiedContestCreatedTopic
            );
            if (eventLog && eventLog.topics[1]) {
              const numericId = ethers.BigNumber.from(eventLog.topics[1]).toString();
              contestId = contestPrefix + numericId;
              console.log('âœ… Found contestId from raw topic:', contestId);
            } else {
              console.log('âš ï¸ Could not find ContestCreated event');
              console.log('   Available logs:', receipt.logs.map(l => l.topics[0]));
            }
          }
        }

        // Clear pending tx
        state.pendingTx = null;

        // Store successful contest info
        const successInfo = {
          contestId,
          castHash: castId,
          txHash: receipt.transactionHash,
          timestamp: new Date().toISOString()
        };

        // Save to localStorage for persistence
        const launchedContests = JSON.parse(localStorage.getItem('neynartodes_launched_contests') || '[]');
        launchedContests.push(successInfo);
        localStorage.setItem('neynartodes_launched_contests', JSON.stringify(launchedContests));

        console.log('ðŸŽ‰ Contest created:', successInfo);

        // Track contest creation
        if (window.analytics?.track) {
          window.analytics.track('Contest Created', {
            contestId,
            prizeType: state.prizeType,
            token: state.tokenAddress,
            tokenTicker: state.tokenTicker,
            duration: state.durationHours,
            txHash: receipt?.transactionHash
          });
        }

        // Store custom message for winner announcement (if provided)
        const apiBaseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        if (state.customMessage && contestId !== 'Unknown') {
          try {
            await fetch(`${apiBaseUrl}/api/store?type=message`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contestId: contestId,
                message: state.customMessage
              })
            });
            console.log('âœ… Custom message stored for winner announcement');
          } catch (e) {
            console.log('âš ï¸ Could not store custom message:', e.message);
          }
        }

        // Store token price at contest creation (for fair volume calculations)
        if (contestId !== 'Unknown' && tokenRequirement !== ethers.constants.AddressZero) {
          try {
            await fetch(`${apiBaseUrl}/api/store?type=price`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contestId: contestId,
                tokenAddress: tokenRequirement
              })
            });
            console.log('âœ… Token price captured at contest creation');
          } catch (e) {
            console.log('âš ï¸ Could not store token price:', e.message);
          }
        }

        // Store prize value in USD at contest creation (for all-time prizes tracking)
        if (contestId !== 'Unknown') {
          try {
            if (state.prizeType === 'token') {
              // For token contests: store prize token price and amount
              const prizeTokenAddr = state.prizeTokenAddress || ethers.constants.AddressZero;
              const prizeAmt = parseFloat(state.prizeTokenAmount) || 0;

              await fetch(`${apiBaseUrl}/api/store?type=price`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  contestId: `prize_${contestId}`,
                  tokenAddress: prizeTokenAddr,
                  prizeAmount: prizeAmt
                })
              });
              console.log('âœ… Prize token value captured:', prizeAmt, state.prizeTokenTicker || 'tokens');
            } else if (state.prizeType === 'nft') {
              // For NFT contests: store complete metadata for cached access
              // Used by: Share button, entry display, notifications, active contest page, history tab
              const hours = parseInt(state.durationHours) || 0;
              const mins = parseInt(state.durationMinutes) || 0;
              const endTime = Date.now() + ((hours * 60 + mins) * 60 * 1000);

              await fetch(`${apiBaseUrl}/api/store-nft-contest`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  contestId: contestId,
                  contractAddress: state.prizeNftAddress || state.prizeNftContract || '',
                  tokenId: state.prizeNftTokenId || state.prizeNftId || '',
                  image: state.prizeNftImage || '',
                  name: state.prizeNftName || `NFT #${state.prizeNftTokenId || state.prizeNftId || '?'}`,
                  collection: state.prizeNftCollection || 'Unknown Collection',
                  description: state.prizeNftDescription || '',
                  attributes: state.prizeNftAttributes || [],
                  tokenType: state.prizeNftType || 'ERC721',
                  creatorFid: state.currentUser?.fid || null,
                  creatorUsername: state.currentUser?.username || '',
                  creatorPfp: state.currentUser?.pfpUrl || '',
                  entryFee: '0',
                  maxEntries: null,
                  endTime: endTime,
                  prizeType: 'nft',
                  floorPriceETH: state.prizeNftFloorPrice || null,
                  status: 'active'
                })
              });
              console.log('âœ… Complete NFT metadata cached:', state.prizeNftName, 'floor:', state.prizeNftFloorPrice || 'N/A', 'ETH');
            }
          } catch (e) {
            console.log('âš ï¸ Could not store prize value:', e.message);
          }
        }

        // Send new_contest notification to all subscribers
        try {
          const prizeDisplay = state.prizeType === 'nft'
            ? `${state.prizeNftName || 'NFT'} #${state.prizeNftTokenId || '?'}`
            : `${state.prizeTokenAmount || ''} ${state.prizeTokenTicker || 'ETH'}`;

          await fetch(`${apiBaseUrl}/api/send-notification`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer neynartodes-notif-secret'
            },
            body: JSON.stringify({
              type: 'new_contest',
              data: {
                contestId: contestId,
                prize: prizeDisplay.trim(),
                hostUsername: state.currentUser?.username || ''
              }
            })
          });
          console.log('ðŸ“¢ New contest notification sent');
        } catch (e) {
          console.log('âš ï¸ Could not send notification:', e.message);
        }

        // Prepare announcement cast text for compose modal
        // Build announcement cast text (isNftContest already defined above)
        const hours = parseInt(state.durationHours) || 0;
        const mins = parseInt(state.durationMinutes) || 0;
        const durationText = hours > 0 && mins > 0 ? `${hours}h ${mins}m`
          : hours > 0 ? `${hours} hour${hours > 1 ? 's' : ''}`
          : `${mins} minute${mins > 1 ? 's' : ''}`;

        // Prize line
        let prizeLine;
        if (isNftContest) {
          prizeLine = `ðŸ–¼ï¸ Prize: ${state.prizeNftName || 'NFT'} #${state.prizeNftTokenId || '?'}`;
        } else {
          prizeLine = `ðŸŽ Prize: ${state.prizeTokenAmount || '?'} $${state.prizeTokenTicker || 'ETH'}`;
        }

        // Winner count (V2 contests can have multiple winners)
        const winnerCount = parseInt(state.winnerCount) || 1;
        const winnersLine = winnerCount > 1 ? `ðŸ‘¥ ${winnerCount} Winners!` : '';

        // Build the cast text with mini app URL
        const miniAppUrl = `https://farcaster.xyz/miniapps/uaKwcOvUry8F/neynartodes?contestId=${contestId}&action=enter`;

        const announcementCastText = `ðŸ¦Ž I just launched Contest #${contestId} on $NEYNARTODES! ðŸ”¥

${prizeLine}
â±ï¸ Duration: ${durationText}${winnersLine ? '\n' + winnersLine : ''}

ðŸ‘‡ Enter now!
${miniAppUrl}`;

        // Build embeds - quote the original cast, add proxied NFT image if available
        const announcementEmbeds = [];
        const cleanCastHash = castId.split('|')[0]; // Strip encoded requirements
        announcementEmbeds.push(`https://warpcast.com/~/conversations/${cleanCastHash}`); // Quote original cast
        // Add NFT image via our proxy (avoids IPFS 403 errors)
        if (isNftContest && state.prizeNftImage) {
          const proxiedImage = `https://frame-opal-eight.vercel.app/api/image-proxy?url=${encodeURIComponent(state.prizeNftImage)}`;
          announcementEmbeds.push(proxiedImage);
        }

        // Open compose modal for host to review/edit before posting
        console.log('ðŸ“£ Opening compose modal for contest announcement...');
        const sdk = window.FarcasterSDK;
        if (sdk && sdk.actions && typeof sdk.actions.composeCast === 'function') {
          try {
            await sdk.actions.composeCast({
              text: announcementCastText,
              embeds: announcementEmbeds
            });
            console.log('âœ… Compose modal opened for announcement');
          } catch (e) {
            console.log('âš ï¸ Could not open compose modal:', e.message);
            // Fallback: open Warpcast compose URL with all embeds
            let warpcastUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(announcementCastText)}`;
            announcementEmbeds.forEach(embed => {
              warpcastUrl += `&embeds[]=${encodeURIComponent(embed)}`;
            });
            window.open(warpcastUrl, '_blank');
          }
        } else {
          // Fallback: open Warpcast compose URL with all embeds
          let warpcastUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(announcementCastText)}`;
          announcementEmbeds.forEach(embed => {
            warpcastUrl += `&embeds[]=${encodeURIComponent(embed)}`;
          });
          window.open(warpcastUrl, '_blank');
        }

        // Add contest to state ONLY after successful on-chain tx
        // Keep contestId as string (M-1, T-1 format) for API calls
        contest.onChainId = contestId;
        contest.contestId = contestId !== 'Unknown' ? contestId : null;
        state.upcomingContests.push(contest);
        state.upcomingContests.sort((a, b) => a.startTime - b.startTime);

        // Show success screen (don't use alert - Warpcast blocks it)
        // Save all contest details BEFORE form reset
        state.launchSuccess = {
          contestId,
          castHash: castId,
          txHash: tx.hash,
          txUrl,
          // Contest details
          prizeAmount: state.prizeTokenAmount,
          prizeTicker: state.prizeTokenTicker || 'ETH',
          durationHours: state.durationHours || '24',
          durationMinutes: state.durationMinutes || '0',
          winnerCount: parseInt(state.winnerCount) || 1,
          // NFT-specific fields
          isNft: state.prizeType === 'nft',
          nftImage: state.prizeType === 'nft' ? state.prizeNftImage : '',
          nftName: state.prizeType === 'nft' ? `${state.prizeNftName || 'NFT'} #${state.prizeNftTokenId || '?'}` : ''
        };

        // Reset form only after successful launch
        state.prizeTokenAddress = '';
        state.prizeTokenAmount = '';
        state.prizeTokenTicker = '';
        state.prizeTokenImage = '';
        state.prizeTokenSearch = '';
        state.castHash = '';
        state.customMessage = '';
        state.freeEntriesEnabled = false;

        render();
      } catch (error) {
        console.error('Contest launch error:', error);

        if (error.code === 4001) {
          showToast('Transaction rejected by user', 'error');
        } else if (error.message?.includes('Prize required')) {
          showToast('Prize amount required! Please enter an amount greater than 0.', 'error');
        } else if (error.message?.includes('Include custom token fee')) {
          showToast('Custom token fee required! Using a custom token costs 0.01 ETH.', 'error');
        } else if (error.message?.includes('Invalid duration')) {
          showToast('Invalid duration! Contest duration must be greater than 0.', 'error');
        } else {
          showToast('Contest launch failed: ' + (error.reason || error.message || 'Unknown error'), 'error');
        }
      }
    }

    // Feed the Neynartodes function - DEPRECATED (Clanker fees now go direct to Treasury)
    window.feedTheNeynartodes = async () => {
      showToast('This feature has been retired! Clanker fees now flow directly to Treasury.', 'info');
    };

    // Make functions globally accessible for inline onclick handlers
    window.voteForHost = voteForHost;

    // Custom prize token modal functions (for mini app compatibility - no prompt() dialogs)
    window.showCustomPrizeToken = () => {
      // Use modal-based approach instead of prompt() for Farcaster Frame compatibility
      showCustomPrizeTokenModal();
    };

    window.showCustomPrizeTokenModal = () => {
      try {
        state.showPrizeTokenSuggestions = false;
        state.showCustomPrizeTokenModal = true;
        updatePrizeTokenDropdown();
        renderCustomPrizeTokenModal();
      } catch (err) {
        console.error('showCustomPrizeTokenModal error:', err);
        showToast('Error opening custom token modal: ' + err.message, 'error');
      }
    };

    window.closeCustomPrizeTokenModal = () => {
      state.showCustomPrizeTokenModal = false;
      const modal = document.getElementById('customPrizeTokenModal');
      if (modal) modal.remove();
    };

    window.submitCustomPrizeToken = () => {
      const addressInput = document.getElementById('customPrizeTokenAddressInput');
      const tickerInput = document.getElementById('customPrizeTokenTickerInput');

      let address = (addressInput?.value || '').trim();
      const ticker = (tickerInput?.value || '').trim();

      if (!address) {
        showToast('Please enter a token address', 'error');
        return;
      }

      if (!address.startsWith('0x') || address.length !== 42) {
        showToast('Invalid address format. Must start with 0x and be 42 characters.', 'error');
        return;
      }

      if (!ticker) {
        showToast('Please enter a token ticker/symbol', 'error');
        return;
      }

      // Add custom token to database
      const customToken = {
        name: ticker.toUpperCase(),
        ticker: ticker.toUpperCase(),
        address: address.toLowerCase(),
        mcap: 1000000,
        supply: 1000000000,
        image: `https://via.placeholder.com/40/8b5cf6/ffffff?text=${ticker[0].toUpperCase()}`
      };

      // Save to localStorage with 1-year expiration
      saveCustomToken(customToken);
      tokenDatabase.push(customToken);

      // Auto-select the custom prize token
      state.prizeTokenAddress = customToken.address;
      state.prizeTokenTicker = customToken.ticker;
      state.prizeTokenImage = customToken.image;
      state.prizeTokenSearch = customToken.name;

      // Close modal and render
      state.showCustomPrizeTokenModal = false;
      const modal = document.getElementById('customPrizeTokenModal');
      if (modal) modal.remove();
      render();

      showToast(`${customToken.ticker} added as prize token!`, 'success');
    };

    function renderCustomPrizeTokenModal() {
      // Remove existing modal if any
      const existingModal = document.getElementById('customPrizeTokenModal');
      if (existingModal) existingModal.remove();

      if (!state.showCustomPrizeTokenModal) return;

      const modal = document.createElement('div');
      modal.id = 'customPrizeTokenModal';
      modal.className = 'fixed inset-0 z-50 flex items-center justify-center p-4';
      modal.innerHTML = `
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" onclick="closeCustomPrizeTokenModal()"></div>
        <div class="relative bg-[var(--bg-secondary)] rounded-2xl p-6 max-w-sm w-full shadow-2xl border border-[var(--border-light)]">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-bold text-[var(--text-primary)]">Add Custom Prize Token</h3>
            <button onclick="closeCustomPrizeTokenModal()" class="text-[var(--text-muted)] hover:text-[var(--text-primary)] text-xl">&times;</button>
          </div>

          <div class="space-y-4">
            <div>
              <label class="block text-sm text-[var(--text-secondary)] mb-2">Token Contract Address</label>
              <input type="text" id="customPrizeTokenAddressInput" placeholder="0x..." class="input-modern font-mono text-sm" />
              <p class="text-xs text-[var(--text-muted)] mt-1">The token's contract address on Base</p>
            </div>

            <div>
              <label class="block text-sm text-[var(--text-secondary)] mb-2">Token Symbol</label>
              <input type="text" id="customPrizeTokenTickerInput" placeholder="e.g., THINK" class="input-modern uppercase" maxlength="10" />
              <p class="text-xs text-[var(--text-muted)] mt-1">The token's ticker symbol</p>
            </div>
          </div>

          <div class="flex gap-3 mt-6">
            <button onclick="closeCustomPrizeTokenModal()" class="flex-1 px-4 py-3 border border-[var(--border-light)] rounded-xl text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)] transition-colors">
              Cancel
            </button>
            <button onclick="submitCustomPrizeToken()" class="flex-1 px-4 py-3 bg-[var(--accent)] text-white rounded-xl hover:bg-[var(--accent-dark)] transition-colors font-medium">
              Add Token
            </button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);

      // Focus the address input
      setTimeout(() => {
        document.getElementById('customPrizeTokenAddressInput')?.focus();
      }, 100);
    }

    // Show custom token modal (for mini app compatibility - no prompt() dialogs)
    window.showCustomTokenModal = () => {
      try {
        state.showTokenSuggestions = false;
        state.showCustomTokenModal = true;
        state.customTokenInput = '';
        state.customTokenTickerInput = '';
        updateTokenDropdown();
        renderCustomTokenModal();
      } catch (err) {
        console.error('showCustomTokenModal error:', err);
        showToast('Error opening custom token modal: ' + err.message, 'error');
      }
    };

    window.closeCustomTokenModal = () => {
      state.showCustomTokenModal = false;
      const modal = document.getElementById('customTokenModal');
      if (modal) modal.remove();
    };

    window.submitCustomToken = () => {
      const addressInput = document.getElementById('customTokenAddressInput');
      const tickerInput = document.getElementById('customTokenTickerInput');

      let address = (addressInput?.value || '').trim();
      const ticker = (tickerInput?.value || '').trim();

      if (!address) {
        showToast('Please enter a token address', 'error');
        return;
      }

      if (!address.startsWith('0x') || address.length !== 42) {
        showToast('Invalid address format. Must start with 0x and be 42 characters.', 'error');
        return;
      }

      if (!ticker) {
        showToast('Please enter a token ticker/symbol', 'error');
        return;
      }

      // Add custom token to database
      const customToken = {
        name: ticker.toUpperCase(),
        ticker: ticker.toUpperCase(),
        address: address.toLowerCase(),
        mcap: 1000000,
        supply: 1000000000,
        image: `https://via.placeholder.com/40/8b5cf6/ffffff?text=${ticker[0].toUpperCase()}`
      };

      // Save to localStorage with 1-year expiration
      saveCustomToken(customToken);
      tokenDatabase.push(customToken);

      // Auto-select the custom token
      state.tokenAddress = customToken.address;
      state.tokenTicker = customToken.ticker;
      state.tokenImage = customToken.image;
      state.tokenMcap = customToken.mcap;
      state.tokenSearch = customToken.name;

      // Close modal and render
      state.showCustomTokenModal = false;
      const modal = document.getElementById('customTokenModal');
      if (modal) modal.remove();
      render();

      showToast(`Custom token ${customToken.ticker} added!`, 'success');
    };

    function renderCustomTokenModal() {
      // Remove existing modal if any
      const existingModal = document.getElementById('customTokenModal');
      if (existingModal) existingModal.remove();

      if (!state.showCustomTokenModal) return;

      const modal = document.createElement('div');
      modal.id = 'customTokenModal';
      modal.className = 'fixed inset-0 z-50 flex items-center justify-center p-4';
      modal.innerHTML = `
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" onclick="closeCustomTokenModal()"></div>
        <div class="relative bg-[var(--bg-secondary)] rounded-2xl p-6 max-w-sm w-full shadow-2xl border border-[var(--border-light)]">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-bold text-[var(--text-primary)]">Add Custom Token</h3>
            <button onclick="closeCustomTokenModal()" class="text-[var(--text-muted)] hover:text-[var(--text-primary)] text-xl">&times;</button>
          </div>

          <div class="space-y-4">
            <div>
              <label class="block text-sm text-[var(--text-secondary)] mb-2">Token Contract Address</label>
              <input type="text" id="customTokenAddressInput" placeholder="0x..." class="input-modern font-mono text-sm" />
              <p class="text-xs text-[var(--text-muted)] mt-1">The token's contract address on Base</p>
            </div>

            <div>
              <label class="block text-sm text-[var(--text-secondary)] mb-2">Token Symbol</label>
              <input type="text" id="customTokenTickerInput" placeholder="e.g., BRETT" class="input-modern uppercase" maxlength="10" />
              <p class="text-xs text-[var(--text-muted)] mt-1">The token's ticker symbol</p>
            </div>
          </div>

          <div class="flex gap-3 mt-6">
            <button onclick="closeCustomTokenModal()" class="flex-1 px-4 py-3 border border-[var(--border-light)] rounded-xl text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)] transition-colors">
              Cancel
            </button>
            <button onclick="submitCustomToken()" class="flex-1 px-4 py-3 bg-[var(--accent)] text-white rounded-xl hover:bg-[var(--accent-dark)] transition-colors font-medium">
              Add Token
            </button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);

      // Focus the address input
      setTimeout(() => {
        document.getElementById('customTokenAddressInput')?.focus();
      }, 100);
    }

    window.showCustomToken = () => {
      // Redirect to modal-based approach
      showCustomTokenModal();
    };

    // Detect if user is on mobile device
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
             (window.innerWidth <= 768);
    }

    // Signer Approval Modal (QR for desktop, direct link for mobile)
    function renderSignerModal() {
      const existingModal = document.getElementById('signerModal');
      if (existingModal) existingModal.remove();

      if (!state.showSignerModal) return;

      const isMobile = isMobileDevice();

      const modal = document.createElement('div');
      modal.id = 'signerModal';
      modal.className = 'fixed inset-0 z-50 flex items-center justify-center p-4';
      modal.innerHTML = `
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" onclick="closeSignerModal()"></div>
        <div class="relative bg-[var(--bg-secondary)] rounded-2xl p-6 max-w-sm w-full shadow-2xl border border-[var(--border-light)]">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-bold text-[var(--text-primary)]">Authorize NEYNARtodes</h3>
            <button onclick="closeSignerModal()" class="text-[var(--text-muted)] hover:text-[var(--text-primary)] text-xl">&times;</button>
          </div>

          <div class="text-center space-y-4">
            ${isMobile ? `
              <!-- Mobile: Show button to open Farcaster app directly via deep link -->
              <p class="text-sm text-[var(--text-secondary)]">
                Tap the button below to authorize the app in Farcaster/Warpcast.
              </p>

              <a href="${state.signerApprovalUrl}"
                 onclick="sessionStorage.setItem('pendingSignerFid', '${state.userFid}')"
                 class="block w-full px-4 py-4 bg-[#8B5CF6] hover:bg-[#7C3AED] text-white font-semibold rounded-xl transition-colors text-center">
                Open in Farcaster App
              </a>

              <p class="text-xs text-[var(--text-muted)] mt-2">
                If the app doesn't open, copy this link:<br>
                <span class="text-[10px] break-all select-all">${state.signerApprovalUrl}</span>
              </p>
            ` : `
              <!-- Desktop: Show QR code to scan -->
              <p class="text-sm text-[var(--text-secondary)]">
                Scan this QR code with your phone to authorize the app in Warpcast.
              </p>

              <div class="flex justify-center">
                <div id="signerQRCode" class="rounded-lg bg-white p-3 inline-block"></div>
              </div>
            `}

            <div class="flex items-center justify-center gap-2 text-sm text-[var(--accent)]">
              <svg class="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <span>Waiting for approval...</span>
            </div>

            <p class="text-xs text-[var(--text-muted)]">
              This is a one-time authorization. Once approved, you can enter contests without needing to authorize again.
            </p>

            ${isMobile ? `
              <p class="text-xs text-[var(--text-muted)] mt-2">
                After approving in Farcaster, come back to this app to continue.
              </p>
            ` : `
              <p class="text-xs text-[var(--text-muted)] mt-2">
                After scanning, complete authorization in your Farcaster app.
              </p>
            `}
          </div>

          <button onclick="closeSignerModal()" class="w-full mt-4 px-4 py-3 border border-[var(--border-light)] rounded-xl text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)] transition-colors">
            Cancel
          </button>
        </div>
      `;
      document.body.appendChild(modal);

      // Generate QR code after modal is in DOM (only for desktop)
      if (!isMobile) {
        setTimeout(() => {
          const qrContainer = document.getElementById('signerQRCode');
          if (qrContainer && window.QRCode && state.signerApprovalUrl) {
            qrContainer.innerHTML = ''; // Clear any existing content
            try {
              new QRCode(qrContainer, {
                text: state.signerApprovalUrl,
                width: 256,
                height: 256,
                colorDark: '#000000',
                colorLight: '#ffffff',
                correctLevel: QRCode.CorrectLevel.L
              });
              console.log('QR code generated for:', state.signerApprovalUrl);
            } catch (error) {
              console.error('QR code error:', error);
              // Fallback: show the URL as text if QR code fails
              qrContainer.innerHTML = `<p class="text-xs text-red-500 break-all">${state.signerApprovalUrl}</p>`;
            }
          } else {
            console.log('QR code not generated: container=', !!qrContainer, 'QRCode=', !!window.QRCode, 'url=', !!state.signerApprovalUrl);
          }
        }, 100);
      }
    }

    window.closeSignerModal = () => {
      state.showSignerModal = false;
      state.signerApprovalUrl = null;
      renderSignerModal();
    };

    window.showCustomTokenLegacy = () => {
      state.showTokenSuggestions = false;
      updateTokenDropdown();

      let address = prompt('Enter the token contract address:\n\n(e.g., 0x532f27101965dd16442E59d40670FaF5eBB142E4)');
      if (!address) return;

      // Trim whitespace and normalize
      address = address.trim();

      if (!address.startsWith('0x') || address.length !== 42) {
        showToast(`Invalid address format. Must start with 0x and be 42 characters.`, 'error');
        return;
      }

      const ticker = prompt('Enter the token symbol/ticker:\n\n(e.g., BRETT, USDC, FIRKIT)');
      if (!ticker) return;

      const name = prompt('Enter the token name (optional):', ticker);

      // Add custom token to database
      const customToken = {
        name: name || ticker,
        ticker: ticker.toUpperCase(),
        address: address.toLowerCase(),
        mcap: 1000000,
        supply: 1000000000,
        image: `https://via.placeholder.com/40/22c55e/ffffff?text=${ticker[0]}`
      };

      // Save to localStorage with 1-year expiration
      saveCustomToken(customToken);

      tokenDatabase.push(customToken);

      // Auto-select the custom token
      state.tokenAddress = customToken.address;
      state.tokenTicker = customToken.ticker;
      state.tokenImage = customToken.image;
      state.tokenMcap = customToken.mcap;
      state.tokenSearch = customToken.name;
      render();

      // Show caps info
      const basePercent = customToken.mcap < 10000 ? 0.01 : customToken.mcap < 20000 ? 0.005 : customToken.mcap < 1000000 ? 0.0025 : customToken.mcap < 10000000 ? 0.001 : 0.0005;
      const multiplier = getBadgeMultiplier(state.userBadges);
      const maxPercent = basePercent * multiplier;
      const maxTokens = Math.floor(customToken.supply * maxPercent);

      showToast(`Custom token added! Market Cap: $${customToken.mcap.toLocaleString()}, Max: ${maxTokens.toLocaleString()} ${customToken.ticker}`, 'success');
    };

    window.selectPrizeToken = (idx) => {
      const results = searchTokens(state.prizeTokenSearch);
      if (results[idx]) {
        const token = results[idx];
        state.prizeTokenAddress = token.address;
        state.prizeTokenTicker = token.ticker;
        state.prizeTokenImage = token.image;
        state.prizeTokenSearch = token.name;
        state.showPrizeTokenSuggestions = false;
        render();
      }
    };

    // Select prize token by address (for DexScreener results)
    window.selectPrizeTokenByAddress = (address) => {
      // Search in local database first
      let token = tokenDatabase.find(t => t.address.toLowerCase() === address.toLowerCase());
      // If not found, check DexScreener results
      if (!token) {
        token = lastDexScreenerResults.find(t => t.address.toLowerCase() === address.toLowerCase());
      }
      if (token) {
        state.prizeTokenAddress = token.address;
        state.prizeTokenTicker = token.ticker;
        state.prizeTokenImage = token.image;
        state.prizeTokenSearch = token.name;
        state.showPrizeTokenSuggestions = false;
        // Clear DexScreener results
        lastDexScreenerResults = [];
        render();
      }
    };

    window.selectToken = (idx) => {
      const results = searchTokens(state.tokenSearch);
      if (results[idx]) {
        const token = results[idx];
        state.tokenAddress = token.address;
        state.tokenTicker = token.ticker;
        state.tokenImage = token.image;
        state.tokenMcap = token.mcap;
        state.tokenSearch = token.name;
        state.showTokenSuggestions = false;

        // Track token selection
        if (window.analytics?.track) {
          window.analytics.track('Token Selected', {
            token: token.address,
            ticker: token.ticker,
            mcap: token.mcap
          });
        }

        render();

        // Show info about caps
        const basePercent = token.mcap < 10000 ? 0.01 : token.mcap < 20000 ? 0.005 : token.mcap < 1000000 ? 0.0025 : token.mcap < 10000000 ? 0.001 : 0.0005;
        const multiplier = getBadgeMultiplier(state.userBadges);
        const maxPercent = basePercent * multiplier;
        const maxTokens = Math.floor(token.supply * maxPercent);

        showToast(`Token selected! Market Cap: $${token.mcap.toLocaleString()}, Max: ${maxTokens.toLocaleString()} ${token.ticker}`, 'success');
      }
    };

    // ===== INIT =====
    // Load token list from Base on startup
    fetchBaseTokens().catch(err => console.warn('Token list fetch failed:', err));

    // Attach document-level event handlers ONCE (not on every render)
    initDropdownCloseHandler();

    // Handle URL params for deep linking from notifications
    const urlParams = new URLSearchParams(window.location.search);
    const viewParam = urlParams.get('view');
    if (viewParam && ['active', 'create', 'leaderboard', 'suggestions'].includes(viewParam)) {
      state.currentView = viewParam;
      console.log('Deep link: navigating to', viewParam);
    }

    // Handle contestId + action params (from shared links)
    const contestIdParam = urlParams.get('contestId');
    const actionParam = urlParams.get('action');
    if (contestIdParam && actionParam === 'enter') {
      console.log('Deep link: auto-entering contest', contestIdParam);
      // Store for after render
      sessionStorage.setItem('pendingEnterContest', contestIdParam);
      // Also store for SDK module to set up primary button
      window.PendingContestEntry = contestIdParam;
    }

    // Clean up URL without reload
    if (urlParams.toString()) {
      window.history.replaceState({}, '', window.location.pathname);
    }

    // Initial render
    render();

    // Mark app as ready after a brief delay to ensure content is rendered
    function showAppContent() {
      if (state.isAppReady) return;
      state.isAppReady = true;

      const appLoading = document.getElementById('app-loading');
      const app = document.getElementById('app');

      if (appLoading) appLoading.classList.add('hidden');
      if (app) app.classList.add('ready');
    }

    // Show app after initial render is complete
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        showAppContent();
      });
    });

    // Check for pending contest entry (from shared link)
    const pendingContestId = sessionStorage.getItem('pendingEnterContest');
    if (pendingContestId) {
      sessionStorage.removeItem('pendingEnterContest');
      console.log('Auto-triggering entry for contest:', pendingContestId);
      // Find the Enter button for this contest and click it
      setTimeout(() => {
        const enterBtn = document.querySelector(`[data-action="enter-raffle"][data-contest-id="${pendingContestId}"]`);
        if (enterBtn) {
          enterBtn.click();
        } else {
          console.log('Contest not found, may need to load contests first');
        }
      }, 1000); // Wait for contests to load
    }

    // Check for pending signer approval (user returning from Warpcast)
    (async function checkPendingSigner() {
      const pendingFid = sessionStorage.getItem('pendingSignerFid');
      if (pendingFid) {
        console.log('Found pending signer for FID:', pendingFid);
        // Poll for signer approval
        let approved = false;
        for (let i = 0; i < 10; i++) {
          try {
            const response = await fetch(`/api/signer-status?fid=${pendingFid}`);
            const data = await response.json();
            if (data.approved) {
              console.log('Signer now approved!');
              approved = true;
              state.signerStatus = data;
              sessionStorage.removeItem('pendingSignerFid');
              showToast('Signer authorized! You can now enter raffles.', 'success');

              // Check if there was a pending contest entry
              const pendingContest = sessionStorage.getItem('pendingContestEntry');
              if (pendingContest) {
                sessionStorage.removeItem('pendingContestEntry');
                console.log('Resuming entry for contest:', pendingContest);
                // User will need to click Enter Raffle again, but signer is ready
              }
              break;
            }
          } catch (e) {
            console.error('Signer status check error:', e);
          }
          await new Promise(r => setTimeout(r, 1000));
        }
        if (!approved) {
          console.log('Signer not yet approved, user may need to complete authorization');
          sessionStorage.removeItem('pendingSignerFid');
        }
      }
    })();

    // Re-render when Farcaster SDK loads (it's async)
    window.addEventListener('farcaster-ready', () => {
      console.log('Farcaster SDK ready event received, re-rendering...');
      // Update notification status from SDK check
      state.notificationsEnabled = window.NotificationsEnabled === true;
      state.notificationsWereReset = window.NotificationsWereReset === true;
      render();
    });

    // Enable notifications using SDK
    window.enableNotifications = async function() {
      const sdk = window.FarcasterSDK;
      if (!sdk) {
        showToast('SDK not loaded', 'error');
        return;
      }

      try {
        showToast('Requesting notification permission...', 'info');
        // Use SDK to prompt for notifications
        const result = await sdk.actions.addFrame();
        console.log('addFrame result:', result);

        if (result?.notificationDetails?.token) {
          // Store the new token
          const context = await sdk.context;
          await fetch('/api/webhook', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              event: 'notifications_enabled',
              fid: context?.user?.fid,
              notificationDetails: {
                token: result.notificationDetails.token,
                url: result.notificationDetails.url,
              },
            }),
          });
          state.notificationsEnabled = true;
          state.notificationsWereReset = false;
          localStorage.setItem('neynartodes_notifs_enabled', 'true');
          showToast('Notifications enabled!', 'success');
          render();
        } else {
          showToast('Could not enable notifications', 'error');
        }
      } catch (e) {
        console.error('Enable notifications error:', e);
        showToast('Failed to enable notifications: ' + e.message, 'error');
      }
    };
  </script>
</body>
</html>
