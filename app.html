<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Danng Neynartodes!! - Season 0</title>

  <!-- Farcaster Mini App Embed -->
  <meta name="fc:frame" content='{"version":"1","imageUrl":"https://frame-opal-eight.vercel.app/api/image","button":{"title":"Launch NEYNARtodes","action":{"type":"launch_frame","name":"NEYNARtodes","url":"https://frame-opal-eight.vercel.app/app","splashImageUrl":"https://frame-opal-eight.vercel.app/api/image","splashBackgroundColor":"#667eea"}}}' />

  <!-- Open Graph -->
  <meta property="og:title" content="NEYNARtodes - Season 0 Beta" />
  <meta property="og:description" content="Create contests on Farcaster!" />
  <meta property="og:image" content="https://frame-opal-eight.vercel.app/api/image" />
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Farcaster Mini App SDK - official esm.sh CDN per docs -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    window.FarcasterSDK = sdk;
    await sdk.actions.ready();
    console.log('Farcaster Mini App ready');
  </script>
  <style>
    @keyframes bubble {
      0%, 100% { transform: translateY(0) scale(1); opacity: 0.5; }
      50% { transform: translateY(-20px) scale(1.1); opacity: 0.8; }
    }
    .bubble { animation: bubble 3s ease-in-out infinite; }
    body { font-family: system-ui, -apple-system, sans-serif; }
  </style>
</head>
<body>
  <div id="app"></div>

  <script>
    // DEBUG: Very first line
    alert('SCRIPT START');

    // ===== CONFIGURATION =====
    const CONFIG = {
      NEYNAR_API_KEY: 'AA2E0FC2-FDC0-466D-9EBA-4BCA968C9B1D',
      BASE_RPC_URL: 'https://mainnet.base.org',
      CONTRACTS: {
        prizeNFT: '0x82f5A8CEffce9419886Bb0644FA5D3FB8295Ab81',
        votingManager: '0xFF730AB8FaBfc432c513C57bE8ce377ac77eEc99',
        contestEscrow: '0x0A8EAf7de19268ceF2d2bA4F9000c60680cAde7A',
        treasury: '0xB5A1a3AAD5962dBF2B8DF3C5712d137c1640A176',
        neynartodes: '0x8de1622fe07f56cda2e2273e615a513f1d828b07'
      },
      SEASON_0_MIN_TOKENS: ethers.utils.parseEther('20000') // 20K tokens
    };

    // Dev wallets with unlimited privileges (no contest launch limit, no voting limit)
    const DEV_WALLETS = [
      '0x78EeAA6F014667A339fCF8b4eCd74743366603fb', // MetaMask
      '0xAB4F21321A7A16eb57171994C7D7D1C808506E5d'  // Farcaster
    ];
    const DEV_WALLET = DEV_WALLETS[0]; // Keep for backwards compat
    const isDevWallet = (addr) => DEV_WALLETS.some(w => w.toLowerCase() === addr?.toLowerCase());

    // ===== STATE =====
    const state = {
      // Auth
      isLoggedIn: false,
      isCheckingWhitelist: false,
      walletStatus: null, // Status message during wallet connection
      isWhitelisted: false,
      hasTokens: false,
      userAddress: '',
      userFid: null,
      userBalance: '0',
      currentView: 'create', // 'create', 'leaderboard', 'history'
      pendingTx: null, // Pending transaction hash

      // Voting
      votesRemaining: 10,
      votesUsedToday: 0,

      // Season & Prize Pool
      currentSeason: 0,
      prizePoolETH: 0,
      hostPoolETH: 0,  // On-chain host prize pool
      voterPoolETH: 0, // On-chain voter prize pool
      pendingClankerFees: '0', // Pending Clanker fees to collect
      totalTokensBurned: '0', // All-time Neynartodes burned from voting
      totalPrizesGiven: 0, // All-time prizes distributed (ETH)

      // Contest settings
      startMode: 'now', // 'now' or 'scheduled'
      startDate: '',
      endDate: '',
      durationHours: '1',
      durationMinutes: '0',
      lastLaunchDate: null, // Track last contest launch per wallet
      upcomingContests: [], // Array of scheduled contests
      prizeType: 'token', // Always token now (NFT removed)
      prizeTokenAddress: '',
      prizeTokenAmount: '',
      prizeTokenTicker: '',
      prizeTokenImage: '',
      prizeTokenSearch: '',
      showPrizeTokenSuggestions: false,

      // Social Dynamics
      socialEnabled: true,
      castHash: '',
      minLikes: '0',
      minRecasts: '0',
      minReplies: '0',

      // Tokenomics (always enabled - defaults to NEYNARTODES)
      tokenEnabled: true,
      tokenAddress: '0x8de1622fe07f56cda2e2273e615a513f1d828b07', // Default to NEYNARTODES
      tokenTicker: 'NEYNARTODES',
      tokenImage: '',
      tokenMcap: 0,
      tokenSearch: '',
      showTokenSuggestions: false,
      minTradeVolume: '',

      // Winner announcement
      customMessage: '',

      // Contest state
      contestLaunched: false,
      showCastPreview: false,
      announcementCast: '',
      contestActive: false,
      winner: null,
      totalParticipants: 0,
      contestStats: null,
      winnerCast: '',
      autoPosted: false,
      prizeReleased: false,

      // Leaderboard
      leaderboardData: [],

      // User badges
      userBadges: []
    };

    // ===== TOKEN DATABASE =====
    // Popular Base network tokens (fallback/cache)
    let tokenDatabase = [
      {
        name: 'Ethereum',
        ticker: 'ETH',
        address: '0x4200000000000000000000000000000000000006', // WETH on Base
        mcap: 450000000000,
        supply: 120000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png'
      },
      {
        name: 'USD Coin',
        ticker: 'USDC',
        address: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base
        mcap: 35000000000,
        supply: 35000000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png'
      },
      {
        name: 'Neynartodes',
        ticker: 'NEYNARTODES',
        address: '0x8de1622fe07f56cda2e2273e615a513f1d828b07',
        mcap: 85000,
        supply: 1000000000,
        image: 'https://i.imgur.com/placeholder-neynartodes.png'
      },
      {
        name: 'Dai Stablecoin',
        ticker: 'DAI',
        address: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb', // DAI on Base
        mcap: 5000000000,
        supply: 5000000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png'
      },
      {
        name: 'Aerodrome Finance',
        ticker: 'AERO',
        address: '0x940181a94A35A4569E4529A3CDfB74e38FD98631',
        mcap: 500000000,
        supply: 500000000,
        image: 'https://assets.coingecko.com/coins/images/31745/small/token.png'
      },
      {
        name: 'Brett',
        ticker: 'BRETT',
        address: '0x532f27101965dd16442E59d40670FaF5eBB142E4',
        mcap: 100000000,
        supply: 10000000000,
        image: 'https://assets.coingecko.com/coins/images/35711/small/brett.jpg'
      }
    ];

    // Cache for API token results
    let tokenCache = new Map();
    let lastFetchTime = 0;

    // ===== LOCALSTORAGE HELPERS FOR CUSTOM TOKENS =====
    const CUSTOM_TOKENS_KEY = 'neynartodes_custom_tokens';
    const ONE_YEAR_MS = 365 * 24 * 60 * 60 * 1000; // 1 year in milliseconds

    // Load custom tokens from localStorage (filters out expired ones)
    function loadCustomTokens() {
      try {
        const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
        if (!stored) return [];

        const data = JSON.parse(stored);
        const now = Date.now();

        // Filter out expired tokens (older than 1 year)
        const validTokens = data.filter(item => {
          return item.expiresAt && item.expiresAt > now;
        });

        // Save back the filtered list if we removed any expired tokens
        if (validTokens.length !== data.length) {
          localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(validTokens));
        }

        return validTokens.map(item => item.token);
      } catch (error) {
        console.warn('Failed to load custom tokens from localStorage:', error);
        return [];
      }
    }

    // Save a custom token to localStorage with 1-year expiration
    function saveCustomToken(token) {
      try {
        const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
        let data = stored ? JSON.parse(stored) : [];
        const now = Date.now();

        // Check if token already exists (by address)
        const existingIndex = data.findIndex(item =>
          item.token.address.toLowerCase() === token.address.toLowerCase()
        );

        if (existingIndex >= 0) {
          // Update expiration date for existing token
          data[existingIndex].expiresAt = now + ONE_YEAR_MS;
        } else {
          // Add new token with expiration
          data.push({
            token: token,
            expiresAt: now + ONE_YEAR_MS,
            addedAt: now
          });
        }

        localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(data));
        console.log(`Saved custom token ${token.ticker} to localStorage (expires in 1 year)`);
      } catch (error) {
        console.warn('Failed to save custom token to localStorage:', error);
      }
    }

    // ===== UTILITY FUNCTIONS =====
    // Fetch tokens from multiple sources for comprehensive Base token coverage
    async function fetchBaseTokens() {
      try {
        // First, load custom tokens from localStorage
        const customTokens = loadCustomTokens();
        if (customTokens.length > 0) {
          const existing = new Set(tokenDatabase.map(t => t.address.toLowerCase()));
          customTokens.forEach(token => {
            if (!existing.has(token.address.toLowerCase())) {
              tokenDatabase.push(token);
              existing.add(token.address.toLowerCase());
            }
          });
          console.log(`Loaded ${customTokens.length} custom tokens from localStorage`);
        }

        // Try multiple token list sources
        const tokenListUrls = [
          'https://tokens.coingecko.com/base/all.json', // CoinGecko Base tokens
          'https://raw.githubusercontent.com/Uniswap/default-token-list/main/build/uniswap-default.tokenlist.json', // Uniswap default
          'https://tokens.1inch.io/v1.1/8453' // 1inch Base tokens (chainId 8453)
        ];

        for (const url of tokenListUrls) {
          try {
            const response = await fetch(url);
            if (!response.ok) continue;

            const data = await response.json();
            let tokens = [];

            // Handle different token list formats
            if (data.tokens && Array.isArray(data.tokens)) {
              // Uniswap/CoinGecko format
              tokens = data.tokens.filter(t => t.chainId === 8453 || !t.chainId); // Base chainId is 8453
            } else if (typeof data === 'object' && !Array.isArray(data)) {
              // 1inch format (object with addresses as keys)
              tokens = Object.values(data);
            }

            if (tokens.length > 0) {
              const newTokens = tokens.map(token => ({
                name: token.name,
                ticker: token.symbol,
                address: (token.address || '').toLowerCase(),
                mcap: token.marketCap || 1000000,
                supply: token.totalSupply || 1000000000,
                image: token.logoURI || token.logo || `https://via.placeholder.com/40/9333ea/ffffff?text=${token.symbol?.[0] || '?'}`
              })).filter(t => t.address && t.address.startsWith('0x'));

              // Merge unique tokens
              const existing = new Set(tokenDatabase.map(t => t.address.toLowerCase()));
              newTokens.forEach(token => {
                if (!existing.has(token.address)) {
                  tokenDatabase.push(token);
                  existing.add(token.address);
                }
              });

              console.log(`Loaded ${newTokens.length} Base tokens from token list`);
              break; // Success, stop trying other sources
            }
          } catch (err) {
            console.warn('Failed to fetch from', url, err);
            continue; // Try next source
          }
        }
      } catch (error) {
        console.warn('Failed to fetch Base token lists, using fallback:', error);
      }
    }

    // Search tokens (synchronous search through cached database)
    function searchTokens(query) {
      if (!query || query.length < 2) return [];
      const q = query.toLowerCase();
      return tokenDatabase.filter(token =>
        token.name.toLowerCase().includes(q) ||
        token.ticker.toLowerCase().includes(q) ||
        token.address.toLowerCase().includes(q)
      ).slice(0, 20); // Limit to 20 results for performance
    }

    function getBadgeMultiplier(badges) {
      if (!badges || badges.length === 0) return 1;
      let multiplier = 1;
      badges.forEach(badge => {
        if (badge === 'gold') multiplier += 2;
        else if (badge === 'silver') multiplier += 1;
        else if (badge === 'bronze') multiplier += 0.5;
        else if (badge === 'purple') multiplier += 0.25;
      });
      return multiplier;
    }

    function getBadgeEmoji(badge) {
      if (badge === 'gold') return 'ğŸ¥‡';
      if (badge === 'silver') return 'ğŸ¥ˆ';
      if (badge === 'bronze') return 'ğŸ¥‰';
      if (badge === 'purple') return 'ğŸŸ£';
      if (badge === 'season0_beta') return 'ğŸ¦';
      return '';
    }

    function getBadgeTitle(badge) {
      if (badge === 'gold') return 'Gold Badge';
      if (badge === 'silver') return 'Silver Badge';
      if (badge === 'bronze') return 'Bronze Badge';
      if (badge === 'purple') return 'Purple Badge';
      if (badge === 'season0_beta') return 'Season 0 Beta Tester - Forever OG';
      return badge;
    }

    // ===== SEASON 0 BETA BADGE TRACKING =====
    function getSeasonTesterBadges() {
      try {
        const stored = localStorage.getItem('season0_beta_participants');
        return stored ? JSON.parse(stored) : {};
      } catch (e) {
        return {};
      }
    }

    function awardSeasonBetaBadge(fid, username) {
      if (state.currentSeason === 0 || state.currentSeason === 1) {
        try {
          const badges = getSeasonTesterBadges();
          if (!badges[fid]) {
            badges[fid] = {
              username: username,
              awardedAt: Date.now(),
              season: state.currentSeason
            };
            localStorage.setItem('season0_beta_participants', JSON.stringify(badges));
            console.log(`ğŸ¦ Season 0 Beta badge awarded to @${username} (FID: ${fid})`);
          }
        } catch (e) {
          console.error('Failed to award Season 0 Beta badge:', e);
        }
      }
    }

    function hasSeasonBetaBadge(fid) {
      const badges = getSeasonTesterBadges();
      return !!badges[fid];
    }

    // ===== CAST VALIDATION =====
    // Extract cast hash from URL or raw hash
    function extractCastHash(input) {
      if (!input) return null;
      input = input.trim();

      // If it's already a hash (starts with 0x)
      if (input.startsWith('0x')) {
        return input.toLowerCase();
      }

      // Extract from Warpcast URL: https://warpcast.com/username/0x1234abcd
      const warpcastMatch = input.match(/warpcast\.com\/[^/]+\/(0x[a-fA-F0-9]+)/i);
      if (warpcastMatch) {
        return warpcastMatch[1].toLowerCase();
      }

      // Try to find any 0x hash in the string
      const hashMatch = input.match(/(0x[a-fA-F0-9]{8,})/i);
      if (hashMatch) {
        return hashMatch[1].toLowerCase();
      }

      return null;
    }

    // Validate cast exists via Neynar API
    async function validateCast(castHash) {
      try {
        console.log('Validating cast hash:', castHash);

        const response = await fetch(`https://api.neynar.com/v2/farcaster/cast?identifier=${castHash}&type=hash`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        const data = await response.json();
        console.log('Neynar API response:', data);

        if (!response.ok || data.code === 'NotFound') {
          return {
            valid: false,
            error: `Cast not found for hash: ${castHash}\n\nMake sure you copied the full URL from Warpcast.\nNew casts may take a few seconds to be indexed.`
          };
        }

        if (data.cast) {
          const authorFid = data.cast.author?.fid;
          const authorUsername = data.cast.author?.username || 'unknown';

          // Check if the connected wallet owns this cast
          // Get author's verified addresses from Neynar
          let isOwnCast = false;
          let authorAddresses = [];

          if (authorFid && state.userAddress) {
            try {
              const verifyResponse = await fetch(`https://api.neynar.com/v2/farcaster/user/bulk?fids=${authorFid}`, {
                headers: {
                  'accept': 'application/json',
                  'api_key': CONFIG.NEYNAR_API_KEY
                }
              });
              const verifyData = await verifyResponse.json();

              if (verifyData.users && verifyData.users[0]) {
                // Get all verified addresses for this user
                authorAddresses = verifyData.users[0].verified_addresses?.eth_addresses || [];
                // Also check custody address
                if (verifyData.users[0].custody_address) {
                  authorAddresses.push(verifyData.users[0].custody_address);
                }

                // Check if connected wallet matches any of author's addresses
                const connectedLower = state.userAddress.toLowerCase();
                isOwnCast = authorAddresses.some(addr => addr.toLowerCase() === connectedLower);

                console.log('Author addresses:', authorAddresses);
                console.log('Connected wallet:', state.userAddress);
                console.log('Is own cast:', isOwnCast);
              }
            } catch (e) {
              console.error('Error checking cast ownership:', e);
              // If we can't verify, allow it but warn
            }
          }

          return {
            valid: true,
            cast: data.cast,
            author: authorUsername,
            authorFid: authorFid,
            authorAddresses: authorAddresses,
            isOwnCast: isOwnCast,
            text: data.cast.text?.substring(0, 100) || ''
          };
        }

        return { valid: false, error: 'Invalid cast data returned from API' };
      } catch (e) {
        console.error('Cast validation error:', e);
        return { valid: false, error: `Network error validating cast: ${e.message}\n\nPlease try again.` };
      }
    }

    // ===== BLOCKCHAIN FUNCTIONS =====
    async function connectWallet() {
      // DEBUG: First thing when connect is clicked
      alert('DEBUG connectWallet called!\n\nFarcasterSDK: ' + (window.FarcasterSDK ? 'YES' : 'NO') + '\nwindow.ethereum: ' + (window.ethereum ? 'YES' : 'NO'));

      try {
        // Helper for timeout (no longer used for wallet connection - we wait indefinitely)
        const withTimeout = (promise, ms, errorMsg) => Promise.race([
          promise,
          new Promise((_, reject) => setTimeout(() => reject(new Error(errorMsg || 'Request timed out')), ms))
        ]);

        // Try to get Farcaster Mini App SDK provider first (for Warpcast)
        let ethProvider = null;
        let providerSource = 'none';

        // Check for Farcaster SDK first
        if (window.FarcasterSDK) {
          try {
            const sdk = window.FarcasterSDK;
            console.log('Farcaster SDK found, wallet methods:', Object.keys(sdk.wallet || {}));

            // Get the provider using new method
            if (sdk.wallet?.getEthereumProvider) {
              ethProvider = await sdk.wallet.getEthereumProvider();
              providerSource = 'farcaster';
              console.log('Got Farcaster provider:', ethProvider);
            }
          } catch (sdkError) {
            console.log('Farcaster SDK wallet error:', sdkError);
          }
        }

        // Fallback to window.ethereum (MetaMask, etc)
        if (!ethProvider && window.ethereum) {
          ethProvider = window.ethereum;
          providerSource = 'metamask';
          console.log('Using window.ethereum (MetaMask)');
        }

        if (!ethProvider) {
          alert('No wallet found!\n\nFarcaster SDK: ' + (window.FarcasterSDK ? 'loaded' : 'not loaded') + '\nwindow.ethereum: ' + (window.ethereum ? 'yes' : 'no'));
          return false;
        }

        console.log('Using provider from:', providerSource);

        // Show "waiting for wallet" state - NO timeout, wait for user to unlock
        state.isCheckingWhitelist = true;
        state.walletStatus = 'Unlock your wallet to continue...';
        render();

        // Connect to wallet - NO TIMEOUT, wait indefinitely for unlock
        let accounts;
        try {
          console.log('Requesting wallet accounts (waiting for unlock if needed)...');

          // Use a Promise wrapper to allow UI updates during the wait
          accounts = await new Promise((resolve, reject) => {
            // Update UI to show we're waiting
            setTimeout(() => {
              state.walletStatus = 'Waiting for wallet... Check your extension!';
              render();
            }, 2000);

            ethProvider.request({ method: 'eth_requestAccounts' })
              .then(resolve)
              .catch(reject);
          });
        } catch (e) {
          state.isCheckingWhitelist = false;
          state.walletStatus = null;
          render();
          // User rejected or other error
          if (e.code === 4001) {
            alert('Wallet connection rejected. Please try again.');
          } else if (e.code === -32002) {
            // Already pending - wallet popup might be hidden
            alert('Wallet request already pending!\n\nCheck if MetaMask popup is hidden or click the MetaMask extension icon.');
            return false;
          } else {
            alert(e.message || 'Failed to connect wallet. Please try again.');
          }
          return false;
        }

        // Store the provider for later use
        window.activeEthProvider = ethProvider;
        state.walletStatus = 'Connected! Checking access...';
        render();

        if (!accounts || accounts.length === 0) {
          state.isCheckingWhitelist = false;
          render();
          alert('No accounts found. Please unlock MetaMask and try again.');
          return false;
        }

        const address = accounts[0];
        state.userAddress = address;

        // Check network (use the active provider)
        const chainId = await ethProvider.request({ method: 'eth_chainId' });
        if (chainId !== '0x2105') { // Base mainnet
          try {
            await ethProvider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: '0x2105' }]
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              await ethProvider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: '0x2105',
                  chainName: 'Base',
                  nativeCurrency: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
                  rpcUrls: ['https://mainnet.base.org'],
                  blockExplorerUrls: ['https://basescan.org']
                }]
              });
            } else {
              throw switchError;
            }
          }
        }

        // Create provider - use JsonRpcProvider for more reliable RPC
        const provider = new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC_URL);

        console.log('Checking whitelist for:', address);

        // Check whitelist with timeout
        const prizeNFTContract = new ethers.Contract(
          CONFIG.CONTRACTS.prizeNFT,
          ['function whitelisted(address) external view returns (bool)'],
          provider
        );

        try {
          state.isWhitelisted = await withTimeout(prizeNFTContract.whitelisted(address), 10000, 'Whitelist check timed out');
        } catch (e) {
          console.error('Whitelist check failed:', e);
          // Default to true if check fails (let them try)
          state.isWhitelisted = true;
        }

        if (!state.isWhitelisted) {
          state.isCheckingWhitelist = false;
          render();
          alert('ğŸš« Season 0 Access Denied!\n\nYou are not on the whitelist for Season 0 beta.\n\nStay tuned for public launch! ğŸ¦');
          return false;
        }

        console.log('Checking token balance...');

        // Check token balance with timeout
        const neynartodeContract = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          ['function balanceOf(address) external view returns (uint256)'],
          provider
        );

        let balance;
        try {
          balance = await withTimeout(neynartodeContract.balanceOf(address), 10000);
          state.userBalance = ethers.utils.formatEther(balance);
        } catch (e) {
          console.error('Balance check failed:', e);
          // Default to enough tokens if check fails
          balance = CONFIG.SEASON_0_MIN_TOKENS;
          state.userBalance = '20000';
        }

        if (balance.lt(CONFIG.SEASON_0_MIN_TOKENS)) {
          state.isCheckingWhitelist = false;
          render();
          alert(`ğŸš« Insufficient Tokens!\n\nYou need at least 20,000 $NEYNARTODES to use this app.\n\nYour balance: ${parseFloat(state.userBalance).toLocaleString()} NEYNARTODES\nRequired: 20,000 NEYNARTODES\n\nGo get more Neynartodes! ğŸ¦`);
          return false;
        }

        state.hasTokens = true;

        // Fetch user FID from Neynar API
        try {
          const response = await fetch(`https://api.neynar.com/v2/farcaster/user/by-verification?address=${address}`, {
            headers: {
              'accept': 'application/json',
              'api_key': CONFIG.NEYNAR_API_KEY
            }
          });
          if (response.ok) {
            const data = await response.json();
            if (data && data.users && data.users.length > 0) {
              state.userFid = data.users[0].fid;
            }
          }
        } catch (e) {
          console.error('Neynar API error:', e);
        }

        state.isLoggedIn = true;
        state.isCheckingWhitelist = false;
        state.walletStatus = null;

        // Load leaderboard data
        await loadLeaderboard();

        render();
        return true;
      } catch (error) {
        console.error('Wallet connection error:', error);
        state.isCheckingWhitelist = false;
        state.walletStatus = null;
        render();
        alert('Failed to connect wallet: ' + error.message);
        return false;
      }
    }

    async function loadPrizePools() {
      try {
        // Use stored provider or fallback to JsonRpcProvider for read-only calls
        const ethProvider = window.activeEthProvider || window.ethereum;
        const provider = ethProvider
          ? new ethers.providers.Web3Provider(ethProvider)
          : new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC_URL);

        // Load current season and prize pools from PrizeNFT contract
        const prizeNFTABI = [
          'function nextSeasonId() external view returns (uint256)',
          'function seasons(uint256) external view returns (string theme, uint256 startTime, uint256 endTime, uint256 devPool, uint256 hostPool, uint256 voterPool, bool distributed)'
        ];

        const prizeNFT = new ethers.Contract(
          CONFIG.CONTRACTS.prizeNFT,
          prizeNFTABI,
          provider
        );

        // Get current season ID (latest season)
        const nextSeasonId = await prizeNFT.nextSeasonId();
        state.currentSeason = nextSeasonId.toNumber() - 1;

        if (state.currentSeason > 0) {
          // Get season data
          const season = await prizeNFT.seasons(state.currentSeason);
          state.hostPoolETH = parseFloat(ethers.utils.formatEther(season.hostPool));
          state.voterPoolETH = parseFloat(ethers.utils.formatEther(season.voterPool));
          state.prizePoolETH = state.hostPoolETH + state.voterPoolETH; // Total
        }

        // Clanker fees now go direct to Treasury - no pending fees to track
        state.pendingClankerFees = '0';

        // Load all-time stats from VotingManager
        const votingManagerABI = [
          'function totalTokensBurned() external view returns (uint256)',
          'function totalVotes() external view returns (uint256)'
        ];

        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          provider
        );

        const tokensBurned = await votingManager.totalTokensBurned();
        state.totalTokensBurned = ethers.utils.formatEther(tokensBurned);

        // For now, calculate prizes given from all seasons (you can add a totalPrizesDistributed to contract later)
        // For beta, we'll use the current season's total as placeholder
        if (state.currentSeason > 0) {
          const season = await prizeNFT.seasons(state.currentSeason);
          state.totalPrizesGiven = parseFloat(ethers.utils.formatEther(season.devPool.add(season.hostPool).add(season.voterPool)));
        }

        console.log('Prize pools loaded:', {
          season: state.currentSeason,
          hostPool: state.hostPoolETH,
          voterPool: state.voterPoolETH,
          pendingFees: state.pendingClankerFees,
          tokensBurned: state.totalTokensBurned,
          prizesGiven: state.totalPrizesGiven
        });
      } catch (error) {
        console.error('Failed to load prize pools:', error);
      }
    }

    async function loadLeaderboard() {
      // Load prize pools from contracts
      await loadPrizePools();

      // Start with empty leaderboard - will be populated from on-chain contest data
      // TODO: Fetch actual host stats from ContestEscrow events
      state.leaderboardData = [];

      // Award Season 0 Beta badges to all participants and add to their badge list
      state.leaderboardData = state.leaderboardData.map(host => {
        // Award the badge if they're on the leaderboard during Season 0/1
        awardSeasonBetaBadge(host.fid, host.username);

        // Add season0_beta badge to their current badges if they've earned it
        const badges = [...host.badges];
        if (hasSeasonBetaBadge(host.fid) && !badges.includes('season0_beta')) {
          badges.push('season0_beta');
        }

        return { ...host, badges };
      });

      // Limit to top 10 hosts (or all if less than 10)
      state.leaderboardData = state.leaderboardData
        .sort((a, b) => b.totalScore - a.totalScore)
        .slice(0, 10)
        .map((host, idx) => ({ ...host, rank: idx + 1 }));

      // Clear sample upcoming contests - will be populated from on-chain data
      state.upcomingContests = [];
    }

    async function voteForHost(hostFid, isUpvote) {
      // Check if dev wallet (unlimited voting)
      const isDev = isDevWallet(state.userAddress);

      if (!isDev && state.votesRemaining <= 0) {
        alert('You have used all 10 votes for today! Come back tomorrow.');
        return;
      }

      try {
        // Create provider and signer using stored provider
        const ethProvider = window.activeEthProvider || window.ethereum;
        if (!ethProvider) {
          alert('Wallet not connected! Please reconnect.');
          return;
        }
        const provider = new ethers.providers.Web3Provider(ethProvider);
        const signer = provider.getSigner();

        // Contract ABIs
        const votingManagerABI = [
          'function vote(uint256 contestId) external',
          'function getRemainingVotes(address user) external view returns (uint256)',
          'function canVote(address user, uint256 contestId) external view returns (bool)',
          'function TOKENS_PER_VOTE() external view returns (uint256)'
        ];

        const tokenABI = [
          'function approve(address spender, uint256 amount) external returns (bool)',
          'function allowance(address owner, address spender) external view returns (uint256)',
          'function balanceOf(address account) external view returns (uint256)'
        ];

        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          signer
        );

        const neynartodeToken = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          tokenABI,
          signer
        );

        // Use hostFid as contestId for now
        const contestId = hostFid;

        // Check if can vote (skip for dev wallet)
        if (!isDevWallet) {
          const canVote = await votingManager.canVote(state.userAddress, contestId);
          if (!canVote) {
            alert('âŒ Cannot vote!\n\nYou may have:\n- Already voted for this host\n- Used all 10 votes today\n- Insufficient token balance');
            return;
          }
        }

        // Get tokens per vote (1000 NEYNARTODES)
        const tokensPerVote = ethers.utils.parseEther('1000');

        // Check balance
        const balance = await neynartodeToken.balanceOf(state.userAddress);
        if (balance.lt(tokensPerVote)) {
          alert(`âŒ Insufficient balance!\n\nYou need 1,000 $NEYNARTODES to vote.\n\nYour balance: ${ethers.utils.formatEther(balance)} NEYNARTODES`);
          return;
        }

        // Check and set approval if needed
        const currentAllowance = await neynartodeToken.allowance(state.userAddress, CONFIG.CONTRACTS.votingManager);
        if (currentAllowance.lt(tokensPerVote)) {
          alert('ğŸ” First, you need to approve the voting contract to spend your tokens.\n\nThis is a one-time approval for security.\n\nClick OK to approve...');

          const approveTx = await neynartodeToken.approve(
            CONFIG.CONTRACTS.votingManager,
            ethers.constants.MaxUint256 // Infinite approval
          );

          alert('â³ Approval transaction submitted!\n\nWaiting for confirmation...\n\nTx: ' + approveTx.hash);
          await approveTx.wait();
          alert('âœ… Approval confirmed!\n\nNow submitting your vote...');
        }

        // Cast vote on-chain
        alert('ğŸ—³ï¸ Submitting your vote on-chain...\n\nThis will:\nâ€¢ Burn 500 NEYNARTODES (50%)\nâ€¢ Send 500 to treasury (50%)\n\nConfirm in MetaMask!');

        const voteTx = await votingManager.vote(contestId);

        alert('â³ Vote transaction submitted!\n\nWaiting for confirmation...\n\nTx: ' + voteTx.hash);
        const receipt = await voteTx.wait();

        // Update UI after successful vote
        const votePoints = isUpvote ? 5 : -5;
        const oldRankings = state.leaderboardData.map(h => ({ fid: h.fid, rank: h.rank }));

        // Update leaderboard
        state.leaderboardData = state.leaderboardData.map(host => {
          if (host.fid === hostFid) {
            return {
              ...host,
              voteScore: host.voteScore + (votePoints * 1000),
              totalScore: host.totalScore + (votePoints * 1000)
            };
          }
          return host;
        }).sort((a, b) => b.totalScore - a.totalScore).map((host, idx) => ({ ...host, rank: idx + 1 }));

        const votedHost = state.leaderboardData.find(h => h.fid === hostFid);
        const oldRank = oldRankings.find(h => h.fid === hostFid)?.rank;
        const newRank = votedHost.rank;
        const movement = oldRank - newRank;

        let movementText = '';
        if (movement > 0) {
          movementText = `\nğŸ“ˆ @${votedHost.username} moved UP ${movement} position${movement > 1 ? 's' : ''}! (${oldRank} â†’ ${newRank})`;
        } else if (movement < 0) {
          movementText = `\nğŸ“‰ @${votedHost.username} moved DOWN ${Math.abs(movement)} position${Math.abs(movement) > 1 ? 's' : ''}! (${oldRank} â†’ ${newRank})`;
        } else {
          movementText = `\nâ¡ï¸ @${votedHost.username} stayed at rank #${newRank}`;
        }

        // Only decrement vote counter for non-dev wallets
        if (!isDevWallet) {
          state.votesUsedToday++;
          state.votesRemaining--;
        }

        const ethFromVote = 0.00001;
        state.prizePoolETH += (ethFromVote * 0.5);

        alert(`âœ… ${isUpvote ? 'ğŸ‘ Upvote' : 'ğŸ‘ Downvote'} confirmed on-chain!${movementText}\n\nğŸ”¥ 500 $NEYNARTODES burned\nğŸ’° 500 $NEYNARTODES â†’ Treasury\n\nTx: ${receipt.transactionHash}\n\n${isDevWallet ? 'ğŸ› ï¸ Dev Mode: Unlimited votes' : `Votes remaining today: ${state.votesRemaining}/10`}`);

        render();
      } catch (error) {
        console.error('Voting error:', error);

        if (error.code === 4001) {
          alert('âŒ Transaction rejected by user');
        } else if (error.message && error.message.includes('Daily vote limit')) {
          alert('âŒ Daily vote limit reached!\n\nYou can only vote 10 times per day.\n\nCome back tomorrow!');
        } else if (error.message && error.message.includes('Already voted')) {
          alert('âŒ Already voted!\n\nYou have already voted for this host.');
        } else if (error.message && error.message.includes('Not whitelisted')) {
          alert('âŒ Not whitelisted!\n\nYou need to be on the Season 0 whitelist.');
        } else {
          alert('âŒ Vote failed!\n\n' + (error.reason || error.message || 'Unknown error'));
        }
      }
    }

    // ===== RENDER FUNCTIONS =====
    function render() {
      const app = document.getElementById('app');

      if (!state.isLoggedIn) {
        app.innerHTML = renderLoginPage();
      } else if (state.currentView === 'leaderboard') {
        app.innerHTML = renderLeaderboard();
      } else if (state.currentView === 'history') {
        app.innerHTML = renderHistory();
      } else {
        app.innerHTML = renderCreateContest();
      }

      attachEventListeners();
    }

    function renderLoginPage() {
      return `
        <div class="min-h-screen bg-gradient-to-b from-blue-400 via-purple-500 to-blue-900 flex items-center justify-center p-6 relative overflow-hidden">
          <div class="absolute inset-0 opacity-20">
            <div class="absolute bottom-0 left-1/4 w-4 h-4 bg-white rounded-full bubble" style="animation-duration: 3s"></div>
            <div class="absolute bottom-0 left-1/2 w-6 h-6 bg-white rounded-full bubble" style="animation-duration: 4s; animation-delay: 1s"></div>
            <div class="absolute bottom-0 right-1/3 w-3 h-3 bg-white rounded-full bubble" style="animation-duration: 5s; animation-delay: 2s"></div>
          </div>

          <div class="bg-white rounded-3xl shadow-2xl p-12 max-w-md w-full text-center relative z-10 border-4 border-purple-400">
            <div class="mb-6">
              <div class="text-7xl mb-4 animate-bounce">ğŸ¦</div>
              <h1 class="text-5xl font-black mb-3" style="background: linear-gradient(45deg, #9333ea, #ec4899, #a855f7); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 2px 2px 4px rgba(147, 51, 234, 0.3); letter-spacing: -0.02em">
                Danng<br/>Neynartodes!!
              </h1>
              <p class="text-purple-600 font-bold text-sm">ğŸŒŠ Season 0 Beta ğŸŒŠ</p>
            </div>

            <div class="mb-6 p-4 bg-gradient-to-r from-purple-100 to-pink-100 rounded-xl border-2 border-purple-300">
              <div class="text-2xl mb-2">ğŸ”’</div>
              <p class="text-sm font-black text-purple-800 mb-1">SEASON 0 BETA</p>
              <p class="text-xs text-purple-700 font-semibold">
                âœ… Whitelist Required<br/>
                ğŸ’ Hold 20K+ $NEYNARTODES
              </p>
            </div>

            ${state.isCheckingWhitelist ? `
              <div class="mb-4 p-4 bg-blue-100 rounded-xl border-2 border-blue-300">
                <div class="animate-spin text-3xl mb-2">ğŸŒ€</div>
                <p class="text-sm font-bold text-blue-800">${state.walletStatus || 'Checking whitelist & balance...'}</p>
                <p class="text-xs text-blue-600 mt-1">Unlock your wallet if prompted</p>
              </div>
            ` : ''}

            <button
              id="connectButton"
              ${state.isCheckingWhitelist ? 'disabled' : ''}
              class="w-full flex items-center justify-center gap-3 bg-gradient-to-r from-purple-500 via-pink-500 to-purple-600 hover:from-purple-600 hover:via-pink-600 hover:to-purple-700 disabled:from-gray-400 disabled:to-gray-400 text-white px-6 py-5 rounded-2xl font-black text-xl transition-all shadow-lg transform hover:scale-105 border-2 border-purple-300"
              style="text-shadow: 1px 1px 2px rgba(0,0,0,0.3)"
            >
              ğŸ”¥ ${state.isCheckingWhitelist ? (state.walletStatus ? 'Waiting...' : 'Checking...') : 'Connect Wallet'}
            </button>

            <div class="mt-8 p-4 bg-purple-50 rounded-xl border-2 border-purple-200">
              <p class="text-sm text-purple-800 mb-2 font-semibold">ğŸŒŠ Powered by the Colony ğŸŒŠ</p>
              <a
                href="https://dexscreener.com/base/0x8de1622fe07f56cda2e2273e615a513f1d828b07"
                target="_blank"
                rel="noopener noreferrer"
                class="text-purple-600 hover:text-pink-600 font-black text-lg transition-colors"
              >
                $NEYNARTODES
              </a>
              <p class="font-mono text-xs text-gray-600 mt-2 break-all">CA: 0x8de1622fe07f56cda2e2273e615a513f1d828b07</p>
            </div>
          </div>
        </div>
      `;
    }

    function renderHeader() {
      return `
        <div class="bg-gradient-to-r from-purple-400 via-pink-400 to-purple-500 rounded-2xl shadow-2xl p-5 mb-6 border-4 border-purple-300">
          <div class="flex items-center justify-between">
            <div>
              <h1 class="text-3xl font-black text-white flex items-center gap-2 drop-shadow-lg" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.3)">
                ğŸ¦ Danng Neynartodes!! ğŸŒŠ
              </h1>
              <p class="text-sm text-purple-100 font-semibold">
                Season 0 Beta â€¢ ${state.userAddress.substring(0, 6)}...${state.userAddress.substring(38)}
                ${state.userBadges.length > 0 ? `<span class="ml-2">${state.userBadges.map(b => getBadgeEmoji(b)).join('')}</span>` : ''}
              </p>
              <p class="text-xs text-white font-bold mt-1 bg-purple-600 bg-opacity-50 inline-block px-3 py-1 rounded-full">
                ğŸ¦ ${parseFloat(state.userBalance).toLocaleString()} $NEYNARTODES
              </p>
            </div>
            <div class="flex gap-2">
              <button id="viewCreate" class="px-4 py-2 rounded-xl font-bold transition-all transform hover:scale-105 ${state.currentView === 'create' ? 'bg-white text-purple-600 shadow-lg' : 'bg-purple-300 text-purple-800 hover:bg-purple-200'}">
                Create
              </button>
              <button id="viewHistory" class="px-4 py-2 rounded-xl font-bold transition-all transform hover:scale-105 ${state.currentView === 'history' ? 'bg-white text-purple-600 shadow-lg' : 'bg-purple-300 text-purple-800 hover:bg-purple-200'}">
                ğŸ“œ History
              </button>
              <button id="viewLeaderboard" class="px-4 py-2 rounded-xl font-bold transition-all transform hover:scale-105 ${state.currentView === 'leaderboard' ? 'bg-white text-purple-600 shadow-lg' : 'bg-purple-300 text-purple-800 hover:bg-purple-200'}">
                ğŸ† Leaderboard
              </button>
            </div>
          </div>
        </div>
      `;
    }

    function renderLeaderboard() {
      return `
        <div class="min-h-screen bg-gradient-to-b from-blue-100 via-purple-100 to-pink-100 p-6 relative">
          <div class="fixed inset-0 pointer-events-none opacity-10 overflow-hidden">
            <div class="absolute top-10 left-10 text-6xl">ğŸª¸</div>
            <div class="absolute top-40 right-20 text-5xl">ğŸš</div>
            <div class="absolute bottom-20 left-1/4 text-7xl">ğŸŒŠ</div>
            <div class="absolute bottom-40 right-1/3 text-5xl">ğŸ«§</div>
          </div>

          <div class="max-w-7xl mx-auto relative z-10">
            ${renderHeader()}

            <div class="space-y-6">
              <!-- Season Info -->
              <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="bg-gradient-to-br from-purple-500 to-purple-700 rounded-2xl shadow-2xl p-6 text-white border-4 border-purple-400 transform hover:scale-105 transition-transform">
                  <div class="text-sm font-bold mb-2 opacity-90">ğŸŒŠ Current Season ğŸŒŠ</div>
                  <div class="text-5xl font-black mb-2">#${state.currentSeason}</div>
                  <div class="text-xs opacity-90 font-semibold">Beta Testing</div>
                </div>

                <div class="bg-gradient-to-br from-green-400 to-emerald-600 rounded-2xl shadow-2xl p-6 text-white border-4 border-green-300 transform hover:scale-105 transition-transform">
                  <div class="text-sm font-bold mb-2 opacity-90">ğŸ† Host Prize Pool ğŸ†</div>
                  <div class="text-4xl font-black mb-2">${state.hostPoolETH.toFixed(4)} ETH</div>
                  <div class="text-xs opacity-90 font-semibold">For Contest Creators</div>
                </div>

                <div class="bg-gradient-to-br from-blue-400 to-cyan-600 rounded-2xl shadow-2xl p-6 text-white border-4 border-blue-300 transform hover:scale-105 transition-transform">
                  <div class="text-sm font-bold mb-2 opacity-90">ğŸ—³ï¸ Voter Prize Pool ğŸ—³ï¸</div>
                  <div class="text-4xl font-black mb-2">${state.voterPoolETH.toFixed(4)} ETH</div>
                  <div class="text-xs opacity-90 font-semibold">For Active Voters</div>
                </div>

                <div class="bg-gradient-to-br from-yellow-400 to-orange-500 rounded-2xl shadow-2xl p-6 text-white border-4 border-yellow-300 transform hover:scale-105 transition-transform">
                  <div class="text-sm font-bold mb-2 opacity-90">ğŸ‘‘ Leader ğŸ‘‘</div>
                  <div class="text-3xl font-black mb-2">
                    ${state.leaderboardData.length > 0 ? `${state.leaderboardData[0].pfp} @${state.leaderboardData[0].username}` : 'TBA'}
                  </div>
                  <div class="text-xs opacity-90 font-semibold">
                    ${state.leaderboardData.length > 0 ? `${state.leaderboardData[0].totalScore.toLocaleString()} points` : 'Launch contests to compete!'}
                  </div>
                </div>
              </div>

              <!-- All-Time Stats -->
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="bg-gradient-to-br from-red-400 to-orange-600 rounded-2xl shadow-2xl p-6 text-white border-4 border-red-300">
                  <div class="text-sm font-bold mb-2 opacity-90">ğŸ”¥ ALL-TIME BURNED ğŸ”¥</div>
                  <div class="text-4xl font-black mb-2">${parseFloat(state.totalTokensBurned).toLocaleString()} $NEYNARTODES</div>
                  <div class="text-xs opacity-90 font-semibold">Permanently removed from supply</div>
                </div>

                <div class="bg-gradient-to-br from-emerald-400 to-green-600 rounded-2xl shadow-2xl p-6 text-white border-4 border-emerald-300">
                  <div class="text-sm font-bold mb-2 opacity-90">ğŸ’ ALL-TIME PRIZES ğŸ’</div>
                  <div class="text-4xl font-black mb-2">${state.totalPrizesGiven.toFixed(4)} ETH</div>
                  <div class="text-xs opacity-90 font-semibold">Given to hosts & voters</div>
                </div>
              </div>

              <!-- Feed the Neynartodes Button -->
              ${parseFloat(state.pendingClankerFees) > 0 ? `
                <div class="bg-gradient-to-r from-orange-100 to-red-100 rounded-2xl shadow-xl p-6 border-4 border-orange-300">
                  <div class="flex items-center justify-between">
                    <div class="flex-1">
                      <h3 class="text-2xl font-black text-orange-800 mb-2">ğŸ¦ Feed the Neynartodes! ğŸ¦</h3>
                      <p class="text-sm text-orange-700 font-semibold mb-2">
                        ${parseFloat(state.pendingClankerFees).toFixed(2)} $NEYNARTODES available from Clanker fees!
                      </p>
                      <p class="text-xs text-orange-600">
                        Click to collect fees and compound liquidity. 50% goes to treasury, 50% to recipient, then triggers Captain Hook!
                      </p>
                    </div>
                    <button
                      onclick="feedTheNeynartodes()"
                      class="ml-4 px-8 py-4 bg-gradient-to-r from-orange-500 to-red-600 hover:from-orange-600 hover:to-red-700 text-white rounded-2xl font-black text-xl transition-all shadow-lg transform hover:scale-105 border-2 border-orange-300"
                    >
                      ğŸ– FEED NOW
                    </button>
                  </div>
                </div>
              ` : ''}

              <!-- Voting Info -->
              <div class="bg-gradient-to-r from-pink-100 to-purple-100 rounded-2xl shadow-xl p-6 border-4 border-purple-300">
                <div class="flex items-center justify-between">
                  <div>
                    <h3 class="text-xl font-black text-purple-800 mb-1">âš¡ Your Voting Power âš¡</h3>
                    <p class="text-sm text-purple-700 font-semibold">
                      1000 $NEYNARTODES per vote â€¢ Resets daily ğŸ”„
                    </p>
                  </div>
                  <div class="text-right">
                    <div class="text-4xl font-black text-purple-600">${state.votesRemaining}/10</div>
                    <div class="text-xs text-purple-700 font-bold">Votes Left Today</div>
                  </div>
                </div>
                <div class="mt-4 bg-white p-4 rounded-xl border-2 border-purple-200 text-sm text-purple-800">
                  <p class="font-black mb-2">ğŸ¦ How Voting Works:</p>
                  <ul class="mt-2 space-y-1 list-none font-semibold">
                    <li>ğŸ’¸ 1000 $NEYNARTODES per vote (50% ğŸ”¥ burned, 50% â†’ prize pool)</li>
                    <li>ğŸ‘ Upvotes add 5,000 points | ğŸ‘ Downvotes subtract 5,000 points</li>
                    <li>ğŸ“Š 10 votes per day - make them count!</li>
                  </ul>
                </div>
              </div>

              <!-- Leaderboard Table -->
              <div class="bg-white rounded-2xl shadow-2xl p-6 border-4 border-purple-300">
                <div class="flex items-center gap-3 mb-6">
                  <div class="text-purple-600 text-4xl">ğŸ“ˆ</div>
                  <div>
                    <h2 class="text-3xl font-black text-purple-800">ğŸ¦ Colony Leaderboard ğŸ¦</h2>
                    <p class="text-sm text-purple-600 font-bold">Top Neynartode Feeders - Season ${state.currentSeason}</p>
                  </div>
                </div>

                <div class="overflow-x-auto">
                  ${state.leaderboardData.length === 0 ? `
                    <div class="text-center py-12">
                      <div class="text-6xl mb-4">ğŸ¦</div>
                      <h3 class="text-2xl font-black text-purple-800 mb-2">No Hosts Yet!</h3>
                      <p class="text-purple-600 font-semibold">Be the first to launch a contest and claim the top spot!</p>
                      <p class="text-sm text-purple-500 mt-2">Top 10 hosts will be displayed here</p>
                    </div>
                  ` : `
                  <table class="w-full">
                    <thead>
                      <tr class="border-b-2 border-gray-200">
                        <th class="text-left py-3 px-2 font-semibold text-gray-700">Rank</th>
                        <th class="text-left py-3 px-2 font-semibold text-gray-700">Host</th>
                        <th class="text-right py-3 px-2 font-semibold text-gray-700">Score</th>
                        <th class="text-center py-3 px-2 font-semibold text-gray-700">Vote</th>
                        <th class="text-right py-3 px-2 font-semibold text-gray-700">Contests</th>
                        <th class="text-right py-3 px-2 font-semibold text-gray-700">Neynar</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${state.leaderboardData.map(host => `
                        <tr class="border-b-2 border-purple-100 hover:bg-gradient-to-r hover:from-purple-50 hover:to-pink-50 transition-all">
                          <td class="py-4 px-2">
                            <div class="font-black text-xl ${
                              host.rank === 1 ? 'text-yellow-500 text-2xl' :
                              host.rank === 2 ? 'text-gray-400 text-xl' :
                              host.rank === 3 ? 'text-orange-500 text-xl' :
                              'text-purple-600'
                            }">
                              ${host.rank === 1 ? 'ğŸ‘‘' : host.rank === 2 ? 'ğŸ¥ˆ' : host.rank === 3 ? 'ğŸ¥‰' : `#${host.rank}`}
                            </div>
                          </td>
                          <td class="py-4 px-2">
                            <div class="flex items-center gap-2">
                              <span class="text-2xl">${host.pfp}</span>
                              <div>
                                <div class="font-semibold text-gray-800 flex items-center gap-1">
                                  @${host.username}
                                  ${host.badges.map(badge => `<span title="${getBadgeTitle(badge)}">${getBadgeEmoji(badge)}</span>`).join('')}
                                </div>
                              </div>
                            </div>
                          </td>
                          <td class="py-4 px-2 text-right">
                            <div class="font-bold text-purple-600 text-lg">
                              ${host.totalScore.toLocaleString()}
                            </div>
                          </td>
                          <td class="py-4 px-2">
                            <div class="flex gap-1 justify-center">
                              <button
                                onclick="voteForHost(${host.fid}, true)"
                                ${state.votesRemaining <= 0 ? 'disabled' : ''}
                                class="p-2 bg-green-100 hover:bg-green-200 disabled:bg-gray-100 disabled:cursor-not-allowed text-green-600 rounded transition-colors"
                                title="Upvote (+5000 pts)"
                              >
                                ğŸ‘
                              </button>
                              <button
                                onclick="voteForHost(${host.fid}, false)"
                                ${state.votesRemaining <= 0 ? 'disabled' : ''}
                                class="p-2 bg-red-100 hover:bg-red-200 disabled:bg-gray-100 disabled:cursor-not-allowed text-red-600 rounded transition-colors"
                                title="Downvote (-5000 pts)"
                              >
                                ğŸ‘
                              </button>
                            </div>
                          </td>
                          <td class="py-4 px-2 text-right text-gray-700">${host.contests}</td>
                          <td class="py-4 px-2 text-right">
                            <span class="bg-blue-100 text-blue-700 px-2 py-1 rounded text-sm font-semibold">
                              ${host.neynarScore}
                            </span>
                          </td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                  `}
                </div>

                <div class="mt-6 p-6 bg-gradient-to-r from-purple-100 to-pink-100 rounded-2xl border-4 border-purple-300">
                  <h3 class="font-black text-purple-900 mb-3 text-xl">ğŸ¦ Scoring System ğŸ¦</h3>
                  <div class="text-sm text-purple-800 space-y-2 font-semibold">
                    <div>ğŸ¯ <strong>Total Score = Contest Score + Vote Score</strong></div>
                    <div>ğŸ“Š Contest Score = (SocialÃ—3) + Token</div>
                    <div>ğŸ—³ï¸ Vote Score = (Upvotes - Downvotes) Ã— 5,000</div>
                    <div>ğŸ’¬ Social = (LikesÃ—1 + RecastsÃ—2 + RepliesÃ—3) Ã— 100</div>
                    <div>ğŸ’° Token = Volume Points Ã— 50</div>
                  </div>
                </div>
              </div>

              <!-- Upcoming Contests Calendar -->
              ${state.upcomingContests.length > 0 ? `
                <div class="bg-white rounded-2xl shadow-2xl p-6 border-4 border-purple-300 mt-6">
                  <div class="flex items-center gap-3 mb-6">
                    <div class="text-purple-600 text-4xl">ğŸ“…</div>
                    <div>
                      <h2 class="text-3xl font-black text-purple-800">ğŸ—“ï¸ Upcoming Contests ğŸ—“ï¸</h2>
                      <p class="text-sm text-purple-600 font-bold">${state.upcomingContests.length} contest${state.upcomingContests.length > 1 ? 's' : ''} scheduled</p>
                    </div>
                  </div>

                  <div class="space-y-4">
                    ${state.upcomingContests.filter(c => new Date(c.endTime) > new Date()).slice(0, 10).map(contest => {
                      const now = new Date();
                      const isLive = new Date(contest.startTime) <= now && new Date(contest.endTime) > now;
                      const isUpcoming = new Date(contest.startTime) > now;

                      return `
                        <div class="border-2 ${isLive ? 'border-green-400 bg-green-50' : 'border-purple-200 bg-purple-50'} rounded-xl p-4">
                          <div class="flex items-start justify-between">
                            <div class="flex-1">
                              <div class="flex items-center gap-2 mb-2">
                                ${isLive ? '<span class="bg-green-500 text-white px-3 py-1 rounded-full text-xs font-bold animate-pulse">ğŸ”´ LIVE NOW</span>' : '<span class="bg-purple-500 text-white px-3 py-1 rounded-full text-xs font-bold">â° UPCOMING</span>'}
                                <span class="text-sm font-semibold text-gray-700">Host: ${contest.host}</span>
                              </div>

                              <div class="grid grid-cols-2 gap-3 mt-3">
                                <div class="bg-white p-2 rounded-lg">
                                  <div class="text-xs text-gray-600">ğŸ Prize</div>
                                  <div class="text-sm font-bold text-purple-600">${contest.prize}</div>
                                </div>
                                <div class="bg-white p-2 rounded-lg">
                                  <div class="text-xs text-gray-600">â±ï¸ Duration</div>
                                  <div class="text-sm font-bold text-blue-600">${contest.duration}</div>
                                </div>
                                <div class="bg-white p-2 rounded-lg">
                                  <div class="text-xs text-gray-600">${isLive ? 'ğŸ Ends' : 'ğŸš€ Starts'}</div>
                                  <div class="text-sm font-bold text-gray-800">${isLive ? new Date(contest.endTime).toLocaleString() : new Date(contest.startTime).toLocaleString()}</div>
                                </div>
                                <div class="bg-white p-2 rounded-lg">
                                  <div class="text-xs text-gray-600">ğŸ“Š Requirements</div>
                                  <div class="text-xs font-semibold text-gray-700">
                                    ${contest.socialEnabled ? 'ğŸ‘¥ Social' : ''} ${contest.tokenEnabled ? 'ğŸ’° Token' : ''}
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      `;
                    }).join('')}
                  </div>

                  ${state.upcomingContests.length > 10 ? `
                    <div class="mt-4 text-center text-sm text-purple-600 font-semibold">
                      + ${state.upcomingContests.length - 10} more contests scheduled
                    </div>
                  ` : ''}
                </div>
              ` : ''}
            </div>
          </div>
        </div>
      `;
    }

    function renderHistory() {
      return `
        <div class="min-h-screen bg-gradient-to-b from-blue-100 via-purple-100 to-pink-100 p-6">
          <div class="max-w-7xl mx-auto">
            ${renderHeader()}

            <div class="bg-white rounded-2xl shadow-2xl p-6 border-4 border-purple-300">
              <h2 class="text-2xl font-bold text-gray-800 mb-4">Your Contest History</h2>
              <p class="text-gray-600">Coming soon: View all your past contests and stats!</p>
            </div>
          </div>
        </div>
      `;
    }

    function renderCreateContest() {
      return `
        <div class="min-h-screen bg-gradient-to-b from-blue-100 via-purple-100 to-pink-100 p-6 relative">
          <div class="fixed inset-0 pointer-events-none opacity-10 overflow-hidden">
            <div class="absolute top-10 left-10 text-6xl">ğŸª¸</div>
            <div class="absolute top-40 right-20 text-5xl">ğŸš</div>
            <div class="absolute bottom-20 left-1/4 text-7xl">ğŸŒŠ</div>
          </div>

          <div class="max-w-7xl mx-auto relative z-10">
            ${renderHeader()}

            <!-- Safeguards Notice -->
            <div class="bg-blue-50 border-2 border-blue-300 rounded-lg p-4 mb-6">
              <h3 class="font-bold text-blue-900 mb-2">ğŸ›¡ï¸ Season 0 Safeguards Active</h3>
              <div class="text-sm text-blue-800 space-y-1">
                <p>â€¢ <strong>Whitelist Required:</strong> Only whitelisted addresses can participate</p>
                <p>â€¢ <strong>Token Gate:</strong> Minimum 20,000 $NEYNARTODES required</p>
                <p>â€¢ <strong>Reply Quality:</strong> Minimum 4 words per reply to prevent spam</p>
                <p>â€¢ <strong>Trade Volume Cap:</strong> $20 max for NEYNARTODES, or â‰¤ prize for custom token</p>
              </div>
            </div>

            <div class="bg-white rounded-2xl shadow-2xl p-8 border-4 border-purple-300">
              <h2 class="text-3xl font-black text-purple-800 mb-6">ğŸ‰ Create New Contest ğŸ‰</h2>

              <div class="space-y-6">
                <!-- Contest Period -->
                <div class="p-6 bg-purple-50 rounded-xl border-2 border-purple-200">
                  <h3 class="text-xl font-bold text-purple-800 mb-4">ğŸ“… Contest Period</h3>

                  <div class="mb-4">
                    <label class="block text-sm font-semibold text-gray-700 mb-2">Start Mode</label>
                    <div class="flex gap-3">
                      <button id="startNow" class="flex-1 py-2 rounded-lg font-semibold transition-colors ${state.startMode === 'now' ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-600'}">
                        Start Now
                      </button>
                      <button id="startScheduled" class="flex-1 py-2 rounded-lg font-semibold transition-colors ${state.startMode === 'scheduled' ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-600'}">
                        Schedule
                      </button>
                    </div>
                  </div>

                  ${state.startMode === 'scheduled' ? `
                    <div class="mb-4">
                      <label class="block text-sm font-semibold text-gray-700 mb-2">Start Date & Time</label>
                      <input type="datetime-local" id="startDate" value="${state.startDate}" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                    </div>
                  ` : ''}

                  <div class="mb-4">
                    <label class="block text-sm font-semibold text-gray-700 mb-2">Contest Duration</label>
                    <div class="grid grid-cols-2 gap-3">
                      <div>
                        <label class="block text-xs text-gray-600 mb-1">Hours</label>
                        <input type="number" id="durationHours" value="${state.durationHours}" min="0" max="720" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      </div>
                      <div>
                        <label class="block text-xs text-gray-600 mb-1">Minutes</label>
                        <input type="number" id="durationMinutes" value="${state.durationMinutes}" min="0" max="59" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      </div>
                    </div>
                    <p class="text-xs text-gray-600 mt-2">â±ï¸ Minimum duration: 30 minutes</p>
                  </div>

                  ${state.startMode === 'scheduled' && state.startDate && state.durationHours !== '' && state.durationMinutes !== '' ? `
                    <div class="bg-purple-100 p-3 rounded-lg">
                      <p class="text-xs text-purple-800 font-semibold mb-1">ğŸ“… Contest Timeline:</p>
                      <p class="text-sm text-purple-900">
                        <strong>Starts:</strong> ${new Date(state.startDate).toLocaleString()}<br/>
                        <strong>Duration:</strong> ${state.durationHours}h ${state.durationMinutes}m<br/>
                        <strong>Ends:</strong> ${(() => {
                          const start = new Date(state.startDate);
                          const hours = parseInt(state.durationHours) || 0;
                          const minutes = parseInt(state.durationMinutes) || 0;
                          const end = new Date(start.getTime() + (hours * 60 + minutes) * 60 * 1000);
                          return end.toLocaleString();
                        })()}
                      </p>
                    </div>
                  ` : state.startMode === 'now' && state.durationHours !== '' && state.durationMinutes !== '' ? `
                    <div class="bg-purple-100 p-3 rounded-lg">
                      <p class="text-xs text-purple-800 font-semibold mb-1">ğŸ“… Contest Duration:</p>
                      <p class="text-sm text-purple-900">
                        <strong>Starts:</strong> Immediately upon launch<br/>
                        <strong>Duration:</strong> ${state.durationHours}h ${state.durationMinutes}m
                      </p>
                    </div>
                  ` : ''}
                </div>

                <!-- Prize Settings -->
                <div class="p-6 bg-green-50 rounded-xl border-2 border-green-200">
                  <h3 class="text-xl font-bold text-green-800 mb-4">ğŸ Prize (Token Only)</h3>

                  <div class="space-y-4">
                    <div class="relative">
                      <label class="block text-sm font-semibold text-gray-700 mb-2">Search Token</label>
                      <input type="text" id="prizeTokenSearch" value="${state.prizeTokenSearch}" placeholder="USDC, ETH, NEYNARTODES..." class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      ${state.showPrizeTokenSuggestions ? `
                        <div class="absolute z-10 w-full mt-1 bg-white border-2 border-purple-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto">
                          ${searchTokens(state.prizeTokenSearch).map((token, idx) => `
                            <button onclick="selectPrizeToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-purple-50 border-b border-gray-100 transition-colors flex items-center gap-3">
                              <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-purple-200" onerror="this.src='https://via.placeholder.com/40/9333ea/ffffff?text=${token.ticker[0]}'" />
                              <div class="flex-1">
                                <div class="font-semibold text-gray-800">${token.name} <span class="text-purple-600">(${token.ticker})</span></div>
                                <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
                              </div>
                              <div class="text-right">
                                <div class="text-xs text-gray-600">Market Cap</div>
                                <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
                              </div>
                            </button>
                          `).join('')}
                        </div>
                      ` : ''}
                    </div>

                    ${state.prizeTokenAddress ? `
                      <div class="bg-gradient-to-r from-purple-50 to-pink-50 p-4 rounded-lg border-2 border-purple-200 flex items-center gap-3">
                        <img src="${state.prizeTokenImage}" alt="${state.prizeTokenTicker}" class="w-12 h-12 rounded-full object-cover border-2 border-purple-400 shadow-lg" onerror="this.src='https://via.placeholder.com/48/9333ea/ffffff?text=${state.prizeTokenTicker[0]}'" />
                        <div class="flex-1">
                          <div class="text-xs text-purple-600 font-semibold mb-1">âœ“ Selected Prize Token</div>
                          <div class="font-bold text-purple-900 text-lg">${state.prizeTokenTicker}</div>
                          <div class="text-xs text-gray-500 font-mono">${state.prizeTokenAddress.substring(0, 10)}...${state.prizeTokenAddress.substring(38)}</div>
                        </div>
                      </div>
                    ` : ''}

                    <div>
                      <label class="block text-sm font-semibold text-gray-700 mb-2">Prize Amount</label>
                      <input type="number" id="prizeTokenAmount" value="${state.prizeTokenAmount}" placeholder="1000" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                    </div>
                  </div>
                </div>

                <!-- Social Dynamics (Always ON) -->
                <div class="p-6 bg-pink-50 rounded-xl border-2 border-pink-200">
                  <div class="flex items-center justify-between mb-4">
                    <h3 class="text-xl font-bold text-pink-800">ğŸ‘¥ Social Dynamics</h3>
                    <span class="px-4 py-2 rounded-lg font-semibold bg-purple-600 text-white">REQUIRED</span>
                  </div>

                  <div class="space-y-4">
                    <!-- Cast URL/Hash - REQUIRED -->
                    <div class="bg-yellow-50 p-4 rounded-lg border-2 border-yellow-300">
                      <label class="block text-sm font-semibold text-gray-700 mb-2">ğŸ“¢ Contest Cast URL <span class="text-red-500">*</span></label>
                      <input type="text" id="castHash" value="${state.castHash}" placeholder="https://warpcast.com/username/0x1234abcd or 0x1234abcd" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      <p class="text-xs text-yellow-700 mt-2">âš ï¸ <strong>Post your contest announcement on Warpcast first!</strong> Then paste the cast URL or hash here. Engagement (recasts, replies) on this cast determines eligible participants.</p>
                    </div>

                    <div class="grid grid-cols-3 gap-3">
                      <div>
                        <label class="block text-xs font-semibold text-gray-700 mb-2">Min Likes (0-1)</label>
                        <input type="number" id="minLikes" value="${state.minLikes}" min="0" max="1" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      </div>
                      <div>
                        <label class="block text-xs font-semibold text-gray-700 mb-2">Min Recasts (0-1)</label>
                        <input type="number" id="minRecasts" value="${state.minRecasts}" min="0" max="1" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      </div>
                      <div>
                        <label class="block text-xs font-semibold text-gray-700 mb-2">Min Replies</label>
                        <input type="number" id="minReplies" value="${state.minReplies}" min="0" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      </div>
                    </div>
                    <p class="text-xs text-pink-700 font-semibold">ğŸ“ Replies must have at least 4 words to count</p>
                  </div>
                </div>

                <!-- Tokenomics (Always ON - Trading Volume) -->
                <div class="p-6 bg-green-50 rounded-xl border-2 border-green-200">
                  <div class="flex items-center justify-between mb-4">
                    <h3 class="text-xl font-bold text-green-800">ğŸ’° Trading Volume Requirement</h3>
                    <span class="px-4 py-2 rounded-lg font-semibold bg-purple-600 text-white">REQUIRED</span>
                  </div>

                  <div class="space-y-4">
                    <!-- Default Token Info -->
                    <div class="bg-gradient-to-r from-green-50 to-emerald-50 p-4 rounded-lg border-2 border-green-200">
                      <div class="flex items-center gap-3">
                        <div class="w-12 h-12 rounded-full bg-purple-600 flex items-center justify-center text-white text-xl font-bold border-2 border-green-400 shadow-lg">ğŸ¦</div>
                        <div class="flex-1">
                          <div class="text-xs text-green-600 font-semibold mb-1">Default Token (FREE)</div>
                          <div class="font-bold text-green-900 text-lg">NEYNARTODES</div>
                          <div class="text-xs text-gray-500 font-mono">${CONFIG.CONTRACTS.neynartodes.substring(0, 10)}...${CONFIG.CONTRACTS.neynartodes.substring(38)}</div>
                        </div>
                      </div>
                    </div>

                    <!-- Custom Token Option -->
                    <div class="border-2 border-dashed border-green-300 rounded-lg p-4">
                      <div class="flex items-center gap-2 mb-3">
                        <input type="checkbox" id="useCustomToken" ${state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase() ? 'checked' : ''} class="w-5 h-5 rounded border-gray-300 text-purple-600 focus:ring-purple-500" />
                        <label for="useCustomToken" class="text-sm font-semibold text-gray-700">Use Custom Token (+0.005 ETH fee)</label>
                      </div>

                      <div id="customTokenSection" class="${state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase() ? '' : 'hidden'}">
                        <div class="relative mb-3">
                          <label class="block text-sm font-semibold text-gray-700 mb-2">Search Token</label>
                          <input type="text" id="tokenSearch" value="${state.tokenSearch}" placeholder="Search: USDC, ETH, BRETT..." class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                          ${state.showTokenSuggestions ? `
                            <div class="absolute z-10 w-full mt-1 bg-white border-2 border-green-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto">
                              ${searchTokens(state.tokenSearch).map((token, idx) => `
                                <button onclick="selectToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-green-50 border-b border-gray-100 transition-colors flex items-center gap-3">
                                  <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-green-200" onerror="this.src='https://via.placeholder.com/40/22c55e/ffffff?text=${token.ticker[0]}'" />
                                  <div class="flex-1">
                                    <div class="font-semibold text-gray-800">${token.name} <span class="text-green-600">(${token.ticker})</span></div>
                                    <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
                                  </div>
                                  <div class="text-right">
                                    <div class="text-xs text-gray-600">Market Cap</div>
                                    <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
                                  </div>
                                </button>
                              `).join('')}
                            </div>
                          ` : ''}
                        </div>

                        ${state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase() ? `
                          <div class="bg-gradient-to-r from-orange-50 to-yellow-50 p-4 rounded-lg border-2 border-orange-200 flex items-center gap-3">
                            <img src="${state.tokenImage}" alt="${state.tokenTicker}" class="w-12 h-12 rounded-full object-cover border-2 border-orange-400 shadow-lg" onerror="this.src='https://via.placeholder.com/48/22c55e/ffffff?text=${state.tokenTicker[0]}'" />
                            <div class="flex-1">
                              <div class="text-xs text-orange-600 font-semibold mb-1">âœ“ Custom Token (+0.005 ETH)</div>
                              <div class="font-bold text-orange-900 text-lg">${state.tokenTicker}</div>
                              <div class="text-xs text-gray-500 font-mono">${state.tokenAddress.substring(0, 10)}...${state.tokenAddress.substring(38)}</div>
                            </div>
                          </div>
                        ` : ''}
                      </div>
                    </div>

                    <!-- Trade Volume Input -->
                    <div>
                      <label class="block text-sm font-semibold text-gray-700 mb-2">Min Trade Volume ($)</label>
                      <input type="number" id="minTradeVolume" value="${state.minTradeVolume}" placeholder="0" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      <p class="text-xs text-gray-600 mt-1">Minimum volume traded during contest (NEYNARTODES: max $20, Custom token: max = prize amount)</p>
                    </div>

                    <div class="bg-blue-50 border-l-4 border-blue-400 p-3 rounded">
                      <p class="text-xs text-blue-800 font-semibold">
                        ğŸ’¡ <strong>NEYNARTODES:</strong> Max $20 volume (FREE) | <strong>Custom token:</strong> Volume â‰¤ prize amount (+0.005 ETH fee)
                      </p>
                    </div>
                  </div>
                </div>

                <!-- Winner Announcement -->
                <div class="p-6 bg-yellow-50 rounded-xl border-2 border-yellow-200">
                  <h3 class="text-xl font-bold text-yellow-800 mb-4">ğŸ’¬ Winner Announcement</h3>
                  <label class="block text-sm font-semibold text-gray-700 mb-2">Custom Message</label>
                  <textarea id="customMessage" rows="3" placeholder="You just won our amazing contest!" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none">${state.customMessage}</textarea>
                </div>

                <!-- Pending Transaction Banner -->
                ${state.pendingTx ? `
                  <div class="mb-4 p-4 bg-yellow-100 border-2 border-yellow-400 rounded-xl animate-pulse">
                    <div class="flex items-center justify-center gap-3 text-yellow-800 font-bold">
                      <span class="animate-spin">â³</span>
                      <span>Transaction Pending...</span>
                    </div>
                    <a href="https://basescan.org/tx/${state.pendingTx}" target="_blank" class="block text-center text-sm text-blue-600 underline mt-2">
                      View on BaseScan â†’
                    </a>
                  </div>
                ` : ''}

                <!-- Launch Button -->
                <button id="launchButton" class="w-full flex items-center justify-center gap-3 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white px-8 py-6 rounded-2xl font-bold text-2xl transition-all shadow-2xl transform hover:scale-105 ${state.pendingTx ? 'opacity-50 cursor-not-allowed' : ''}" ${state.pendingTx ? 'disabled' : ''}>
                  ${state.pendingTx ? 'â³ LAUNCHING...' : 'â–¶ï¸ LAUNCH CONTEST'}
                </button>
                <p class="text-center text-sm text-gray-600">
                  âš ï¸ Prize will be locked in escrow smart contract
                </p>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // ===== DROPDOWN HELPERS =====
    function updatePrizeTokenDropdown() {
      const container = document.getElementById('prizeTokenSearch')?.parentElement;
      if (!container) return;

      // Remove old dropdown if exists
      const oldDropdown = container.querySelector('.absolute');
      if (oldDropdown) oldDropdown.remove();

      // Create new dropdown if needed
      if (state.showPrizeTokenSuggestions && state.prizeTokenSearch.length >= 2) {
        const results = searchTokens(state.prizeTokenSearch);
        const dropdown = document.createElement('div');
        dropdown.className = 'absolute z-10 w-full mt-1 bg-white border-2 border-purple-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto';
        dropdown.style.top = '100%';
        dropdown.style.left = '0';

        if (results.length === 0) {
          // Show "no results" message with option to use custom address
          dropdown.innerHTML = `
            <div class="p-4 text-center">
              <div class="text-gray-600 mb-2">No tokens found for "${state.prizeTokenSearch}"</div>
              <div class="text-xs text-gray-500 mb-3">
                Token not listed? You can use a custom address below after closing this.
              </div>
              <button onclick="showCustomPrizeToken()" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors text-sm font-semibold">
                â• Use Custom Token Address
              </button>
            </div>
          `;
        } else {
          dropdown.innerHTML = results.map((token, idx) => `
            <button onclick="selectPrizeToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-purple-50 border-b border-gray-100 transition-colors flex items-center gap-3">
              <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-purple-200" onerror="this.src='https://via.placeholder.com/40/9333ea/ffffff?text=${token.ticker[0]}'" />
              <div class="flex-1">
                <div class="font-semibold text-gray-800">${token.name} <span class="text-purple-600">(${token.ticker})</span></div>
                <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
              </div>
              <div class="text-right">
                <div class="text-xs text-gray-600">Market Cap</div>
                <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
              </div>
            </button>
          `).join('') + `
            <button onclick="showCustomPrizeToken()" class="w-full text-left px-4 py-3 bg-purple-50 hover:bg-purple-100 transition-colors border-t-2 border-purple-200">
              <div class="font-semibold text-purple-700 text-center">â• Use Custom Token Address</div>
            </button>
          `;
        }

        container.appendChild(dropdown);
      }
    }

    function updateTokenDropdown() {
      const container = document.getElementById('tokenSearch')?.parentElement;
      if (!container) return;

      // Remove old dropdown if exists
      const oldDropdown = container.querySelector('.absolute');
      if (oldDropdown) oldDropdown.remove();

      // Create new dropdown if needed
      if (state.showTokenSuggestions && state.tokenSearch.length >= 2) {
        const results = searchTokens(state.tokenSearch);
        const dropdown = document.createElement('div');
        dropdown.className = 'absolute z-10 w-full mt-1 bg-white border-2 border-green-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto';
        dropdown.style.top = '100%';
        dropdown.style.left = '0';

        if (results.length === 0) {
          // Show "no results" message with option to use custom address
          dropdown.innerHTML = `
            <div class="p-4 text-center">
              <div class="text-gray-600 mb-2">No tokens found for "${state.tokenSearch}"</div>
              <div class="text-xs text-gray-500 mb-3">
                Token not listed? You can use a custom address below after closing this.
              </div>
              <button onclick="showCustomToken()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-semibold">
                â• Use Custom Token Address
              </button>
            </div>
          `;
        } else {
          dropdown.innerHTML = results.map((token, idx) => `
            <button onclick="selectToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-green-50 border-b border-gray-100 transition-colors flex items-center gap-3">
              <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-green-200" onerror="this.src='https://via.placeholder.com/40/22c55e/ffffff?text=${token.ticker[0]}'" />
              <div class="flex-1">
                <div class="font-semibold text-gray-800">${token.name} <span class="text-green-600">(${token.ticker})</span></div>
                <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
              </div>
              <div class="text-right">
                <div class="text-xs text-gray-600">Market Cap</div>
                <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
              </div>
            </button>
          `).join('') + `
            <button onclick="showCustomToken()" class="w-full text-left px-4 py-3 bg-green-50 hover:bg-green-100 transition-colors border-t-2 border-green-200">
              <div class="font-semibold text-green-700 text-center">â• Use Custom Token Address</div>
            </button>
          `;
        }

        container.appendChild(dropdown);
      }
    }

    // ===== EVENT LISTENERS =====
    function attachEventListeners() {
      // Login page
      const connectButton = document.getElementById('connectButton');
      if (connectButton) {
        connectButton.onclick = connectWallet;
      }

      // View switching
      const viewCreate = document.getElementById('viewCreate');
      const viewHistory = document.getElementById('viewHistory');
      const viewLeaderboard = document.getElementById('viewLeaderboard');

      if (viewCreate) viewCreate.onclick = () => { state.currentView = 'create'; render(); };
      if (viewHistory) viewHistory.onclick = () => { state.currentView = 'history'; render(); };
      if (viewLeaderboard) viewLeaderboard.onclick = () => { state.currentView = 'leaderboard'; render(); };

      // Create contest form
      const startNow = document.getElementById('startNow');
      const startScheduled = document.getElementById('startScheduled');
      if (startNow) startNow.onclick = () => { state.startMode = 'now'; render(); };
      if (startScheduled) startScheduled.onclick = () => { state.startMode = 'scheduled'; render(); };

      // Custom token checkbox handler
      const useCustomToken = document.getElementById('useCustomToken');
      if (useCustomToken) {
        useCustomToken.onchange = (e) => {
          const customSection = document.getElementById('customTokenSection');
          if (e.target.checked) {
            customSection?.classList.remove('hidden');
          } else {
            customSection?.classList.add('hidden');
            // Reset to default NEYNARTODES
            state.tokenAddress = CONFIG.CONTRACTS.neynartodes;
            state.tokenTicker = 'NEYNARTODES';
            state.tokenImage = '';
            state.tokenSearch = '';
          }
        };
      }

      const prizeTokenSearch = document.getElementById('prizeTokenSearch');
      if (prizeTokenSearch) {
        prizeTokenSearch.oninput = (e) => {
          state.prizeTokenSearch = e.target.value;
          state.showPrizeTokenSuggestions = e.target.value.length >= 2;
          // Don't call render() - let dropdown stay open and update via direct DOM manipulation
          updatePrizeTokenDropdown();
        };
        prizeTokenSearch.onfocus = (e) => {
          if (e.target.value.length >= 2) {
            state.showPrizeTokenSuggestions = true;
            updatePrizeTokenDropdown();
          }
        };
      }

      const tokenSearch = document.getElementById('tokenSearch');
      if (tokenSearch) {
        tokenSearch.oninput = (e) => {
          state.tokenSearch = e.target.value;
          state.showTokenSuggestions = e.target.value.length >= 2;
          // Don't call render() - let dropdown stay open and update via direct DOM manipulation
          updateTokenDropdown();
        };
        tokenSearch.onfocus = (e) => {
          if (e.target.value.length >= 2) {
            state.showTokenSuggestions = true;
            updateTokenDropdown();
          }
        };
      }

      // Form inputs
      const startDate = document.getElementById('startDate');
      const endDate = document.getElementById('endDate');
      const durationHours = document.getElementById('durationHours');
      const durationMinutes = document.getElementById('durationMinutes');
      const castHash = document.getElementById('castHash');
      const minLikes = document.getElementById('minLikes');
      const minRecasts = document.getElementById('minRecasts');
      const minReplies = document.getElementById('minReplies');
      const customMessage = document.getElementById('customMessage');
      const prizeTokenAmount = document.getElementById('prizeTokenAmount');
      const minTradeVolume = document.getElementById('minTradeVolume');

      if (startDate) startDate.onchange = (e) => { state.startDate = e.target.value; render(); };
      if (endDate) endDate.onchange = (e) => { state.endDate = e.target.value; };
      if (durationHours) {
        durationHours.oninput = (e) => {
          state.durationHours = e.target.value;
        };
        durationHours.onchange = (e) => {
          state.durationHours = e.target.value;
          render();
        };
        durationHours.onblur = () => { render(); };
      }
      if (durationMinutes) {
        durationMinutes.oninput = (e) => {
          state.durationMinutes = e.target.value;
        };
        durationMinutes.onchange = (e) => {
          state.durationMinutes = e.target.value;
          render();
        };
        durationMinutes.onblur = () => { render(); };
      }
      if (castHash) castHash.oninput = (e) => { state.castHash = e.target.value; };
      if (minLikes) minLikes.oninput = (e) => { state.minLikes = e.target.value; };
      if (minRecasts) minRecasts.oninput = (e) => { state.minRecasts = e.target.value; };
      if (minReplies) minReplies.oninput = (e) => { state.minReplies = e.target.value; };
      if (customMessage) customMessage.oninput = (e) => { state.customMessage = e.target.value; };
      if (prizeTokenAmount) prizeTokenAmount.oninput = (e) => { state.prizeTokenAmount = e.target.value; };
      if (minTradeVolume) minTradeVolume.oninput = (e) => { state.minTradeVolume = e.target.value; };

      const launchButton = document.getElementById('launchButton');
      if (launchButton) {
        launchButton.onclick = async () => {
          try {
            console.log('ğŸ”˜ Launch button clicked');

            // Check if dev wallet (unlimited contest launches)
            const isDev = isDevWallet(state.userAddress);

          // Check if user already launched a contest today (skip for dev wallet)
          if (!isDev) {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

            if (state.lastLaunchDate) {
              const lastLaunch = new Date(state.lastLaunchDate);
              const lastLaunchDay = new Date(lastLaunch.getFullYear(), lastLaunch.getMonth(), lastLaunch.getDate());

              if (today.getTime() === lastLaunchDay.getTime()) {
                alert('ğŸš« Daily Contest Limit Reached!\n\nYou can only launch 1 contest per day per wallet.\n\nThis prevents leaderboard farming.\n\nYour last launch: ' + lastLaunch.toLocaleString() + '\n\nTry again tomorrow!');
                return;
              }
            }
          }

          // Validate duration
          const hours = parseInt(state.durationHours) || 0;
          const minutes = parseInt(state.durationMinutes) || 0;
          const totalMinutes = hours * 60 + minutes;

          if (totalMinutes < 30) {
            alert('Contest duration must be at least 30 minutes!\n\nCurrent duration: ' + totalMinutes + ' minutes\nRequired: 30 minutes minimum');
            return;
          }

          // Validate scheduled start date
          if (state.startMode === 'scheduled' && !state.startDate) {
            alert('Please set contest start date!');
            return;
          }

          if (!state.prizeTokenAddress || !state.prizeTokenAmount) {
            alert('Please select a prize token and enter the amount!');
            return;
          }

          // Cast hash is ALWAYS required
          if (!state.castHash) {
            alert('ğŸ“¢ Cast Required!\n\nPlease post your contest announcement on Warpcast first, then paste the cast URL or hash here.\n\nParticipants are determined by engagement on your cast (recasts, replies).');
            return;
          }

          // Extract and validate cast hash
          const extractedHash = extractCastHash(state.castHash);
          if (!extractedHash) {
            alert('âŒ Invalid cast URL/hash format.\n\nPlease enter a valid Warpcast URL or cast hash (e.g., 0x1234abcd...)');
            return;
          }

          // Validate cast exists
          const castValidation = await validateCast(extractedHash);
          if (!castValidation.valid) {
            alert(`âŒ Cast Validation Failed!\n\n${castValidation.error}\n\nMake sure you\'ve posted the cast and the URL/hash is correct.`);
            return;
          }

          // Check if this is the user's own cast (required for leaderboard integrity)
          if (!castValidation.isOwnCast && !isDev) {
            alert(`âŒ Not Your Cast!\n\nYou can only create contests on your own Warpcast posts.\n\nCast author: @${castValidation.author}\nYour wallet: ${state.userAddress.slice(0, 6)}...${state.userAddress.slice(-4)}\n\nTo prevent leaderboard gaming, contests must be on casts you authored.`);
            return;
          }

          // Show cast preview
          const confirmCast = confirm(`âœ… Cast Found!\n\nAuthor: @${castValidation.author} ${castValidation.isOwnCast ? '(Your cast âœ“)' : '(DEV MODE)'}\nText: "${castValidation.text}..."\n\nIs this the correct contest cast?`);
          if (!confirmCast) {
            return;
          }

          // Store the validated hash
          state.castHash = extractedHash;

          // Volume requirement validation
          const prizeAmount = parseFloat(state.prizeTokenAmount) || 0;
          const volumeReq = parseFloat(state.minTradeVolume) || 0;
          const isCustomToken = state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase();

          if (isCustomToken) {
            // Custom token: volume must be <= prize amount
            if (volumeReq > prizeAmount) {
              alert(`Trade volume requirement cannot exceed prize amount!\n\nPrize: ${prizeAmount} ${state.prizeTokenTicker}\nVolume Req: ${volumeReq}\n\nVolume must be â‰¤ ${prizeAmount}`);
              return;
            }
          } else {
            // Default NEYNARTODES: fixed cap at $20
            if (volumeReq > 20) {
              alert('Trade volume requirement cannot exceed $20 for NEYNARTODES!\n\nMax: $20\nYour value: $' + volumeReq + '\n\nPay for custom token to set higher volume requirements.');
              return;
            }
          }

          // Ensure token address defaults to NEYNARTODES if not set
          if (!state.tokenAddress) {
            state.tokenAddress = CONFIG.CONTRACTS.neynartodes;
            state.tokenTicker = 'NEYNARTODES';
          }

          // Calculate end time
          let startTime, endTime;
          if (state.startMode === 'scheduled') {
            startTime = new Date(state.startDate);
            endTime = new Date(startTime.getTime() + totalMinutes * 60 * 1000);
          } else {
            startTime = new Date();
            endTime = new Date(startTime.getTime() + totalMinutes * 60 * 1000);
          }

          // Record this launch
          state.lastLaunchDate = new Date();

          // Add to upcoming contests
          const newContest = {
            id: Date.now(),
            host: state.userAddress.substring(0, 6) + '...' + state.userAddress.substring(38),
            hostFull: state.userAddress,
            prize: state.prizeType === 'token' ? `${state.prizeTokenAmount} ${state.prizeTokenTicker}` : `NFT #${state.prizeNftId}`,
            startTime: startTime,
            endTime: endTime,
            duration: `${hours}h ${minutes}m`,
            socialEnabled: state.socialEnabled,
            tokenEnabled: state.tokenEnabled
          };

          // Launch contest on ContestEscrow contract
          // Contest is only added to state AFTER successful on-chain tx (inside launchContestOnChain)
          await launchContestOnChain(newContest, totalMinutes * 60);

          } catch (error) {
            console.error('âŒ Launch button error:', error);
            alert('âŒ Error launching contest:\n\n' + (error.message || error));
          }
        };
      }

      // Close dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        const prizeTokenSearch = document.getElementById('prizeTokenSearch');
        const tokenSearch = document.getElementById('tokenSearch');

        // Close prize token dropdown if clicking outside
        if (prizeTokenSearch && !prizeTokenSearch.parentElement.contains(e.target)) {
          state.showPrizeTokenSuggestions = false;
          updatePrizeTokenDropdown();
        }

        // Close tokenomics dropdown if clicking outside
        if (tokenSearch && !tokenSearch.parentElement.contains(e.target)) {
          state.showTokenSuggestions = false;
          updateTokenDropdown();
        }
      });
    }

    // ContestEscrow ABI for creating contests
    const CONTEST_ESCROW_ABI = [
      'function createContestETH(uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function createContestERC20(address _prizeToken, uint256 _prizeAmount, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function getContest(uint256 _contestId) external view returns (address host, address prizeToken, uint256 prizeAmount, uint256 startTime, uint256 endTime, string memory castId, address tokenRequirement, uint256 volumeRequirement, uint8 status, address winner)',
      'function customTokenFee() external view returns (uint256)',
      'function defaultToken() external view returns (address)',
      'event ContestCreated(uint256 indexed contestId, address indexed host, address prizeToken, uint256 prizeAmount, uint256 endTime, string castId)'
    ];

    const ERC20_ABI = [
      'function approve(address spender, uint256 amount) external returns (bool)',
      'function allowance(address owner, address spender) external view returns (uint256)',
      'function balanceOf(address account) external view returns (uint256)',
      'function decimals() external view returns (uint8)'
    ];

    // Launch contest on ContestEscrow contract
    async function launchContestOnChain(contest, durationSeconds) {
      try {
        console.log('ğŸš€ launchContestOnChain() called');

        // DEBUG: Show what provider we have
        alert('DEBUG: Starting launch...\n\nactiveEthProvider: ' + (window.activeEthProvider ? 'YES' : 'NO') + '\nwindow.ethereum: ' + (window.ethereum ? 'YES' : 'NO'));

        // Use the stored provider (Farcaster or MetaMask)
        const ethProvider = window.activeEthProvider || window.ethereum;
        if (!ethProvider) {
          alert('Wallet not connected! Please reconnect.');
          return;
        }

        alert('DEBUG: Got provider, creating Web3Provider...');

        const provider = new ethers.providers.Web3Provider(ethProvider);
        const signer = provider.getSigner();
        const signerAddress = await signer.getAddress();

        alert('DEBUG: Signer address: ' + signerAddress);

        const contestEscrow = new ethers.Contract(
          CONFIG.CONTRACTS.contestEscrow,
          CONTEST_ESCROW_ABI,
          signer
        );
        console.log('   ContestEscrow contract:', CONFIG.CONTRACTS.contestEscrow);

        // Get custom token fee and default token
        const customTokenFee = await contestEscrow.customTokenFee();
        const defaultToken = await contestEscrow.defaultToken();
        console.log('   Custom token fee:', ethers.utils.formatEther(customTokenFee), 'ETH');
        console.log('   Default token:', defaultToken);

        // Determine if we need to pay custom token fee
        const tokenRequirement = state.tokenEnabled ? state.tokenAddress : defaultToken;
        const isCustomToken = tokenRequirement.toLowerCase() !== defaultToken.toLowerCase();
        console.log('   Token requirement:', tokenRequirement);
        console.log('   Is custom token:', isCustomToken);

        // Sanitize volume requirement - ensure valid number
        let volumeRequirement = ethers.BigNumber.from(0);
        if (state.tokenEnabled && state.minTradeVolume) {
          try {
            // Clean the input - remove any invalid chars and limit decimals
            const cleanVolume = parseFloat(state.minTradeVolume).toFixed(18).replace(/\.?0+$/, '');
            if (cleanVolume && !isNaN(parseFloat(cleanVolume))) {
              volumeRequirement = ethers.utils.parseEther(cleanVolume);
            }
          } catch (e) {
            console.error('Invalid volume format:', e);
            volumeRequirement = ethers.BigNumber.from(0);
          }
        }
        console.log('   Volume requirement:', ethers.utils.formatEther(volumeRequirement));

        // Cast ID - validated cast hash from user input (REQUIRED)
        // Encode social requirements into castId: "castHash|R1L0P1" format
        // R = recast required (1 if minRecasts > 0), L = like required, P = reply required
        const reqRecast = parseInt(state.minRecasts) > 0 ? '1' : '0';
        const reqLike = parseInt(state.minLikes) > 0 ? '1' : '0';
        const reqReply = parseInt(state.minReplies) > 0 ? '1' : '0';
        const requirementsCode = `R${reqRecast}L${reqLike}P${reqReply}`;
        const castId = `${state.castHash}|${requirementsCode}`;
        console.log('   Cast ID to send (with requirements):', castId);
        console.log('   Requirements encoded: Recast=' + reqRecast + ', Like=' + reqLike + ', Reply=' + reqReply);
        if (!state.castHash || !state.castHash.startsWith('0x')) {
          console.error('âŒ Invalid cast hash - empty or doesnt start with 0x');
          alert('âŒ Invalid cast hash. Please start over and enter a valid cast URL/hash.');
          return;
        }

        let tx;

        if (state.prizeType === 'token') {
          // Check if prize is ETH (address(0) or WETH)
          const isETHPrize = state.prizeTokenAddress.toLowerCase() === '0x0000000000000000000000000000000000000000' ||
                            state.prizeTokenAddress.toLowerCase() === '0x4200000000000000000000000000000000000006'; // WETH on Base

          console.log('   Prize type: token');
          console.log('   Is ETH prize:', isETHPrize);
          console.log('   Prize token ticker:', state.prizeTokenTicker);

          if (isETHPrize || state.prizeTokenTicker === 'ETH') {
            // ETH prize - call createContestETH
            // Sanitize prize amount
            const cleanPrize = parseFloat(state.prizeTokenAmount).toFixed(18).replace(/\.?0+$/, '');
            if (!cleanPrize || isNaN(parseFloat(cleanPrize))) {
              alert('âŒ Invalid prize amount. Please enter a valid number.');
              return;
            }
            const prizeAmount = ethers.utils.parseEther(cleanPrize);
            const totalValue = isCustomToken ? prizeAmount.add(customTokenFee) : prizeAmount;

            console.log('ğŸ“ Calling createContestETH with:');
            console.log('   _duration:', durationSeconds);
            console.log('   _castId:', castId);
            console.log('   _tokenRequirement:', tokenRequirement);
            console.log('   _volumeRequirement:', volumeRequirement.toString());
            console.log('   value (ETH):', ethers.utils.formatEther(totalValue));

            alert(`ğŸ”’ Launching Contest!\n\nPrize: ${state.prizeTokenAmount} ETH\nDuration: ${Math.floor(durationSeconds / 60)} minutes\n${isCustomToken ? `Custom Token Fee: ${ethers.utils.formatEther(customTokenFee)} ETH\n` : ''}\nConfirm in MetaMask to lock your prize!`);

            console.log('â³ Waiting for MetaMask confirmation...');
            tx = await contestEscrow.createContestETH(
              durationSeconds,
              castId,
              tokenRequirement,
              volumeRequirement,
              { value: totalValue }
            );
            console.log('âœ… MetaMask confirmed! TX:', tx.hash);
          } else {
            // ERC20 prize - need to approve then call createContestERC20
            const prizeToken = new ethers.Contract(state.prizeTokenAddress, ERC20_ABI, signer);

            // Get decimals and parse amount
            let decimals;
            try {
              decimals = await prizeToken.decimals();
            } catch {
              decimals = 18; // Default to 18 decimals
            }
            // Sanitize prize amount - limit to token's decimal places
            const cleanPrize = parseFloat(state.prizeTokenAmount).toFixed(decimals).replace(/\.?0+$/, '');
            if (!cleanPrize || isNaN(parseFloat(cleanPrize))) {
              alert('âŒ Invalid prize amount. Please enter a valid number.');
              return;
            }
            const prizeAmount = ethers.utils.parseUnits(cleanPrize, decimals);

            // Check allowance
            const userAddress = await signer.getAddress();
            const allowance = await prizeToken.allowance(userAddress, CONFIG.CONTRACTS.contestEscrow);

            if (allowance.lt(prizeAmount)) {
              alert(`ğŸ“ Approval Required!\n\nFirst, approve ${state.prizeTokenAmount} ${state.prizeTokenTicker} for the contest.\n\nConfirm in MetaMask...`);

              const approveTx = await prizeToken.approve(CONFIG.CONTRACTS.contestEscrow, prizeAmount);
              await approveTx.wait();

              alert('âœ… Approval confirmed! Now creating contest...');
            }

            const ethValue = isCustomToken ? customTokenFee : ethers.BigNumber.from(0);

            console.log('ğŸ“ Calling createContestERC20 with:');
            console.log('   _prizeToken:', state.prizeTokenAddress);
            console.log('   _prizeAmount:', prizeAmount.toString());
            console.log('   _duration:', durationSeconds);
            console.log('   _castId:', castId);
            console.log('   _tokenRequirement:', tokenRequirement);
            console.log('   _volumeRequirement:', volumeRequirement.toString());
            console.log('   value (ETH for fee):', ethers.utils.formatEther(ethValue));

            alert(`ğŸ”’ Launching Contest!\n\nPrize: ${state.prizeTokenAmount} ${state.prizeTokenTicker}\nDuration: ${Math.floor(durationSeconds / 60)} minutes\n${isCustomToken ? `Custom Token Fee: ${ethers.utils.formatEther(customTokenFee)} ETH\n` : ''}\nConfirm in MetaMask to lock your prize!`);

            console.log('â³ Waiting for MetaMask confirmation...');
            tx = await contestEscrow.createContestERC20(
              state.prizeTokenAddress,
              prizeAmount,
              durationSeconds,
              castId,
              tokenRequirement,
              volumeRequirement,
              { value: ethValue }
            );
            console.log('âœ… MetaMask confirmed! TX:', tx.hash);
          }
        } else {
          // NFT prize - not supported in current contract
          alert('âŒ NFT prizes are not yet supported.\n\nPlease use token prizes for now.');
          return;
        }

        console.log('ğŸ“¤ Transaction submitted:', tx.hash);

        // Show persistent notification while waiting
        const txUrl = `https://basescan.org/tx/${tx.hash}`;
        state.pendingTx = tx.hash;
        render();

        const receipt = await tx.wait();
        console.log('âœ… Transaction confirmed:', receipt.transactionHash);
        console.log('ğŸ“œ Receipt events:', receipt.events);
        console.log('ğŸ“œ Receipt logs:', receipt.logs);

        // Parse contest ID from event
        let contestId = 'Unknown';

        // Try method 1: Find parsed event (ethers Contract auto-parses if ABI has event)
        const contestCreatedEvent = receipt.events?.find(e => e.event === 'ContestCreated');
        if (contestCreatedEvent?.args?.contestId) {
          contestId = contestCreatedEvent.args.contestId.toString();
          console.log('âœ… Found contestId from parsed event:', contestId);
        } else {
          // Method 2: Parse from raw logs using contract interface
          // ContestCreated(uint256 indexed contestId, address indexed host, ...)
          const iface = new ethers.utils.Interface(CONTEST_ESCROW_ABI);
          for (const log of receipt.logs || []) {
            try {
              const parsed = iface.parseLog(log);
              if (parsed.name === 'ContestCreated') {
                contestId = parsed.args.contestId.toString();
                console.log('âœ… Found contestId via interface.parseLog:', contestId);
                break;
              }
            } catch (e) {
              // Log doesn't match our event, skip
            }
          }

          // Method 3: Direct topic parsing as last resort
          if (contestId === 'Unknown' && receipt.logs?.length > 0) {
            const contestCreatedTopic = ethers.utils.id('ContestCreated(uint256,address,address,uint256,uint256,string)');
            const eventLog = receipt.logs.find(log => log.topics[0] === contestCreatedTopic);
            if (eventLog && eventLog.topics[1]) {
              contestId = ethers.BigNumber.from(eventLog.topics[1]).toString();
              console.log('âœ… Found contestId from raw topic:', contestId);
            } else {
              console.log('âš ï¸ Could not find ContestCreated event');
              console.log('   Available logs:', receipt.logs.map(l => l.topics[0]));
            }
          }
        }

        // Clear pending tx
        state.pendingTx = null;

        // Store successful contest info
        const successInfo = {
          contestId,
          castHash: castId,
          txHash: receipt.transactionHash,
          timestamp: new Date().toISOString()
        };

        // Save to localStorage for persistence
        const launchedContests = JSON.parse(localStorage.getItem('neynartodes_launched_contests') || '[]');
        launchedContests.push(successInfo);
        localStorage.setItem('neynartodes_launched_contests', JSON.stringify(launchedContests));

        console.log('ğŸ‰ Contest created:', successInfo);

        // Add contest to state ONLY after successful on-chain tx
        contest.onChainId = contestId;
        state.upcomingContests.push(contest);
        state.upcomingContests.sort((a, b) => a.startTime - b.startTime);

        // Show success notification
        alert(`ğŸ‰ CONTEST LAUNCHED SUCCESSFULLY!\n\n` +
          `Contest ID: ${contestId}\n` +
          `Cast Hash: ${castId}\n` +
          `Prize: Locked in escrow âœ…\n\n` +
          `Your contest is now LIVE!\n` +
          `Winner selected via Chainlink VRF when it ends.\n\n` +
          `View on BaseScan:\n${txUrl}`);

        // Update last launch date
        state.lastLaunchDate = new Date();

        // Reset form only after successful launch
        state.prizeTokenAddress = '';
        state.prizeTokenAmount = '';
        state.prizeTokenTicker = '';
        state.prizeTokenImage = '';
        state.prizeTokenSearch = '';
        state.tokenAddress = '';
        state.tokenTicker = '';
        state.tokenImage = '';
        state.tokenSearch = '';
        state.castHash = '';
        state.customMessage = '';
        state.minLikes = '0';
        state.minRecasts = '0';
        state.minReplies = '0';
        state.minTradeVolume = '';

        render();
      } catch (error) {
        console.error('Contest launch error:', error);

        if (error.code === 4001) {
          alert('âŒ Transaction rejected by user');
        } else if (error.message?.includes('Prize required')) {
          alert('âŒ Prize amount required!\n\nPlease enter a prize amount greater than 0.');
        } else if (error.message?.includes('Include custom token fee')) {
          alert('âŒ Custom token fee required!\n\nUsing a custom token requirement costs 0.005 ETH.\nMake sure you have enough ETH for the fee.');
        } else if (error.message?.includes('Invalid duration')) {
          alert('âŒ Invalid duration!\n\nContest duration must be greater than 0.');
        } else {
          alert('âŒ Contest launch failed!\n\n' + (error.reason || error.message || 'Unknown error'));
        }
      }
    }

    // Feed the Neynartodes function - DEPRECATED (Clanker fees now go direct to Treasury)
    window.feedTheNeynartodes = async () => {
      alert('ğŸ¦ This feature has been retired!\n\nClanker fees now flow directly to the Treasury.\n\nNo manual collection needed anymore.');
    };

    // Make functions globally accessible for inline onclick handlers
    window.voteForHost = voteForHost;

    // Custom token prompt functions
    window.showCustomPrizeToken = () => {
      state.showPrizeTokenSuggestions = false;
      updatePrizeTokenDropdown();

      let address = prompt('Enter the token contract address:\n\n(e.g., 0x532f27101965dd16442E59d40670FaF5eBB142E4)');
      if (!address) return;

      // Trim whitespace and normalize
      address = address.trim();

      if (!address.startsWith('0x') || address.length !== 42) {
        alert(`Invalid address format.\n\nMust start with 0x and be 42 characters.\nYou entered: "${address}" (${address.length} chars)`);
        return;
      }

      const ticker = prompt('Enter the token symbol/ticker:\n\n(e.g., BRETT, USDC, FIRKIT)');
      if (!ticker) return;

      const name = prompt('Enter the token name (optional):', ticker);

      // Add custom token to database
      const customToken = {
        name: name || ticker,
        ticker: ticker.toUpperCase(),
        address: address.toLowerCase(),
        mcap: 1000000,
        supply: 1000000000,
        image: `https://via.placeholder.com/40/9333ea/ffffff?text=${ticker[0]}`
      };

      // Save to localStorage with 1-year expiration
      saveCustomToken(customToken);

      tokenDatabase.push(customToken);

      // Auto-select the custom token
      state.prizeTokenAddress = customToken.address;
      state.prizeTokenTicker = customToken.ticker;
      state.prizeTokenImage = customToken.image;
      state.prizeTokenSearch = customToken.name;
      render();
    };

    window.showCustomToken = () => {
      state.showTokenSuggestions = false;
      updateTokenDropdown();

      let address = prompt('Enter the token contract address:\n\n(e.g., 0x532f27101965dd16442E59d40670FaF5eBB142E4)');
      if (!address) return;

      // Trim whitespace and normalize
      address = address.trim();

      if (!address.startsWith('0x') || address.length !== 42) {
        alert(`Invalid address format.\n\nMust start with 0x and be 42 characters.\nYou entered: "${address}" (${address.length} chars)`);
        return;
      }

      const ticker = prompt('Enter the token symbol/ticker:\n\n(e.g., BRETT, USDC, FIRKIT)');
      if (!ticker) return;

      const name = prompt('Enter the token name (optional):', ticker);

      // Add custom token to database
      const customToken = {
        name: name || ticker,
        ticker: ticker.toUpperCase(),
        address: address.toLowerCase(),
        mcap: 1000000,
        supply: 1000000000,
        image: `https://via.placeholder.com/40/22c55e/ffffff?text=${ticker[0]}`
      };

      // Save to localStorage with 1-year expiration
      saveCustomToken(customToken);

      tokenDatabase.push(customToken);

      // Auto-select the custom token
      state.tokenAddress = customToken.address;
      state.tokenTicker = customToken.ticker;
      state.tokenImage = customToken.image;
      state.tokenMcap = customToken.mcap;
      state.tokenSearch = customToken.name;
      render();

      // Show caps info
      const basePercent = customToken.mcap < 10000 ? 0.01 : customToken.mcap < 20000 ? 0.005 : customToken.mcap < 1000000 ? 0.0025 : customToken.mcap < 10000000 ? 0.001 : 0.0005;
      const multiplier = getBadgeMultiplier(state.userBadges);
      const maxPercent = basePercent * multiplier;
      const maxTokens = Math.floor(customToken.supply * maxPercent);

      alert(`Custom token added!\n\nğŸ’° Market Cap: $${customToken.mcap.toLocaleString()}\nğŸ“Š Max Holdings: ${(maxPercent * 100).toFixed(2)}% of supply\n= ${maxTokens.toLocaleString()} ${customToken.ticker}\n\nğŸ¦ Your badge multiplier: ${multiplier}x\nğŸ’¸ Max trade volume: $500`);
    };

    window.selectPrizeToken = (idx) => {
      const results = searchTokens(state.prizeTokenSearch);
      if (results[idx]) {
        const token = results[idx];
        state.prizeTokenAddress = token.address;
        state.prizeTokenTicker = token.ticker;
        state.prizeTokenImage = token.image;
        state.prizeTokenSearch = token.name;
        state.showPrizeTokenSuggestions = false;
        render();
      }
    };

    window.selectToken = (idx) => {
      const results = searchTokens(state.tokenSearch);
      if (results[idx]) {
        const token = results[idx];
        state.tokenAddress = token.address;
        state.tokenTicker = token.ticker;
        state.tokenImage = token.image;
        state.tokenMcap = token.mcap;
        state.tokenSearch = token.name;
        state.showTokenSuggestions = false;
        render();

        // Show info about caps
        const basePercent = token.mcap < 10000 ? 0.01 : token.mcap < 20000 ? 0.005 : token.mcap < 1000000 ? 0.0025 : token.mcap < 10000000 ? 0.001 : 0.0005;
        const multiplier = getBadgeMultiplier(state.userBadges);
        const maxPercent = basePercent * multiplier;
        const maxTokens = Math.floor(token.supply * maxPercent);

        alert(`Token selected!\n\nğŸ’° Market Cap: $${token.mcap.toLocaleString()}\nğŸ“Š Max Holdings: ${(maxPercent * 100).toFixed(2)}% of supply\n= ${maxTokens.toLocaleString()} ${token.ticker}\n\nğŸ¦ Your badge multiplier: ${multiplier}x\nğŸ’¸ Max trade volume: $500`);
      }
    };

    // ===== INIT =====
    // DEBUG: Alert on page load
    alert('PAGE LOADED!\n\nJS is running.\nFarcasterSDK: ' + (window.FarcasterSDK ? 'YES' : 'NO'));

    // Load token list from Base on startup
    fetchBaseTokens().catch(err => console.warn('Token list fetch failed:', err));

    // Initial render
    render();
  </script>
</body>
</html>
