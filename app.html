<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Danng Neynartodes!! - Season 0</title>

  <!-- Farcaster Mini App Embed -->
  <meta name="fc:frame" content='{"version":"1","imageUrl":"https://frame-opal-eight.vercel.app/Neynartodes_1200x638_splash.png","button":{"title":"Launch NEYNARtodes","action":{"type":"launch_frame","name":"NEYNARtodes","url":"https://frame-opal-eight.vercel.app/app","splashImageUrl":"https://frame-opal-eight.vercel.app/Neynartodes_1200x638_splash.png","splashBackgroundColor":"#667eea"}}}' />

  <!-- Open Graph -->
  <meta property="og:title" content="NEYNARtodes - Season 0 Beta" />
  <meta property="og:description" content="Create contests on Farcaster!" />
  <meta property="og:image" content="https://frame-opal-eight.vercel.app/Neynartodes_1200x638_splash.png" />
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Vercel Analytics -->
  <script type="module">
    import { inject, track } from 'https://esm.sh/@vercel/analytics';
    inject();
    window.analytics = { track };
  </script>

  <!-- Farcaster Mini App SDK - loads and signals when ready -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    window.FarcasterSDK = sdk;
    await sdk.actions.ready();

    // Try to get context
    try {
      const context = await sdk.context;
      window.FarcasterContext = context;
      console.log('Farcaster context:', context);
      if (context?.user) {
        window.FarcasterUser = context.user;
        console.log('Farcaster user:', context.user);
      }
    } catch (e) {
      console.log('Could not get Farcaster context:', e);
    }

    // Signal that SDK is ready - main script will listen for this
    window.FarcasterSDKReady = true;
    window.dispatchEvent(new Event('farcaster-ready'));
    console.log('Farcaster Mini App SDK ready');
  </script>
  <style>
    /* ===== MODERN DARK THEME FOUNDATION ===== */
    :root {
      /* Base colors */
      --bg-primary: #0a0a0f;
      --bg-secondary: #12121a;
      --bg-tertiary: #1a1a24;
      --bg-card: rgba(26, 26, 36, 0.8);

      /* Text colors */
      --text-primary: #f4f4f5;
      --text-secondary: #a1a1aa;
      --text-muted: #71717a;

      /* Accent - Violet/Purple */
      --accent: #8b5cf6;
      --accent-light: #a78bfa;
      --accent-dark: #7c3aed;
      --accent-glow: rgba(139, 92, 246, 0.3);

      /* Status colors */
      --success: #10b981;
      --success-glow: rgba(16, 185, 129, 0.2);
      --warning: #f59e0b;
      --warning-glow: rgba(245, 158, 11, 0.2);
      --error: #ef4444;
      --error-glow: rgba(239, 68, 68, 0.2);
      --info: #3b82f6;

      /* Borders */
      --border-subtle: rgba(255, 255, 255, 0.06);
      --border-light: rgba(255, 255, 255, 0.1);
      --border-accent: rgba(139, 92, 246, 0.3);

      /* Shadows */
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
      --shadow-glow: 0 0 40px var(--accent-glow);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    /* ===== GLASSMORPHISM CARDS ===== */
    .glass-card {
      background: var(--bg-card);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border-subtle);
      border-radius: 16px;
      transition: all 0.3s ease;
    }

    .glass-card:hover {
      border-color: var(--border-light);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .glass-card-accent {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(139, 92, 246, 0.05) 100%);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-accent);
      border-radius: 16px;
    }

    /* ===== BUTTONS ===== */
    .btn-primary {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
      color: white;
      font-weight: 600;
      padding: 12px 24px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 14px var(--accent-glow);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px var(--accent-glow);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-weight: 500;
      padding: 12px 24px;
      border-radius: 12px;
      border: 1px solid var(--border-light);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--border-accent);
    }

    .btn-ghost {
      background: transparent;
      color: var(--text-secondary);
      font-weight: 500;
      padding: 10px 16px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
    }

    .btn-ghost.active {
      background: rgba(139, 92, 246, 0.15);
      color: var(--accent-light);
    }

    /* ===== INPUTS ===== */
    .input-modern {
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 14px 16px;
      color: var(--text-primary);
      font-size: 14px;
      transition: all 0.2s ease;
      width: 100%;
    }

    .input-modern:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-glow);
    }

    .input-modern::placeholder {
      color: var(--text-muted);
    }

    /* ===== STAT CARDS ===== */
    .stat-card {
      background: var(--bg-card);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-subtle);
      border-radius: 16px;
      padding: 20px;
      position: relative;
      overflow: hidden;
    }

    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent) 0%, transparent 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .stat-card:hover::before {
      opacity: 1;
    }

    .stat-label {
      font-size: 12px;
      font-weight: 500;
      color: var(--accent-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--text-primary);
      line-height: 1.2;
    }

    .stat-value-sm {
      font-size: 20px;
    }

    .stat-subtitle {
      font-size: 13px;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    /* ===== TAGS/BADGES ===== */
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
    }

    .tag-accent {
      background: rgba(139, 92, 246, 0.15);
      color: var(--accent-light);
    }

    .tag-success {
      background: var(--success-glow);
      color: var(--success);
    }

    .tag-warning {
      background: var(--warning-glow);
      color: var(--warning);
    }

    .tag-error {
      background: var(--error-glow);
      color: var(--error);
    }

    /* ===== ANIMATIONS ===== */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 20px var(--accent-glow); }
      50% { box-shadow: 0 0 40px var(--accent-glow); }
    }

    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }

    .animate-fade-in {
      animation: fadeIn 0.4s ease-out;
    }

    .animate-pulse-glow {
      animation: pulse-glow 2s ease-in-out infinite;
    }

    /* ===== SKELETON LOADING ===== */
    .skeleton {
      background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: 8px;
    }

    /* ===== SCROLLBAR ===== */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* ===== TOAST NOTIFICATIONS ===== */
    #toast-container {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 90vw;
      pointer-events: none;
    }

    .toast {
      background: var(--bg-card);
      backdrop-filter: blur(20px);
      color: var(--text-primary);
      padding: 14px 18px;
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-line;
      animation: toastIn 0.3s ease-out;
      pointer-events: auto;
      max-width: 380px;
      border: 1px solid var(--border-subtle);
    }

    .toast.success { border-left: 3px solid var(--success); }
    .toast.error { border-left: 3px solid var(--error); }
    .toast.info { border-left: 3px solid var(--info); }
    .toast.warning { border-left: 3px solid var(--warning); }

    @keyframes toastIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes toastOut {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-20px); }
    }

    /* ===== UTILITY CLASSES ===== */
    .text-gradient {
      background: linear-gradient(135deg, var(--accent-light) 0%, var(--accent) 50%, #ec4899 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .glow-accent {
      box-shadow: var(--shadow-glow);
    }

    .divider {
      height: 1px;
      background: var(--border-subtle);
      margin: 16px 0;
    }
  </style>
</head>
<body>
  <div id="toast-container"></div>


  <div id="app"></div>

  <script>
    // Toast notification system (replaces alert() which is blocked in Farcaster iframe)
    // Set duration to 0 for persistent toast that stays until user closes it
    function showToast(message, type = 'info', duration = 5000) {
      const container = document.getElementById('toast-container');
      if (!container) return;

      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.style.position = 'relative';
      toast.style.whiteSpace = 'pre-line';

      // Add message text
      const textSpan = document.createElement('span');
      textSpan.textContent = message;
      toast.appendChild(textSpan);

      // Add close button for persistent toasts
      if (duration === 0) {
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'âœ•';
        closeBtn.style.cssText = 'position:absolute;top:8px;right:8px;background:none;border:none;color:inherit;font-size:16px;cursor:pointer;padding:4px 8px;opacity:0.7;';
        closeBtn.onmouseover = () => closeBtn.style.opacity = '1';
        closeBtn.onmouseout = () => closeBtn.style.opacity = '0.7';
        closeBtn.onclick = (e) => {
          e.stopPropagation();
          toast.style.animation = 'toastOut 0.3s ease-out forwards';
          setTimeout(() => toast.remove(), 300);
        };
        toast.appendChild(closeBtn);
        toast.style.paddingRight = '32px';
      }

      container.appendChild(toast);

      // Auto-remove after duration (skip if duration is 0 for persistent)
      if (duration > 0) {
        setTimeout(() => {
          toast.style.animation = 'toastOut 0.3s ease-out forwards';
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      // Click to dismiss (anywhere on toast)
      toast.onclick = () => {
        toast.style.animation = 'toastOut 0.3s ease-out forwards';
        setTimeout(() => toast.remove(), 300);
      };
    }

    // Check eligibility function
    async function checkEligibility(contestId, isNftContest = false) {
      showToast('Checking eligibility...', 'info');

      try {
        // Use FID if available, otherwise use wallet address
        let params = state.userFid
          ? `contestId=${contestId}&fid=${state.userFid}`
          : `contestId=${contestId}&address=${state.userAddress}`;

        // Add nft parameter for NFT contests
        if (isNftContest) {
          params += '&nft=true';
        }

        const response = await fetch(`/api/check-eligibility?${params}`);
        const data = await response.json();

        if (!response.ok) {
          showToast(`Error: ${data.error}`, 'error');
          return;
        }

        // Build result message
        const lines = [`Contest #${contestId} Eligibility:`];

        // Volume status
        if (data.volume.required > 0) {
          const volStatus = data.volume.met ? 'âœ…' : 'âŒ';
          lines.push(`${volStatus} Volume: $${data.volume.usd.toFixed(2)} / $${data.volume.required} required`);
        } else {
          lines.push('âœ… No volume requirement');
        }

        // Social status
        const socialReqs = [];
        if (data.social.requirements.recast) {
          socialReqs.push(data.social.recasted ? 'âœ… Recasted' : 'âŒ Need Recast');
        }
        if (data.social.requirements.like) {
          socialReqs.push(data.social.liked ? 'âœ… Liked' : 'âŒ Need Like');
        }
        if (data.social.requirements.reply) {
          socialReqs.push(data.social.replied ? 'âœ… Replied' : 'âŒ Need Reply (2+ words)');
        }

        if (socialReqs.length > 0) {
          lines.push(socialReqs.join(' | '));
        } else {
          lines.push('âœ… No social requirements');
        }

        // Final status
        if (data.qualified) {
          lines.push('ðŸŽ‰ YOU ARE QUALIFIED!');
          showToast(lines.join('\n'), 'success', 8000);
        } else {
          lines.push('Complete requirements above to qualify');
          showToast(lines.join('\n'), 'warning', 8000);
        }

      } catch (error) {
        console.error('Check eligibility error:', error);
        showToast('Failed to check eligibility', 'error');
      }
    }

    // Check eligibility for all active contests
    async function checkAllEligibility() {
      if (!state.userFid && !state.userAddress) {
        showToast('Please connect your wallet first', 'warning');
        return;
      }

      const activeContests = state.upcomingContests || [];
      if (activeContests.length === 0) {
        showToast('No active contests to check', 'info');
        return;
      }

      showToast(`Checking ${activeContests.length} contest(s)...`, 'info');

      const results = [];
      let qualifiedCount = 0;

      for (const contest of activeContests) {
        try {
          let params = state.userFid
            ? `contestId=${contest.contestId}&fid=${state.userFid}`
            : `contestId=${contest.contestId}&address=${state.userAddress}`;

          // Add nft parameter for NFT contests
          if (contest.isNft) {
            params += '&nft=true';
          }

          const response = await fetch(`/api/check-eligibility?${params}`);
          const data = await response.json();

          if (response.ok) {
            const status = data.qualified ? 'âœ…' : 'âŒ';
            let line = `${status} Contest #${contest.contestId}: `;

            // Build status details
            const details = [];

            // Social status
            if (data.social.requirements.recast || data.social.requirements.like || data.social.requirements.reply) {
              details.push(data.social.met ? 'Social âœ“' : 'Social âœ—');
            }

            // Volume status
            if (data.volume.required > 0) {
              details.push(data.volume.met ? 'Volume âœ“' : `Volume âœ— ($${data.volume.usd.toFixed(0)}/$${data.volume.required})`);
            }

            // If no requirements
            if (details.length === 0) {
              details.push('Open to all');
            }

            line += details.join(' | ');
            results.push(line);
            if (data.qualified) qualifiedCount++;
          } else {
            results.push(`âš ï¸ Contest #${contest.contestId}: Error`);
          }
        } catch (error) {
          results.push(`âš ï¸ Contest #${contest.contestId}: Failed`);
        }
      }

      // Show summary
      const summary = qualifiedCount > 0
        ? `ðŸŽ‰ You qualify for ${qualifiedCount}/${activeContests.length} contest(s)!`
        : `Complete requirements to qualify`;

      const message = `${results.join('\n')}\n\n${summary}`;
      const toastType = qualifiedCount > 0 ? 'success' : 'warning';
      // Use duration 0 for persistent toast - user must close it
      showToast(message, toastType, 0);
    }

    // Cast sharing modal functions - wrapper to read from data attributes (avoids URL escaping issues in onclick)
    function openCastModalFromData(button) {
      const contestId = parseInt(button.dataset.contestId);
      const prize = decodeURIComponent(button.dataset.prize || '');
      const hoursLeft = parseInt(button.dataset.hours);
      const minutesLeft = parseInt(button.dataset.minutes);
      const volumeReq = parseFloat(button.dataset.volume) || 0;
      const tokenSymbol = decodeURIComponent(button.dataset.token || '');
      const hostUsername = decodeURIComponent(button.dataset.host || '');
      const requireRecast = button.dataset.recast === 'true';
      const requireLike = button.dataset.like === 'true';
      const requireReply = button.dataset.reply === 'true';
      const castId = button.dataset.castId || '';
      const isNft = button.dataset.isNft === 'true';
      const nftImage = decodeURIComponent(button.dataset.nftImage || '');

      shareContest(contestId, prize, hoursLeft, minutesLeft, volumeReq, tokenSymbol, hostUsername, requireRecast, requireLike, requireReply, castId, isNft, nftImage);
    }

    async function shareContest(contestId, prize, hoursLeft, minutesLeft, volumeReq, tokenSymbol, hostUsername, requireRecast, requireLike, requireReply, castId, isNft, nftImage) {
      const hostTag = hostUsername ? `@${hostUsername}` : 'a host';

      // Build requirements string
      const reqs = [];
      if (requireRecast) reqs.push('ðŸ”„ Recast');
      if (requireLike) reqs.push('â¤ï¸ Like');
      if (requireReply) reqs.push('ðŸ’¬ Reply');
      if (volumeReq > 0) reqs.push(`ðŸ’° $${volumeReq} ${tokenSymbol} volume`);

      const reqsLine = reqs.length > 0 ? `ðŸ“‹ To Enter: ${reqs.join(' + ')}` : 'ðŸŽ Open to everyone!';
      const reactLine = reqs.length > 0 ? 'ðŸ‘‡ React to the cast below to enter!' : '';

      // Different prize line for NFT vs token
      const prizeLine = isNft ? `ðŸ–¼ï¸ NFT Prize: ${prize}` : `ðŸŽ Prize: ${prize}`;

      const text = `ðŸ¦Ž Contest #${contestId} by ${hostTag} is LIVE on NEYNARtodes! ðŸ”¥

${prizeLine}
â±ï¸ Time Left: ${hoursLeft}h ${minutesLeft}m
${reqsLine}
${reactLine}`;

      // Build embeds array
      const embeds = [];

      // Add NFT image as embed if available
      if (isNft && nftImage) {
        // Proxy through our server to avoid IPFS gateway 403 errors
        const proxyUrl = `https://frame-opal-eight.vercel.app/api/image?url=${encodeURIComponent(nftImage)}`;
        embeds.push(proxyUrl);
      }

      // Quote the original cast
      if (castId) {
        // castId may have format: "castHash|R1L0P1" or "castHash|R1L0P1|imageUrl"
        // Extract just the hash part (before any | character) for the embed URL
        const castHash = castId.split('|')[0];
        embeds.push(`https://warpcast.com/~/conversations/${castHash}`);
      }

      console.log('Sharing contest:', { contestId, isNft, embeds });

      // Use SDK composeCast
      const sdk = window.FarcasterSDK;
      if (sdk && sdk.actions && typeof sdk.actions.composeCast === 'function') {
        try {
          await sdk.actions.composeCast({
            text: text,
            embeds: embeds.length > 0 ? embeds : undefined
          });
          return;
        } catch (e) {
          console.log('composeCast failed, falling back to URL:', e);
        }
      }

      // Fallback: Build Warpcast compose URL
      let warpcastUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}`;
      embeds.forEach(embed => {
        warpcastUrl += `&embeds[]=${encodeURIComponent(embed)}`;
      });

      window.open(warpcastUrl, '_blank');
    }

  </script>

  <script>
    // ===== CONFIGURATION =====
    const CONFIG = {
      NEYNAR_API_KEY: 'AA2E0FC2-FDC0-466D-9EBA-4BCA968C9B1D',
      BASE_RPC_URL: 'https://base-mainnet.g.alchemy.com/v2/QooWtq9nKQlkeqKF_-rvC',
      CHAIN_ID: 8453, // Base chain ID
      CONTRACTS: {
        prizeNFT: '0x54E3972839A79fB4D1b0F70418141723d02E56e1', // V2 deployed 2025-12-01
        votingManager: '0x267Bd7ae64DA1060153b47d6873a8830dA4236f8', // V2 deployed 2025-11-29
        contestEscrow: '0x0A8EAf7de19268ceF2d2bA4F9000c60680cAde7A',
        nftContestEscrow: '0xFD6e84d4396Ecaa144771C65914b2a345305F922', // NFT Contest Escrow V3 deployed 2025-12-05 (supports restricted NFTs with two-step flow)
        treasury: '0xd4d84f3477eb482783aAB48F00e357C801c48928', // V2 deployed 2025-12-01
        neynartodes: '0x8de1622fe07f56cda2e2273e615a513f1d828b07'
      },
      SEASON_0_MIN_TOKENS: ethers.utils.parseEther('20000') // 20K tokens
    };

    // ===== NFT ABIs (needed for approval and transfer flow) =====
    const ERC721_ABI = [
      'function approve(address to, uint256 tokenId) external',
      'function getApproved(uint256 tokenId) external view returns (address)',
      'function setApprovalForAll(address operator, bool approved) external',
      'function isApprovedForAll(address owner, address operator) external view returns (bool)',
      'function ownerOf(uint256 tokenId) external view returns (address)',
      'function safeTransferFrom(address from, address to, uint256 tokenId) external',
      'function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external'
    ];

    const ERC1155_ABI = [
      'function setApprovalForAll(address operator, bool approved) external',
      'function isApprovedForAll(address account, address operator) external view returns (bool)',
      'function balanceOf(address account, uint256 id) external view returns (uint256)'
    ];

    // ===== SHARED RPC PROVIDER (reduces duplicate connections) =====
    const rpcProvider = new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC_URL);

    // ===== API CACHE (reduces duplicate Neynar calls) =====
    const apiCache = new Map();
    function getCached(key, ttlMs = 60000) {
      const entry = apiCache.get(key);
      if (entry && Date.now() - entry.ts < ttlMs) return entry.data;
      return null;
    }
    function setCache(key, data, ttlMs = 60000) {
      apiCache.set(key, { data, ts: Date.now() });
      // Cleanup old entries if cache gets too large
      if (apiCache.size > 500) {
        const now = Date.now();
        for (const [k, v] of apiCache) {
          if (now - v.ts > ttlMs * 2) apiCache.delete(k);
        }
      }
    }

    // Cached Neynar API helper
    async function neynarFetch(endpoint, cacheTtlMs = 30000) {
      const cacheKey = `neynar:${endpoint}`;
      const cached = getCached(cacheKey, cacheTtlMs);
      if (cached) return cached;

      const res = await fetch(`https://api.neynar.com/v2/farcaster/${endpoint}`, {
        headers: { 'api_key': CONFIG.NEYNAR_API_KEY }
      });
      if (!res.ok) throw new Error(`Neynar API error: ${res.status}`);
      const data = await res.json();
      setCache(cacheKey, data, cacheTtlMs);
      return data;
    }

    // Dev wallets with unlimited privileges (no contest launch limit, no voting limit)
    const DEV_WALLETS = [
      '0x78EeAA6F014667A339fCF8b4eCd74743366603fb', // MetaMask
      '0xAB4F21321A7A16eb57171994C7D7D1C808506E5d'  // Farcaster
    ];
    const DEV_WALLET = DEV_WALLETS[0]; // Keep for backwards compat
    const isDevWallet = (addr) => DEV_WALLETS.some(w => w.toLowerCase() === addr?.toLowerCase());

    // ===== STATE =====
    const state = {
      // Auth
      isLoggedIn: false,
      isCheckingWhitelist: false,
      walletStatus: null, // Status message during wallet connection
      isWhitelisted: false,
      hasTokens: false,
      userAddress: '',
      userFid: null,
      userProfile: null, // Full Farcaster profile {fid, username, displayName, pfpUrl}
      userBalance: '0',
      currentView: 'create', // 'create', 'leaderboard', 'history', 'suggestions'
      pendingTx: null, // Pending transaction hash

      // Voting
      votesRemaining: 10,
      votesUsedToday: 0,

      // Season & Prize Pool
      currentSeason: 0,
      seasonEndTime: null, // Unix timestamp when season ends
      prizePoolETH: 0,
      hostPoolETH: 0,  // On-chain host prize pool
      voterPoolETH: 0, // On-chain voter prize pool
      pendingClankerFees: '0', // Pending Clanker fees to collect
      totalTokensBurned: '0', // All-time Neynartodes burned from voting
      totalPrizesGiven: 0, // All-time prizes distributed (ETH)

      // Contest settings
      startMode: 'now', // 'now' or 'scheduled'
      startDate: '',
      endDate: '',
      durationHours: '1',
      durationMinutes: '0',
      lastLaunchDate: null, // Track last contest launch per wallet
      upcomingContests: [], // Array of scheduled contests
      prizeType: 'token', // 'token' or 'nft'
      prizeTokenAddress: '',
      prizeTokenAmount: '',
      prizeTokenTicker: '',
      prizeTokenImage: '',
      prizeTokenSearch: '',
      showPrizeTokenSuggestions: false,
      // NFT Prize fields
      prizeNftAddress: '',
      prizeNftTokenId: '',
      prizeNftImage: '',
      prizeNftName: '',
      prizeNftCollection: '',
      prizeNftType: '', // 'ERC721' or 'ERC1155'
      prizeNftAmount: '1', // For ERC1155
      loadingNftMetadata: false,
      // NFT Approval state (two-step flow for reliable wallet handling)
      nftApprovalStatus: 'none', // 'none', 'pending', 'approved'
      nftApprovalTxHash: '',

      // Social Dynamics
      socialEnabled: true,
      castHash: '',
      minLikes: '0',
      showRecentCasts: false, // Toggle for recent casts dropdown
      recentCasts: [], // User's last 3 casts
      loadingRecentCasts: false,
      minRecasts: '0',
      minReplies: '0',

      // Tokenomics (can be toggled off for 0.001 ETH, free for dev)
      tokenomicsEnabled: true, // Main toggle for tokenomics section
      tokenEnabled: true,
      useCustomTokenMode: false, // Whether user has checked "Custom token" checkbox
      tokenAddress: '0x8de1622fe07f56cda2e2273e615a513f1d828b07', // Default to NEYNARTODES
      tokenTicker: 'NEYNARTODES',
      tokenImage: '',
      tokenMcap: 0,
      tokenSearch: '',
      showTokenSuggestions: false,
      minTradeVolume: '20', // Default to $20 for NEYNARTODES

      // Custom Token Modal
      showCustomTokenModal: false,
      customTokenInput: '',
      customTokenTickerInput: '',

      // Winner announcement
      customMessage: '',

      // Cast sharing modal
      showCastModal: false,
      castModalText: '',
      castModalContestId: null,

      // Contest state
      contestLaunched: false,
      showCastPreview: false,
      announcementCast: '',
      contestActive: false,
      winner: null,
      totalParticipants: 0,
      contestStats: null,
      winnerCast: '',
      autoPosted: false,
      prizeReleased: false,

      // Leaderboard
      leaderboardData: [],

      // User badges
      userBadges: [],

      // Contest History
      historyData: [],
      historyLoading: false,
      historyError: null,
      historyTotal: 0,

      // Suggestions (anonymous)
      suggestions: [],
      suggestionText: '',
      suggestionsLoading: false
    };

    // ===== TOKEN DATABASE =====
    // Popular Base network tokens (fallback/cache)
    let tokenDatabase = [
      {
        name: 'Ethereum',
        ticker: 'ETH',
        address: '0x4200000000000000000000000000000000000006', // WETH on Base
        mcap: 450000000000,
        supply: 120000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png'
      },
      {
        name: 'USD Coin',
        ticker: 'USDC',
        address: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base
        mcap: 35000000000,
        supply: 35000000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png'
      },
      {
        name: 'Neynartodes',
        ticker: 'NEYNARTODES',
        address: '0x8de1622fe07f56cda2e2273e615a513f1d828b07',
        mcap: 85000,
        supply: 1000000000,
        image: 'https://i.imgur.com/placeholder-neynartodes.png'
      },
      {
        name: 'Dai Stablecoin',
        ticker: 'DAI',
        address: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb', // DAI on Base
        mcap: 5000000000,
        supply: 5000000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png'
      },
      {
        name: 'Aerodrome Finance',
        ticker: 'AERO',
        address: '0x940181a94A35A4569E4529A3CDfB74e38FD98631',
        mcap: 500000000,
        supply: 500000000,
        image: 'https://assets.coingecko.com/coins/images/31745/small/token.png'
      },
      {
        name: 'Brett',
        ticker: 'BRETT',
        address: '0x532f27101965dd16442E59d40670FaF5eBB142E4',
        mcap: 100000000,
        supply: 10000000000,
        image: 'https://assets.coingecko.com/coins/images/35711/small/brett.jpg'
      }
    ];

    // Cache for API token results
    let tokenCache = new Map();
    let lastFetchTime = 0;

    // ===== LOCALSTORAGE HELPERS FOR CUSTOM TOKENS =====
    const CUSTOM_TOKENS_KEY = 'neynartodes_custom_tokens';
    const ONE_YEAR_MS = 365 * 24 * 60 * 60 * 1000; // 1 year in milliseconds

    // Load custom tokens from localStorage (filters out expired ones)
    function loadCustomTokens() {
      try {
        const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
        if (!stored) return [];

        const data = JSON.parse(stored);
        const now = Date.now();

        // Filter out expired tokens (older than 1 year)
        const validTokens = data.filter(item => {
          return item.expiresAt && item.expiresAt > now;
        });

        // Save back the filtered list if we removed any expired tokens
        if (validTokens.length !== data.length) {
          localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(validTokens));
        }

        return validTokens.map(item => item.token);
      } catch (error) {
        console.warn('Failed to load custom tokens from localStorage:', error);
        return [];
      }
    }

    // Save a custom token to localStorage with 1-year expiration
    function saveCustomToken(token) {
      try {
        const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
        let data = stored ? JSON.parse(stored) : [];
        const now = Date.now();

        // Check if token already exists (by address)
        const existingIndex = data.findIndex(item =>
          item.token.address.toLowerCase() === token.address.toLowerCase()
        );

        if (existingIndex >= 0) {
          // Update expiration date for existing token
          data[existingIndex].expiresAt = now + ONE_YEAR_MS;
        } else {
          // Add new token with expiration
          data.push({
            token: token,
            expiresAt: now + ONE_YEAR_MS,
            addedAt: now
          });
        }

        localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(data));
        console.log(`Saved custom token ${token.ticker} to localStorage (expires in 1 year)`);
      } catch (error) {
        console.warn('Failed to save custom token to localStorage:', error);
      }
    }

    // ===== UTILITY FUNCTIONS =====
    // Fetch tokens from multiple sources for comprehensive Base token coverage
    async function fetchBaseTokens() {
      try {
        // First, load custom tokens from localStorage
        const customTokens = loadCustomTokens();
        if (customTokens.length > 0) {
          const existing = new Set(tokenDatabase.map(t => t.address.toLowerCase()));
          customTokens.forEach(token => {
            if (!existing.has(token.address.toLowerCase())) {
              tokenDatabase.push(token);
              existing.add(token.address.toLowerCase());
            }
          });
          console.log(`Loaded ${customTokens.length} custom tokens from localStorage`);
        }

        // Try multiple token list sources
        const tokenListUrls = [
          'https://tokens.coingecko.com/base/all.json', // CoinGecko Base tokens
          'https://raw.githubusercontent.com/Uniswap/default-token-list/main/build/uniswap-default.tokenlist.json', // Uniswap default
          'https://tokens.1inch.io/v1.1/8453' // 1inch Base tokens (chainId 8453)
        ];

        for (const url of tokenListUrls) {
          try {
            const response = await fetch(url);
            if (!response.ok) continue;

            const data = await response.json();
            let tokens = [];

            // Handle different token list formats
            if (data.tokens && Array.isArray(data.tokens)) {
              // Uniswap/CoinGecko format
              tokens = data.tokens.filter(t => t.chainId === 8453 || !t.chainId); // Base chainId is 8453
            } else if (typeof data === 'object' && !Array.isArray(data)) {
              // 1inch format (object with addresses as keys)
              tokens = Object.values(data);
            }

            if (tokens.length > 0) {
              const newTokens = tokens.map(token => ({
                name: token.name,
                ticker: token.symbol,
                address: (token.address || '').toLowerCase(),
                mcap: token.marketCap || 1000000,
                supply: token.totalSupply || 1000000000,
                image: token.logoURI || token.logo || `https://via.placeholder.com/40/9333ea/ffffff?text=${token.symbol?.[0] || '?'}`
              })).filter(t => t.address && t.address.startsWith('0x'));

              // Merge unique tokens
              const existing = new Set(tokenDatabase.map(t => t.address.toLowerCase()));
              newTokens.forEach(token => {
                if (!existing.has(token.address)) {
                  tokenDatabase.push(token);
                  existing.add(token.address);
                }
              });

              console.log(`Loaded ${newTokens.length} Base tokens from token list`);
              break; // Success, stop trying other sources
            }
          } catch (err) {
            console.warn('Failed to fetch from', url, err);
            continue; // Try next source
          }
        }
      } catch (error) {
        console.warn('Failed to fetch Base token lists, using fallback:', error);
      }
    }

    // Search tokens (synchronous search through cached database)
    function searchTokens(query) {
      if (!query || query.length < 2) return [];
      const q = query.toLowerCase();
      return tokenDatabase.filter(token =>
        token.name.toLowerCase().includes(q) ||
        token.ticker.toLowerCase().includes(q) ||
        token.address.toLowerCase().includes(q)
      ).slice(0, 20); // Limit to 20 results for performance
    }

    // Fetch NFT metadata from contract or Alchemy
    async function fetchNftMetadata(contractAddress, tokenId) {
      try {
        // First try to get metadata directly from contract tokenURI
        const erc721ABI = [
          'function tokenURI(uint256 tokenId) view returns (string)',
          'function name() view returns (string)',
          'function ownerOf(uint256 tokenId) view returns (address)',
          'function supportsInterface(bytes4 interfaceId) view returns (bool)'
        ];
        const erc1155ABI = [
          'function uri(uint256 tokenId) view returns (string)',
          'function balanceOf(address account, uint256 id) view returns (uint256)'
        ];

        const contract721 = new ethers.Contract(contractAddress, erc721ABI, rpcProvider);
        const contract1155 = new ethers.Contract(contractAddress, erc1155ABI, rpcProvider);

        let tokenUri = null;
        let nftType = '';
        let collectionName = '';

        // Check if ERC721 (interface ID: 0x80ac58cd)
        try {
          const is721 = await contract721.supportsInterface('0x80ac58cd');
          if (is721) {
            nftType = 'ERC721';
            tokenUri = await contract721.tokenURI(tokenId);
            collectionName = await contract721.name().catch(() => 'NFT Collection');
          }
        } catch (e) {
          // Not ERC721, try ERC1155
        }

        // Check if ERC1155 (interface ID: 0xd9b67a26)
        if (!nftType) {
          try {
            const is1155 = await contract721.supportsInterface('0xd9b67a26');
            if (is1155) {
              nftType = 'ERC1155';
              tokenUri = await contract1155.uri(tokenId);
              // ERC1155 URIs often have {id} placeholder
              tokenUri = tokenUri.replace('{id}', tokenId.toString().padStart(64, '0'));
              collectionName = await contract721.name().catch(() => 'NFT Collection');
            }
          } catch (e) {
            // Not ERC1155 either
          }
        }

        if (!tokenUri) {
          throw new Error('Could not fetch token URI - may not be a valid NFT');
        }

        // Convert IPFS URLs to gateway
        if (tokenUri.startsWith('ipfs://')) {
          tokenUri = tokenUri.replace('ipfs://', 'https://ipfs.io/ipfs/');
        }

        // Fetch metadata JSON
        const metadataResponse = await fetch(tokenUri);
        if (!metadataResponse.ok) throw new Error('Failed to fetch metadata');
        const metadata = await metadataResponse.json();

        // Get image URL
        let imageUrl = metadata.image || metadata.image_url || '';
        if (imageUrl.startsWith('ipfs://')) {
          imageUrl = imageUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');
        }

        return {
          success: true,
          name: metadata.name || `${collectionName} #${tokenId}`,
          collection: collectionName,
          image: imageUrl,
          type: nftType,
          description: metadata.description || '',
          attributes: metadata.attributes || [],
        };
      } catch (error) {
        console.error('NFT metadata fetch error:', error);
        return {
          success: false,
          error: error.message
        };
      }
    }

    // Handle NFT address/tokenId input and fetch metadata
    async function loadNftMetadata() {
      const address = state.prizeNftAddress.trim();
      const tokenId = state.prizeNftTokenId.trim();

      if (!address || !tokenId) {
        showToast('Enter both NFT contract address and Token ID', 'warning');
        return;
      }

      if (!ethers.utils.isAddress(address)) {
        showToast('Invalid contract address', 'error');
        return;
      }

      state.loadingNftMetadata = true;
      render();

      const result = await fetchNftMetadata(address, tokenId);

      state.loadingNftMetadata = false;

      if (result.success) {
        state.prizeNftImage = result.image;
        state.prizeNftName = result.name;
        state.prizeNftCollection = result.collection;
        state.prizeNftType = result.type;
        showToast(`Loaded: ${result.name}`, 'success');
        // Check if NFT is already approved
        await checkNftApprovalStatus();
      } else {
        state.prizeNftImage = '';
        state.prizeNftName = '';
        state.prizeNftCollection = '';
        state.prizeNftType = '';
        state.nftApprovalStatus = 'none';
        showToast(`Failed to load NFT: ${result.error}`, 'error');
      }

      render();
    }

    // Approve NFT for escrow (Step 1 of NFT contest creation)
    // This is a separate step to ensure the wallet properly sequences transactions
    async function approveNftForEscrow() {
      if (!state.prizeNftAddress || !state.prizeNftType) {
        showToast('Please load the NFT first', 'warning');
        return;
      }

      if (!state.userAddress) {
        showToast('Please connect your wallet first', 'error');
        return;
      }

      // Get the Ethereum provider from Farcaster SDK or fallback to window.ethereum
      let ethProvider = null;
      const sdk = window.FarcasterSDK;
      if (sdk && typeof sdk.wallet?.getEthereumProvider === 'function') {
        ethProvider = sdk.wallet.getEthereumProvider();
        if (ethProvider && typeof ethProvider.then === 'function') {
          ethProvider = await ethProvider;
        }
      }
      if (!ethProvider && window.ethereum) {
        ethProvider = window.ethereum;
      }
      if (!ethProvider) {
        showToast('Wallet provider not available', 'error');
        return;
      }

      state.nftApprovalStatus = 'pending';
      render();

      try {
        const signerAddress = state.userAddress;
        const tokenId = parseInt(state.prizeNftTokenId) || 0;

        console.log('NFT Approval Debug:', {
          nftAddress: state.prizeNftAddress,
          nftType: state.prizeNftType,
          tokenId: tokenId,
          signerAddress: signerAddress,
          escrowContract: CONFIG.CONTRACTS.nftContestEscrow
        });

        // Check if already approved
        const nftContract = new ethers.Contract(
          state.prizeNftAddress,
          state.prizeNftType === 'ERC721' ? ERC721_ABI : ERC1155_ABI,
          rpcProvider
        );

        let isAlreadyApproved = false;
        try {
          if (state.prizeNftType === 'ERC721') {
            const approved = await nftContract.getApproved(tokenId);
            const isApprovedForAll = await nftContract.isApprovedForAll(signerAddress, CONFIG.CONTRACTS.nftContestEscrow);
            console.log('ERC721 approval check:', { approved, isApprovedForAll });
            isAlreadyApproved = approved.toLowerCase() === CONFIG.CONTRACTS.nftContestEscrow.toLowerCase() || isApprovedForAll;
          } else {
            isAlreadyApproved = await nftContract.isApprovedForAll(signerAddress, CONFIG.CONTRACTS.nftContestEscrow);
            console.log('ERC1155 approval check:', { isAlreadyApproved });
          }
        } catch (checkErr) {
          console.log('Approval check error (may be normal for some NFTs):', checkErr.message);
        }

        if (isAlreadyApproved) {
          state.nftApprovalStatus = 'approved';
          showToast('NFT already approved! You can now create the contest.', 'success');
          render();
          return;
        }

        // Send approval transaction
        const approveIface = new ethers.utils.Interface(state.prizeNftType === 'ERC721' ? ERC721_ABI : ERC1155_ABI);
        const approveData = approveIface.encodeFunctionData('setApprovalForAll', [
          CONFIG.CONTRACTS.nftContestEscrow,
          true
        ]);

        const txParams = {
          from: signerAddress,
          to: state.prizeNftAddress,
          data: approveData
        };

        console.log('Sending approval tx with params:', txParams);
        console.log('Encoded data:', approveData);

        // Try to estimate gas first to catch errors early
        try {
          const gasEstimate = await rpcProvider.estimateGas({
            from: signerAddress,
            to: state.prizeNftAddress,
            data: approveData
          });
          console.log('Gas estimate:', gasEstimate.toString());
        } catch (gasErr) {
          console.error('Gas estimation failed:', gasErr.message);
          console.error('Full error:', gasErr);
          showToast(`Transaction would fail: ${gasErr.reason || gasErr.message}`, 'error');
          state.nftApprovalStatus = 'failed';
          render();
          return;
        }

        const approveTxHash = await ethProvider.request({
          method: 'eth_sendTransaction',
          params: [txParams]
        });

        console.log('NFT approval tx hash:', approveTxHash);
        state.nftApprovalTxHash = approveTxHash;
        showToast('Approval submitted! Waiting for confirmation...', 'info');
        render();

        // Wait for transaction to be mined
        let txReceipt = null;
        for (let i = 0; i < 60; i++) {
          try {
            const receipt = await rpcProvider.getTransactionReceipt(approveTxHash);
            if (receipt && receipt.blockNumber) {
              txReceipt = receipt;
              console.log('=== APPROVAL TX RECEIPT ===');
              console.log('Block number:', receipt.blockNumber);
              console.log('Status:', receipt.status, '(1=success, 0=failed)');
              console.log('Gas used:', receipt.gasUsed?.toString());
              console.log('From:', receipt.from);
              console.log('To:', receipt.to);
              console.log('Logs:', receipt.logs?.length || 0, 'events');
              if (receipt.status === 0) {
                console.error('APPROVAL TRANSACTION FAILED ON-CHAIN!');
                showToast('Approval transaction failed on-chain!', 'error');
                state.nftApprovalStatus = 'failed';
                render();
                return;
              }
              break;
            }
          } catch (e) {
            // Receipt not yet available
          }
          await new Promise(r => setTimeout(r, 2000));
        }

        if (!txReceipt) {
          console.warn('Could not get transaction receipt after 2 minutes');
        }

        // Verify approval is confirmed on-chain
        console.log('=== VERIFYING APPROVAL ON-CHAIN ===');
        console.log('Checking approval for:');
        console.log('  NFT Contract:', state.prizeNftAddress);
        console.log('  Owner:', signerAddress);
        console.log('  Operator (escrow):', CONFIG.CONTRACTS.nftContestEscrow);

        // Use shared rpcProvider instead of creating new one each iteration
        const verifyContract = new ethers.Contract(
          state.prizeNftAddress,
          state.prizeNftType === 'ERC721' ? ERC721_ABI : ERC1155_ABI,
          rpcProvider
        );

        for (let i = 0; i < 10; i++) {
          await new Promise(r => setTimeout(r, 2000));

          const nowApproved = await verifyContract.isApprovedForAll(signerAddress, CONFIG.CONTRACTS.nftContestEscrow);
          console.log(`Approval check attempt ${i + 1}: isApprovedForAll =`, nowApproved);
          if (nowApproved) {
            console.log('=== APPROVAL CONFIRMED ===');
            state.nftApprovalStatus = 'approved';
            showToast('NFT approved! You can now create the contest.', 'success');
            render();
            return;
          }
        }

        // Approval didn't confirm in time
        state.nftApprovalStatus = 'none';
        showToast('Approval may still be pending. Please try again or check BaseScan.', 'warning');
        render();

      } catch (error) {
        console.error('NFT approval error:', error);
        state.nftApprovalStatus = 'none';
        showToast('Failed to approve NFT: ' + (error.message || error), 'error');
        render();
      }
    }

    // Check if NFT is currently approved for escrow
    async function checkNftApprovalStatus() {
      if (!state.prizeNftAddress || !state.prizeNftType || !state.userAddress) {
        state.nftApprovalStatus = 'none';
        return;
      }

      try {
        const nftContract = new ethers.Contract(
          state.prizeNftAddress,
          state.prizeNftType === 'ERC721' ? ERC721_ABI : ERC1155_ABI,
          rpcProvider
        );

        const tokenId = parseInt(state.prizeNftTokenId) || 0;
        let isApproved = false;

        if (state.prizeNftType === 'ERC721') {
          const approved = await nftContract.getApproved(tokenId);
          const isApprovedForAll = await nftContract.isApprovedForAll(state.userAddress, CONFIG.CONTRACTS.nftContestEscrow);
          isApproved = approved.toLowerCase() === CONFIG.CONTRACTS.nftContestEscrow.toLowerCase() || isApprovedForAll;
        } else {
          isApproved = await nftContract.isApprovedForAll(state.userAddress, CONFIG.CONTRACTS.nftContestEscrow);
        }

        state.nftApprovalStatus = isApproved ? 'approved' : 'none';
      } catch (e) {
        console.error('Error checking NFT approval:', e);
        state.nftApprovalStatus = 'none';
      }
    }

    function getBadgeMultiplier(badges) {
      if (!badges || badges.length === 0) return 1;
      let multiplier = 1;
      badges.forEach(badge => {
        if (badge === 'gold') multiplier += 2;
        else if (badge === 'silver') multiplier += 1;
        else if (badge === 'bronze') multiplier += 0.5;
        else if (badge === 'purple') multiplier += 0.25;
      });
      return multiplier;
    }

    function getBadgeEmoji(badge) {
      if (badge === 'gold') return 'ðŸ¥‡';
      if (badge === 'silver') return 'ðŸ¥ˆ';
      if (badge === 'bronze') return 'ðŸ¥‰';
      if (badge === 'purple') return 'ðŸŸ£';
      if (badge === 'season0_beta') return 'ðŸ¦Ž';
      return '';
    }

    function getBadgeTitle(badge) {
      if (badge === 'gold') return 'Gold Badge';
      if (badge === 'silver') return 'Silver Badge';
      if (badge === 'bronze') return 'Bronze Badge';
      if (badge === 'purple') return 'Purple Badge';
      if (badge === 'season0_beta') return 'Season 0 Beta Tester - Forever OG';
      return badge;
    }

    // ===== SEASON 0 BETA BADGE TRACKING =====
    function getSeasonTesterBadges() {
      try {
        const stored = localStorage.getItem('season0_beta_participants');
        return stored ? JSON.parse(stored) : {};
      } catch (e) {
        return {};
      }
    }

    function awardSeasonBetaBadge(fid, username) {
      if (state.currentSeason === 0 || state.currentSeason === 1) {
        try {
          const badges = getSeasonTesterBadges();
          if (!badges[fid]) {
            badges[fid] = {
              username: username,
              awardedAt: Date.now(),
              season: state.currentSeason
            };
            localStorage.setItem('season0_beta_participants', JSON.stringify(badges));
            console.log(`ðŸ¦Ž Season 0 Beta badge awarded to @${username} (FID: ${fid})`);
          }
        } catch (e) {
          console.error('Failed to award Season 0 Beta badge:', e);
        }
      }
    }

    function hasSeasonBetaBadge(fid) {
      const badges = getSeasonTesterBadges();
      return !!badges[fid];
    }

    // ===== CAST VALIDATION =====
    // Extract cast hash and username from URL or raw hash
    // Returns { hash, username } - username is only set for farcaster.xyz URLs with short hashes
    function extractCastInfo(input) {
      if (!input) return { hash: null, username: null };
      input = input.trim();

      // Extract from Farcaster.xyz URL: https://farcaster.xyz/username/0x1234abcd
      // These use SHORT hashes that need to be resolved
      const farcasterMatch = input.match(/farcaster\.xyz\/([^/]+)\/(0x[a-fA-F0-9]+)/i);
      if (farcasterMatch) {
        const username = farcasterMatch[1].toLowerCase();
        const hash = farcasterMatch[2].toLowerCase();
        // farcaster.xyz uses short hashes (10 chars like 0x539e9184)
        // Full hashes are 66 chars (0x + 64 hex)
        const isShortHash = hash.length < 42;
        return { hash, username: isShortHash ? username : null };
      }

      // If it's already a hash (starts with 0x)
      if (input.startsWith('0x')) {
        return { hash: input.toLowerCase(), username: null };
      }

      // Extract from Warpcast URL: https://warpcast.com/username/0x1234abcd
      const warpcastMatch = input.match(/warpcast\.com\/[^/]+\/(0x[a-fA-F0-9]+)/i);
      if (warpcastMatch) {
        return { hash: warpcastMatch[1].toLowerCase(), username: null };
      }

      // Try to find any 0x hash in the string
      const hashMatch = input.match(/(0x[a-fA-F0-9]{8,})/i);
      if (hashMatch) {
        return { hash: hashMatch[1].toLowerCase(), username: null };
      }

      return { hash: null, username: null };
    }

    // Legacy function for backwards compatibility
    function extractCastHash(input) {
      return extractCastInfo(input).hash;
    }

    // Resolve a short hash to full hash by looking up user's recent casts
    async function resolveShortHash(shortHash, username) {
      try {
        console.log(`Resolving short hash ${shortHash} for user ${username}`);

        // First get the user's FID from username
        const userResponse = await fetch(`https://api.neynar.com/v2/farcaster/user/by_username?username=${username}`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        if (!userResponse.ok) {
          console.log('Could not find user:', username);
          return null;
        }

        const userData = await userResponse.json();
        const fid = userData.user?.fid;
        if (!fid) return null;

        // Fetch user's recent casts
        const castsResponse = await fetch(`https://api.neynar.com/v2/farcaster/feed/user/casts?fid=${fid}&limit=25`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        if (!castsResponse.ok) return null;

        const castsData = await castsResponse.json();

        // Find the cast that starts with the short hash
        const matchingCast = castsData.casts?.find(cast =>
          cast.hash.toLowerCase().startsWith(shortHash.toLowerCase())
        );

        if (matchingCast) {
          console.log(`Resolved ${shortHash} to full hash: ${matchingCast.hash}`);
          return matchingCast.hash;
        }

        console.log(`No cast found starting with ${shortHash}`);
        return null;
      } catch (e) {
        console.error('Error resolving short hash:', e);
        return null;
      }
    }

    // Validate cast exists via Neynar API
    // Can accept either a hash directly or a raw URL input (for short hash resolution)
    async function validateCast(castHashOrInput, rawInput = null) {
      try {
        let castHash = castHashOrInput;

        // If rawInput is provided, try to resolve short hashes from farcaster.xyz URLs
        if (rawInput) {
          const castInfo = extractCastInfo(rawInput);
          if (castInfo.username && castInfo.hash && castInfo.hash.length < 42) {
            // This is a short hash from farcaster.xyz - resolve it
            console.log(`Detected short hash ${castInfo.hash} from farcaster.xyz, resolving...`);
            const fullHash = await resolveShortHash(castInfo.hash, castInfo.username);
            if (fullHash) {
              castHash = fullHash;
            } else {
              return {
                valid: false,
                error: `Could not resolve short hash ${castInfo.hash} for user @${castInfo.username}.\n\nThe cast may be older than recent history. Try using the full Warpcast URL instead.`
              };
            }
          }
        }

        console.log('Validating cast hash:', castHash);

        const response = await fetch(`https://api.neynar.com/v2/farcaster/cast?identifier=${castHash}&type=hash`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        const data = await response.json();
        console.log('Neynar API response:', data);

        if (!response.ok || data.code === 'NotFound') {
          return {
            valid: false,
            error: `Cast not found for hash: ${castHash}\n\nMake sure you copied the full URL from Warpcast.\nNew casts may take a few seconds to be indexed.`
          };
        }

        if (data.cast) {
          const authorFid = data.cast.author?.fid;
          const authorUsername = data.cast.author?.username || 'unknown';

          // Check if the connected wallet owns this cast
          // Get author's verified addresses from Neynar
          let isOwnCast = false;
          let authorAddresses = [];

          if (authorFid && state.userAddress) {
            try {
              const verifyResponse = await fetch(`https://api.neynar.com/v2/farcaster/user/bulk?fids=${authorFid}`, {
                headers: {
                  'accept': 'application/json',
                  'api_key': CONFIG.NEYNAR_API_KEY
                }
              });
              const verifyData = await verifyResponse.json();

              if (verifyData.users && verifyData.users[0]) {
                // Get all verified addresses for this user
                authorAddresses = verifyData.users[0].verified_addresses?.eth_addresses || [];
                // Also check custody address
                if (verifyData.users[0].custody_address) {
                  authorAddresses.push(verifyData.users[0].custody_address);
                }

                // Check if connected wallet matches any of author's addresses
                const connectedLower = state.userAddress.toLowerCase();
                isOwnCast = authorAddresses.some(addr => addr.toLowerCase() === connectedLower);

                console.log('Author addresses:', authorAddresses);
                console.log('Connected wallet:', state.userAddress);
                console.log('Is own cast:', isOwnCast);
              }
            } catch (e) {
              console.error('Error checking cast ownership:', e);
              // If we can't verify, allow it but warn
            }
          }

          return {
            valid: true,
            cast: data.cast,
            hash: castHash, // Return the resolved full hash
            author: authorUsername,
            authorFid: authorFid,
            authorAddresses: authorAddresses,
            isOwnCast: isOwnCast,
            text: data.cast.text?.substring(0, 100) || ''
          };
        }

        return { valid: false, error: 'Invalid cast data returned from API' };
      } catch (e) {
        console.error('Cast validation error:', e);
        return { valid: false, error: `Network error validating cast: ${e.message}\n\nPlease try again.` };
      }
    }

    // ===== BLOCKCHAIN FUNCTIONS =====
    async function connectWallet() {
      try {
        // Helper for timeout (no longer used for wallet connection - we wait indefinitely)
        const withTimeout = (promise, ms, errorMsg) => Promise.race([
          promise,
          new Promise((_, reject) => setTimeout(() => reject(new Error(errorMsg || 'Request timed out')), ms))
        ]);

        // Try to get Farcaster Mini App SDK provider first (for Warpcast)
        let ethProvider = null;
        let providerSource = 'none';

        // Check for Farcaster SDK first
        if (window.FarcasterSDK) {
          try {
            const sdk = window.FarcasterSDK;
            console.log('Farcaster SDK found');
            console.log('SDK wallet object:', sdk.wallet);
            console.log('SDK wallet methods:', sdk.wallet ? Object.keys(sdk.wallet) : 'no wallet');
            console.log('SDK context:', sdk.context);

            // Try to get user FID from SDK context (multiple approaches)
            const farcasterUser = window.FarcasterUser || window.FarcasterContext?.user || sdk.context?.user;
            if (farcasterUser?.fid) {
              state.userFid = farcasterUser.fid;
              state.userProfile = {
                fid: farcasterUser.fid,
                username: farcasterUser.username,
                displayName: farcasterUser.displayName || farcasterUser.display_name,
                pfpUrl: farcasterUser.pfpUrl || farcasterUser.pfp_url
              };
              console.log('Got user FID from Farcaster context:', state.userFid, state.userProfile);
            } else {
              console.log('No Farcaster user found in context. FarcasterUser:', window.FarcasterUser, 'FarcasterContext:', window.FarcasterContext);
            }

            // Get the provider - try different methods
            if (typeof sdk.wallet?.getEthereumProvider === 'function') {
              console.log('Calling getEthereumProvider()...');
              ethProvider = sdk.wallet.getEthereumProvider();
              // Check if it returns a promise
              if (ethProvider && typeof ethProvider.then === 'function') {
                ethProvider = await ethProvider;
              }
              providerSource = 'farcaster';
              console.log('Got Farcaster provider:', ethProvider);
              console.log('Provider methods:', ethProvider ? Object.keys(ethProvider) : 'null');
            } else {
              console.log('getEthereumProvider not found on sdk.wallet');
            }
          } catch (sdkError) {
            console.log('Farcaster SDK wallet error:', sdkError.message);
          }
        }

        // Fallback to window.ethereum (MetaMask, etc)
        if (!ethProvider && window.ethereum) {
          ethProvider = window.ethereum;
          providerSource = 'metamask';
          console.log('Using window.ethereum (MetaMask)');
        }

        if (!ethProvider) {
          showToast('No wallet found! Farcaster SDK: ' + (window.FarcasterSDK ? 'loaded' : 'not loaded'), 'error');
          return false;
        }

        console.log('Using provider from:', providerSource);

        // Show "waiting for wallet" state - NO timeout, wait for user to unlock
        state.isCheckingWhitelist = true;
        state.walletStatus = 'Unlock your wallet to continue...';
        render();

        // Connect to wallet - NO TIMEOUT, wait indefinitely for unlock
        let accounts;
        try {
          console.log('Requesting wallet accounts (waiting for unlock if needed)...');

          // Use a Promise wrapper to allow UI updates during the wait
          accounts = await new Promise((resolve, reject) => {
            // Update UI to show we're waiting
            setTimeout(() => {
              state.walletStatus = 'Waiting for wallet... Check your extension!';
              render();
            }, 2000);

            ethProvider.request({ method: 'eth_requestAccounts' })
              .then(resolve)
              .catch(reject);
          });
        } catch (e) {
          state.isCheckingWhitelist = false;
          state.walletStatus = null;
          render();
          // User rejected or other error
          if (e.code === 4001) {
            showToast('Wallet connection rejected. Please try again.', 'error');
          } else if (e.code === -32002) {
            // Already pending - wallet popup might be hidden
            showToast('Wallet request already pending! Check your wallet extension.', 'warning');
            return false;
          } else {
            showToast(e.message || 'Failed to connect wallet. Please try again.', 'error');
          }
          return false;
        }

        // Store the provider for later use
        window.activeEthProvider = ethProvider;
        state.walletStatus = 'Connected! Checking access...';
        render();

        if (!accounts || accounts.length === 0) {
          state.isCheckingWhitelist = false;
          render();
          showToast('No accounts found. Please unlock your wallet and try again.', 'error');
          return false;
        }

        const address = accounts[0];
        state.userAddress = address;

        // Check network (use the active provider)
        const chainId = await ethProvider.request({ method: 'eth_chainId' });
        if (chainId !== '0x2105') { // Base mainnet
          try {
            await ethProvider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: '0x2105' }]
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              await ethProvider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: '0x2105',
                  chainName: 'Base',
                  nativeCurrency: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
                  rpcUrls: ['https://mainnet.base.org'],
                  blockExplorerUrls: ['https://basescan.org']
                }]
              });
            } else {
              throw switchError;
            }
          }
        }

        // Uses shared rpcProvider for read operations
        // Whitelist removed - app is now open to everyone!
        state.isWhitelisted = true;

        console.log('Checking token balance...');

        // Check token balance with timeout (uses shared rpcProvider)
        const neynartodeContract = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          ['function balanceOf(address) external view returns (uint256)'],
          rpcProvider
        );

        let balance;
        try {
          balance = await withTimeout(neynartodeContract.balanceOf(address), 10000);
          state.userBalance = ethers.utils.formatEther(balance);
        } catch (e) {
          console.error('Balance check failed:', e);
          // Default to enough tokens if check fails
          balance = CONFIG.SEASON_0_MIN_TOKENS;
          state.userBalance = '20000';
        }

        if (balance.lt(CONFIG.SEASON_0_MIN_TOKENS)) {
          state.isCheckingWhitelist = false;
          render();
          showToast(`Insufficient Tokens! Need 20K $NEYNARTODES to enter. Your balance: ${parseFloat(state.userBalance).toLocaleString()}. Contract: 0x8de1...d828b07`, 'error', 10000);
          return false;
        }

        state.hasTokens = true;

        // Fetch user FID from Neynar API if not already set from Farcaster context
        if (!state.userFid) {
          console.log('No FID from Farcaster context, trying Neynar API lookup for address:', address);
          try {
            const response = await fetch(`https://api.neynar.com/v2/farcaster/user/by-verification?address=${address}`, {
              headers: {
                'accept': 'application/json',
                'api_key': CONFIG.NEYNAR_API_KEY
              }
            });
            console.log('Neynar user lookup response:', response.status);
            if (response.ok) {
              const data = await response.json();
              console.log('Neynar user lookup data:', data);
              if (data && data.users && data.users.length > 0) {
                const user = data.users[0];
                state.userFid = user.fid;
                state.userProfile = {
                  fid: user.fid,
                  username: user.username,
                  displayName: user.display_name,
                  pfpUrl: user.pfp_url
                };
                console.log('Got FID from Neynar API:', state.userFid);
              } else {
                console.log('No Farcaster user found for this wallet address');
              }
            }
          } catch (e) {
            console.error('Neynar API error:', e);
          }
        } else {
          console.log('Already have FID from Farcaster context:', state.userFid);
        }

        state.isLoggedIn = true;
        state.isCheckingWhitelist = false;
        state.walletStatus = null;

        // Fetch remaining votes from VotingManager contract
        try {
          const votingManagerRead = new ethers.Contract(
            CONFIG.CONTRACTS.votingManager,
            ['function getRemainingVotes(address user) external view returns (uint256)'],
            rpcProvider
          );
          const remainingVotes = await withTimeout(votingManagerRead.getRemainingVotes(address), 5000);
          state.votesRemaining = Number(remainingVotes);
          state.votesUsedToday = 10 - state.votesRemaining;
          console.log(`Remaining votes from contract: ${state.votesRemaining}`);
        } catch (e) {
          console.error('Failed to fetch remaining votes:', e);
          // Default to 10 if contract call fails
          state.votesRemaining = 10;
          state.votesUsedToday = 0;
        }

        // Load leaderboard data
        await loadLeaderboard();

        // Track wallet connection
        if (window.analytics?.track) {
          window.analytics.track('Wallet Connected', {
            address,
            fid: state.userFid,
            balance: state.userBalance,
            provider: providerSource
          });
        }

        render();
        return true;
      } catch (error) {
        console.error('Wallet connection error:', error);
        state.isCheckingWhitelist = false;
        state.walletStatus = null;
        render();
        showToast('Failed to connect wallet: ' + error.message, 'error');
        return false;
      }
    }

    // Dedicated function to load burned tokens - checks all burn sources
    // Uses shared rpcProvider for efficiency
    async function loadBurnedTokens() {
      // All common burn addresses on Base/Ethereum
      const BURN_ADDRESSES = [
        '0x000000000000000000000000000000000000dEaD', // Most common burn address
        '0x0000000000000000000000000000000000000000', // Zero address
      ];

      try {
        // Token contract for checking burn address balances (uses shared provider)
        const neynartodeToken = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          ['function balanceOf(address) view returns (uint256)'],
          rpcProvider
        );

        // VotingManager contract for checking burned via burn() function (uses shared provider)
        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          ['function totalTokensBurned() view returns (uint256)'],
          rpcProvider
        );

        // Check all sources in parallel (batched RPC calls)
        const [burnAddressBalances, vmBurned] = await Promise.all([
          // Check burn addresses
          Promise.all(BURN_ADDRESSES.map(addr =>
            neynartodeToken.balanceOf(addr).catch(() => ethers.BigNumber.from(0))
          )),
          // Check VotingManager's tracked burns
          votingManager.totalTokensBurned().catch(() => ethers.BigNumber.from(0))
        ]);

        // Sum all burned tokens from burn addresses
        let totalBurned = ethers.BigNumber.from(0);
        for (const balance of burnAddressBalances) {
          totalBurned = totalBurned.add(balance);
        }

        // Add VotingManager tracked burns (these are actual burn() calls that reduce supply)
        totalBurned = totalBurned.add(vmBurned);

        state.totalTokensBurned = ethers.utils.formatEther(totalBurned);
        console.log('Total tokens burned (all sources):', state.totalTokensBurned, '| VM burned:', ethers.utils.formatEther(vmBurned));
      } catch (e) {
        console.error('Error fetching burned tokens:', e);
        state.totalTokensBurned = '0';
      }
    }

    async function loadPrizePools() {
      // FIRST: Load burned tokens - this runs independently and should always work
      await loadBurnedTokens();

      try {
        console.log('Loading prize pools from PrizeNFT:', CONFIG.CONTRACTS.prizeNFT);

        // Load current season and prize pools from PrizeNFT contract (V2 - no devPool)
        // Uses shared rpcProvider for efficiency
        const prizeNFTABI = [
          'function nextSeasonId() external view returns (uint256)',
          'function seasons(uint256) external view returns (string theme, uint256 startTime, uint256 endTime, uint256 hostPool, uint256 voterPool, bool distributed)'
        ];

        const prizeNFT = new ethers.Contract(
          CONFIG.CONTRACTS.prizeNFT,
          prizeNFTABI,
          rpcProvider
        );

        // Get current season ID (latest season)
        console.log('Calling nextSeasonId()...');
        const nextSeasonId = await prizeNFT.nextSeasonId();
        console.log('nextSeasonId result:', nextSeasonId.toString());
        state.currentSeason = nextSeasonId.toNumber() - 1;
        console.log('currentSeason:', state.currentSeason);

        if (state.currentSeason > 0) {
          // Get season data
          console.log('Calling seasons(' + state.currentSeason + ')...');
          const season = await prizeNFT.seasons(state.currentSeason);
          console.log('Season data:', {
            theme: season.theme,
            startTime: season.startTime.toString(),
            endTime: season.endTime.toString(),
            hostPool: season.hostPool.toString(),
            voterPool: season.voterPool.toString(),
            distributed: season.distributed
          });

          state.hostPoolETH = parseFloat(ethers.utils.formatEther(season.hostPool));
          state.voterPoolETH = parseFloat(ethers.utils.formatEther(season.voterPool));
          state.prizePoolETH = state.hostPoolETH + state.voterPoolETH; // Total
          state.seasonEndTime = season.endTime.toNumber(); // Store season end timestamp
          console.log('seasonEndTime set to:', state.seasonEndTime);
        }

        // Clanker fees now go direct to Treasury - no pending fees to track
        state.pendingClankerFees = '0';

        // For now, calculate prizes given from all seasons (you can add a totalPrizesDistributed to contract later)
        // For beta, we'll use the current season's total as placeholder (V2 has no devPool)
        if (state.currentSeason > 0) {
          state.totalPrizesGiven = state.hostPoolETH + state.voterPoolETH;
        }

        console.log('Prize pools loaded successfully:', {
          season: state.currentSeason,
          hostPool: state.hostPoolETH,
          voterPool: state.voterPoolETH,
          seasonEndTime: state.seasonEndTime,
          pendingFees: state.pendingClankerFees,
          tokensBurned: state.totalTokensBurned,
          prizesGiven: state.totalPrizesGiven
        });
      } catch (error) {
        console.error('Failed to load prize pools:', error);
        console.error('Error details:', error.message, error.code);
      }
    }

    async function loadLeaderboard() {
      // Load prize pools from contracts
      await loadPrizePools();

      try {
        // Fetch leaderboard data from API
        const baseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        const response = await fetch(`${baseUrl}/api/leaderboard?limit=10`);

        if (!response.ok) {
          console.error('Failed to fetch leaderboard:', response.status);
          state.leaderboardData = [];
          return;
        }

        const data = await response.json();
        const hosts = data.hosts || [];

        // Transform API data to match expected leaderboard format
        state.leaderboardData = hosts.map(host => {
          // Award Season 0 Beta badges to all participants
          awardSeasonBetaBadge(host.fid, host.username);

          // Build badges array
          const badges = [];
          if (hasSeasonBetaBadge(host.fid)) {
            badges.push('season0_beta');
          }

          // Get a pfp emoji based on username hash or use first letter
          const pfpEmoji = getPfpEmoji(host.username);

          return {
            rank: host.rank,
            fid: host.fid,
            username: host.username,
            displayName: host.displayName,
            pfp: pfpEmoji,
            pfpUrl: host.pfpUrl,
            badges,
            contests: host.contests,
            completedContests: host.completedContests,
            // Score breakdown
            likes: host.likes,
            recasts: host.recasts,
            replies: host.replies,
            volume: host.volume,
            upvotes: host.upvotes,
            downvotes: host.downvotes,
            socialScore: host.socialScore,
            tokenScore: host.tokenScore,
            contestScore: host.contestScore,
            voteScore: host.voteScore || 0,
            totalScore: host.totalScore,
            neynarScore: host.neynarScore,
          };
        });

        // Fetch on-chain vote scores and merge with leaderboard data
        await fetchOnChainVoteScores();

      } catch (error) {
        console.error('Error loading leaderboard:', error);
        state.leaderboardData = [];
      }

      // Fetch active contests from contest-history API
      try {
        const baseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        const historyResponse = await fetch(`${baseUrl}/api/contest-history?limit=20&includeUsers=true`);
        if (historyResponse.ok) {
          const historyData = await historyResponse.json();
          // Filter to only active (status 0) and pending VRF (status 1) contests
          state.upcomingContests = (historyData.contests || [])
            .filter(c => c.status === 0 || c.status === 1)
            .map(c => ({
              contestId: c.contestId,
              host: c.host,
              hostUser: c.hostUser,
              prize: c.isNft
                ? `${c.nftName || 'NFT'}`
                : `${c.prizeAmount.toLocaleString(undefined, { maximumFractionDigits: 4 })} $${c.prizeTokenSymbol}`,
              prizeToken: c.prizeTokenSymbol,
              prizeAmount: c.prizeAmount,
              startTime: new Date(c.startTime * 1000),
              endTime: new Date(c.endTime * 1000),
              volumeRequirement: c.volumeRequirement,
              tokenRequirementSymbol: c.tokenRequirementSymbol,
              status: c.status,
              statusText: c.statusText,
              participantCount: c.participantCount,
              castId: c.castId,
              // Social requirements from API
              requireRecast: c.requireRecast || false,
              requireLike: c.requireLike || false,
              requireReply: c.requireReply || false,
              // NFT fields
              isNft: c.isNft || false,
              nftAddress: c.nftAddress || '',
              nftTokenId: c.nftTokenId || '',
              nftImage: c.nftImage || '',
              nftName: c.nftName || '',
              nftCollection: c.nftCollection || '',
              nftType: c.nftType || '',
            }));
          console.log(`Loaded ${state.upcomingContests.length} active/pending contests`);
          // Debug NFT contests
          state.upcomingContests.filter(c => c.isNft).forEach(c => {
            console.log('NFT Contest:', c.contestId, 'nftImage:', c.nftImage, 'nftName:', c.nftName);
          });
        }
      } catch (e) {
        console.error('Error fetching active contests:', e);
        state.upcomingContests = [];
      }

      // Re-render to show active contests
      render();
    }

    // Fetch vote scores from VotingManager contract and update leaderboard
    async function fetchOnChainVoteScores() {
      if (state.leaderboardData.length === 0) return;

      try {
        // Uses shared rpcProvider for efficiency
        const votingManagerABI = [
          'function getHostVoteStats(uint256 hostFid) external view returns (uint256 upvotes, uint256 downvotes, int256 netScore)'
        ];
        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          rpcProvider
        );

        // Fetch vote stats for each host in parallel
        const votePromises = state.leaderboardData.map(async (host) => {
          try {
            const stats = await votingManager.getHostVoteStats(host.fid);
            return {
              fid: host.fid,
              upvotes: stats.upvotes.toNumber(),
              downvotes: stats.downvotes.toNumber(),
              netScore: stats.netScore.toNumber()
            };
          } catch (e) {
            console.warn(`Failed to get vote stats for FID ${host.fid}:`, e.message);
            return { fid: host.fid, upvotes: 0, downvotes: 0, netScore: 0 };
          }
        });

        const voteStats = await Promise.all(votePromises);

        // Update leaderboard with on-chain vote scores (200 points per net vote)
        state.leaderboardData = state.leaderboardData.map(host => {
          const stats = voteStats.find(s => s.fid === host.fid);
          if (stats) {
            const onChainVoteScore = stats.netScore * 200; // 200 points per net vote
            // Replace API vote score with on-chain score
            const adjustedTotal = host.totalScore - (host.voteScore || 0) + onChainVoteScore;
            return {
              ...host,
              upvotes: stats.upvotes,
              downvotes: stats.downvotes,
              voteScore: onChainVoteScore,
              totalScore: adjustedTotal
            };
          }
          return host;
        });

        // Re-sort and re-rank after updating scores
        state.leaderboardData = state.leaderboardData
          .sort((a, b) => b.totalScore - a.totalScore)
          .map((host, idx) => ({ ...host, rank: idx + 1 }));

        console.log('Updated leaderboard with on-chain vote scores');
        render();

      } catch (error) {
        console.error('Error fetching on-chain vote scores:', error);
      }
    }

    // Get a consistent emoji for a user based on their username
    function getPfpEmoji(username) {
      const emojis = ['ðŸ¦Ž', 'ðŸ¸', 'ðŸŠ', 'ðŸ¦–', 'ðŸ¢', 'ðŸ¦•', 'ðŸ', 'ðŸ²', 'ðŸŒŠ', 'ðŸª¸'];
      if (!username) return 'ðŸ¦Ž';
      const hash = username.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      return emojis[hash % emojis.length];
    }

    async function loadHistory() {
      state.historyLoading = true;
      state.historyError = null;
      render();

      try {
        const baseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        const response = await fetch(`${baseUrl}/api/contest-history?limit=20&includeUsers=true`);

        if (!response.ok) {
          throw new Error(`Failed to fetch history: ${response.status}`);
        }

        const data = await response.json();
        state.historyData = data.contests || [];
        state.historyTotal = data.total || 0;
        state.historyLoading = false;
        render();
      } catch (error) {
        console.error('Error loading history:', error);
        state.historyError = error.message;
        state.historyLoading = false;
        render();
      }
    }

    // ===== ANONYMOUS SUGGESTIONS =====
    // Uses localStorage for storage - suggestions are completely anonymous (no user data stored)
    const SUGGESTIONS_KEY = 'neynartodes_suggestions';

    function loadSuggestions() {
      state.suggestionsLoading = true;
      render();

      try {
        const stored = localStorage.getItem(SUGGESTIONS_KEY);
        state.suggestions = stored ? JSON.parse(stored) : [];
        // Sort by newest first
        state.suggestions.sort((a, b) => b.timestamp - a.timestamp);
      } catch (error) {
        console.error('Error loading suggestions:', error);
        state.suggestions = [];
      }

      state.suggestionsLoading = false;
      render();
    }

    function submitAnonymousSuggestion() {
      const text = state.suggestionText.trim();

      if (text.length < 10) {
        showToast('Suggestion must be at least 10 characters', 'error');
        return;
      }

      try {
        // Load existing suggestions
        const stored = localStorage.getItem(SUGGESTIONS_KEY);
        const suggestions = stored ? JSON.parse(stored) : [];

        // Add new suggestion (completely anonymous - no user data)
        suggestions.push({
          id: Date.now().toString(36) + Math.random().toString(36).substr(2),
          text: text,
          timestamp: Date.now()
        });

        // Save back to localStorage
        localStorage.setItem(SUGGESTIONS_KEY, JSON.stringify(suggestions));

        // Clear the input and show success
        state.suggestionText = '';
        showToast('Suggestion submitted anonymously! Thank you for your feedback.', 'success');
        render();

        // Track analytics (without any identifying info)
        if (window.analytics?.track) {
          window.analytics.track('Suggestion Submitted', { anonymous: true });
        }
      } catch (error) {
        console.error('Error submitting suggestion:', error);
        showToast('Failed to submit suggestion. Please try again.', 'error');
      }
    }

    // History refresh is now manual only - triggered when entering the page or clicking Refresh button
    // Removed auto-refresh interval to reduce unnecessary API calls
    function stopHistoryAutoRefresh() {
      // No-op - kept for compatibility with existing view switching code
    }

    // Countdown timer interval for leaderboard
    let countdownInterval = null;

    function startCountdownTimer() {
      stopCountdownTimer();
      // Update countdown every minute (targeted update, not full render)
      countdownInterval = setInterval(() => {
        if (state.currentView === 'leaderboard') {
          updateCountdownDisplay();
        }
      }, 60000); // Update every minute
    }

    // Targeted countdown update - avoids rebuilding entire leaderboard DOM
    function updateCountdownDisplay() {
      const countdownEl = document.getElementById('countdown-text');
      if (!countdownEl) return;

      const countdown = getSeasonCountdown();
      if (!countdown) {
        countdownEl.textContent = 'Loading...';
      } else if (countdown.ended) {
        countdownEl.textContent = 'Season Ended!';
      } else {
        countdownEl.textContent = countdown.text;
      }
    }

    function stopCountdownTimer() {
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }

    // Format timestamp to readable date
    function formatDate(timestamp) {
      const date = new Date(timestamp * 1000);
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    // Get season countdown string
    function getSeasonCountdown() {
      if (!state.seasonEndTime) return null;

      const now = Math.floor(Date.now() / 1000);
      const remaining = state.seasonEndTime - now;

      if (remaining <= 0) return { text: 'Season Ended!', days: 0, hours: 0, minutes: 0, ended: true };

      const days = Math.floor(remaining / 86400);
      const hours = Math.floor((remaining % 86400) / 3600);
      const minutes = Math.floor((remaining % 3600) / 60);

      let text = '';
      if (days > 0) text += `${days}d `;
      if (hours > 0 || days > 0) text += `${hours}h `;
      text += `${minutes}m`;

      return { text: text.trim(), days, hours, minutes, ended: false };
    }

    // Format duration
    function formatDuration(hours, minutes) {
      if (hours === 0) return `${minutes}m`;
      if (minutes === 0) return `${hours}h`;
      return `${hours}h ${minutes}m`;
    }

    // Fetch user's recent casts from Neynar
    async function fetchRecentCasts() {
      if (!state.userFid) {
        showToast('Unable to fetch casts - no Farcaster ID found', 'error');
        console.log('fetchRecentCasts: No userFid available, userFid =', state.userFid);
        return;
      }

      state.loadingRecentCasts = true;
      render();

      try {
        console.log('Fetching casts for FID:', state.userFid);
        const response = await fetch(`https://api.neynar.com/v2/farcaster/feed/user/casts?fid=${state.userFid}&limit=3&include_replies=false`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        console.log('Neynar API response status:', response.status);

        if (response.ok) {
          const data = await response.json();
          console.log('Casts data:', data);
          state.recentCasts = (data.casts || []).map(cast => ({
            hash: cast.hash,
            text: cast.text?.substring(0, 80) + (cast.text?.length > 80 ? '...' : '') || '',
            timestamp: new Date(cast.timestamp).toLocaleDateString(),
            url: `https://farcaster.id/cast/${cast.hash}`
          }));
        } else {
          const errorText = await response.text();
          console.error('Neynar API error:', response.status, errorText);
          showToast('Failed to fetch casts', 'error');
          state.recentCasts = [];
        }
      } catch (error) {
        console.error('Error fetching recent casts:', error);
        showToast('Error fetching casts', 'error');
        state.recentCasts = [];
      }

      state.loadingRecentCasts = false;
      state.showRecentCasts = true;
      render();
    }

    // Copy cast hash to input and close dropdown
    function selectRecentCast(url) {
      state.castHash = url;
      state.showRecentCasts = false;
      render();
    }

    // Copy text to clipboard
    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        showToast('Copied to clipboard!', 'success', 2000);
      } catch (err) {
        showToast('Failed to copy', 'error');
      }
    }

    // Get status color class
    function getStatusColor(status) {
      switch (status) {
        case 0: return 'bg-blue-100 text-blue-700'; // Active
        case 1: return 'bg-yellow-100 text-yellow-700'; // PendingVRF
        case 2: return 'bg-green-100 text-green-700'; // Completed
        case 3: return 'bg-red-100 text-red-700'; // Cancelled
        default: return 'bg-gray-100 text-gray-700';
      }
    }

    // Get status emoji
    function getStatusEmoji(status) {
      switch (status) {
        case 0: return 'ðŸ”µ'; // Active
        case 1: return 'ðŸŽ²'; // PendingVRF
        case 2: return 'âœ…'; // Completed
        case 3: return 'âŒ'; // Cancelled
        default: return 'â“';
      }
    }

    async function voteForHost(hostFid, isUpvote) {
      // Check if dev wallet (unlimited voting)
      const isDev = isDevWallet(state.userAddress);

      // Block self-voting (except dev for testing)
      if (!isDev && state.userFid && state.userFid === hostFid) {
        showToast("You can't vote for yourself! Nice try though!", 'error');
        return;
      }

      if (!isDev && state.votesRemaining <= 0) {
        showToast('You have used all 10 votes for today! Come back tomorrow.', 'warning');
        return;
      }

      try {
        // Create provider and signer using stored provider
        const ethProvider = window.activeEthProvider || window.ethereum;
        if (!ethProvider) {
          showToast('Wallet not connected! Please reconnect.', 'error');
          return;
        }
        const walletProvider = new ethers.providers.Web3Provider(ethProvider);
        const signer = walletProvider.getSigner();

        // Use shared rpcProvider for read operations (Farcaster wallet doesn't support eth_call)

        // Contract ABIs - VotingManager V2 with upvote/downvote
        const votingManagerABI = [
          'function voteForHost(uint256 hostFid, bool isUpvote) external',
          'function getRemainingVotes(address user) external view returns (uint256)',
          'function canVote(address user) external view returns (bool)',
          'function getHostVoteStats(uint256 hostFid) external view returns (uint256 upvotes, uint256 downvotes, int256 netScore)',
          'function TOKENS_PER_VOTE() external view returns (uint256)'
        ];

        const tokenABI = [
          'function approve(address spender, uint256 amount) external returns (bool)',
          'function allowance(address owner, address spender) external view returns (uint256)',
          'function balanceOf(address account) external view returns (uint256)'
        ];

        // Read-only contract instances for checking balances/allowances (uses shared rpcProvider)
        const votingManagerRead = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          rpcProvider
        );

        const neynartodeTokenRead = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          tokenABI,
          rpcProvider
        );

        // Write contract instances for transactions
        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          signer
        );

        const neynartodeToken = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          tokenABI,
          signer
        );

        // Check if can vote (skip for dev wallet) - use read-only provider
        if (!isDev) {
          const canVoteResult = await votingManagerRead.canVote(state.userAddress);
          if (!canVoteResult) {
            showToast('Cannot vote! You may have used all votes today or have insufficient tokens.', 'error');
            return;
          }
        }

        // Get tokens per vote (1000 NEYNARTODES)
        const tokensPerVote = ethers.utils.parseEther('1000');

        // Check balance - use read-only provider
        const balance = await neynartodeTokenRead.balanceOf(state.userAddress);
        if (balance.lt(tokensPerVote)) {
          showToast(`Insufficient balance! You need 1,000 NEYNARTODES to vote. Your balance: ${ethers.utils.formatEther(balance)}`, 'error');
          return;
        }

        // Check and set approval if needed - use read-only provider for allowance check
        const currentAllowance = await neynartodeTokenRead.allowance(state.userAddress, CONFIG.CONTRACTS.votingManager);
        if (currentAllowance.lt(tokensPerVote)) {
          showToast('Approving voting contract... Confirm in wallet.', 'info', 8000);

          // Encode approve call manually for smart wallet compatibility
          const approveInterface = new ethers.utils.Interface(tokenABI);
          const approveData = approveInterface.encodeFunctionData('approve', [
            CONFIG.CONTRACTS.votingManager,
            ethers.constants.MaxUint256
          ]);

          // Send via raw eth_sendTransaction for Farcaster smart wallet
          const approveTxHash = await ethProvider.request({
            method: 'eth_sendTransaction',
            params: [{
              from: state.userAddress,
              to: CONFIG.CONTRACTS.neynartodes,
              data: approveData,
              gas: '0x' + (500000).toString(16) // 500k gas for smart wallet approve
            }]
          });

          showToast('Approval submitted! Waiting for confirmation...', 'info', 10000);

          // Wait for approval confirmation
          let approveReceipt = null;
          for (let i = 0; i < 30; i++) {
            await new Promise(r => setTimeout(r, 2000));
            approveReceipt = await rpcProvider.getTransactionReceipt(approveTxHash);
            if (approveReceipt) break;
          }

          if (approveReceipt) {
            showToast('Approval confirmed! Now submitting vote...', 'success');
          } else {
            showToast('Approval may still be pending. Continuing with vote...', 'warning');
          }
        }

        // Cast vote on-chain
        showToast('Submitting vote... Burns 500 + 500 to treasury. Confirm in wallet!', 'info', 8000);

        // Encode the function call manually (Farcaster provider doesn't support eth_estimateGas)
        const voteInterface = new ethers.utils.Interface(votingManagerABI);
        const voteData = voteInterface.encodeFunctionData('voteForHost', [hostFid, isUpvote]);

        // Send transaction via raw eth_sendTransaction (works with Farcaster wallet)
        const txHash = await ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: state.userAddress,
            to: CONFIG.CONTRACTS.votingManager,
            data: voteData,
            gas: '0x' + (800000).toString(16) // 800k gas for smart wallet vote (transferFrom + burn + transfer)
          }]
        });

        console.log('Vote tx hash:', txHash);

        // Track vote event
        if (window.analytics?.track) {
          window.analytics.track('Vote Cast', {
            hostFid,
            isUpvote,
            voteType: isUpvote ? 'upvote' : 'downvote',
            txHash: txHash
          });
        }

        showToast('Vote submitted! Waiting for confirmation...', 'info', 15000);

        // Wait for receipt using read provider
        let receipt = null;
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          receipt = await rpcProvider.getTransactionReceipt(txHash);
          if (receipt) break;
        }

        if (!receipt) {
          showToast('Vote submitted but not yet confirmed. Check BaseScan.', 'warning');
        }

        // Update UI after successful vote (200 points per vote to align with scoring system)
        const votePoints = isUpvote ? 200 : -200;
        const oldRankings = state.leaderboardData.map(h => ({ fid: h.fid, rank: h.rank }));

        // Update leaderboard locally
        state.leaderboardData = state.leaderboardData.map(host => {
          if (host.fid === hostFid) {
            return {
              ...host,
              voteScore: host.voteScore + votePoints,
              totalScore: host.totalScore + votePoints
            };
          }
          return host;
        }).sort((a, b) => b.totalScore - a.totalScore).map((host, idx) => ({ ...host, rank: idx + 1 }));

        // Refresh burned tokens counter
        await loadBurnedTokens();

        const votedHost = state.leaderboardData.find(h => h.fid === hostFid);
        const oldRank = oldRankings.find(h => h.fid === hostFid)?.rank;
        const newRank = votedHost.rank;
        const movement = oldRank - newRank;

        let movementText = '';
        if (movement > 0) {
          movementText = `\nðŸ“ˆ @${votedHost.username} moved UP ${movement} position${movement > 1 ? 's' : ''}! (${oldRank} â†’ ${newRank})`;
        } else if (movement < 0) {
          movementText = `\nðŸ“‰ @${votedHost.username} moved DOWN ${Math.abs(movement)} position${Math.abs(movement) > 1 ? 's' : ''}! (${oldRank} â†’ ${newRank})`;
        } else {
          movementText = `\nâž¡ï¸ @${votedHost.username} stayed at rank #${newRank}`;
        }

        // Refresh remaining votes from contract for non-dev wallets
        if (!isDevWallet) {
          try {
            const remainingVotes = await votingManagerRead.getRemainingVotes(state.userAddress);
            state.votesRemaining = Number(remainingVotes);
            state.votesUsedToday = 10 - state.votesRemaining;
          } catch (e) {
            // Fallback to local decrement if contract call fails
            state.votesUsedToday++;
            state.votesRemaining--;
          }
        }

        const ethFromVote = 0.00001;
        state.prizePoolETH += (ethFromVote * 0.5);

        showToast(`${isUpvote ? 'Upvote' : 'Downvote'} confirmed! 500 burned, 500 to treasury. ${isDevWallet ? 'Dev mode' : `${state.votesRemaining}/10 votes left`}`, 'success', 6000);

        render();
      } catch (error) {
        console.error('Voting error:', error);

        if (error.code === 4001) {
          showToast('Transaction rejected by user', 'error');
        } else if (error.message && error.message.includes('Daily vote limit')) {
          showToast('Daily vote limit reached! Come back tomorrow.', 'error');
        } else if (error.message && error.message.includes('Already voted')) {
          showToast('Already voted for this host!', 'error');
        } else {
          showToast('Vote failed: ' + (error.reason || error.message || 'Unknown error'), 'error');
        }
      }
    }

    // ===== RENDER FUNCTIONS =====
    function render() {
      const app = document.getElementById('app');

      if (!state.isLoggedIn) {
        app.innerHTML = renderLoginPage();
      } else if (state.launchSuccess) {
        app.innerHTML = renderLaunchSuccess();
      } else if (state.currentView === 'leaderboard') {
        app.innerHTML = renderLeaderboard();
      } else if (state.currentView === 'active') {
        app.innerHTML = renderActiveContests();
      } else if (state.currentView === 'history') {
        app.innerHTML = renderHistory();
      } else if (state.currentView === 'suggestions') {
        app.innerHTML = renderSuggestions();
      } else {
        app.innerHTML = renderCreateContest();
      }

      attachEventListeners();
    }

    function renderLaunchSuccess() {
      const { contestId, castHash, txHash, txUrl } = state.launchSuccess;
      return `
        <div class="min-h-screen flex items-center justify-center p-6" style="background: var(--bg-primary);">
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at center, rgba(16, 185, 129, 0.15) 0%, transparent 60%);"></div>

          <div class="glass-card p-8 max-w-sm w-full text-center relative z-10 animate-fade-in">
            <div class="w-16 h-16 mx-auto mb-4 rounded-full bg-[var(--success-glow)] flex items-center justify-center text-3xl">
              ðŸŽ‰
            </div>
            <h1 class="text-2xl font-bold text-[var(--success)] mb-6">
              Contest Launched!
            </h1>

            <div class="bg-[var(--bg-secondary)] rounded-xl p-4 mb-6 text-left space-y-3">
              <div>
                <p class="text-xs text-[var(--text-muted)]">Contest ID</p>
                <p class="text-lg font-bold text-[var(--text-primary)]">#${contestId}</p>
              </div>
              <div>
                <p class="text-xs text-[var(--text-muted)]">Status</p>
                <p class="text-sm text-[var(--success)]">Prize locked in escrow</p>
              </div>
              <div>
                <p class="text-xs text-[var(--text-muted)]">Winner Selection</p>
                <p class="text-sm text-[var(--text-secondary)]">Chainlink VRF at contest end</p>
              </div>
              <div>
                <p class="text-xs text-[var(--text-muted)]">Transaction</p>
                <a href="${txUrl}" target="_blank" class="text-sm text-[var(--accent-light)] hover:underline break-all">
                  ${txHash.slice(0, 20)}...
                </a>
              </div>
            </div>

            <button
              id="castSuccessButton"
              class="btn-primary w-full py-3 mb-3"
            >
              ðŸ“£ Cast It
            </button>

            <button
              onclick="state.launchSuccess = null; render();"
              class="btn-ghost w-full py-3"
            >
              Launch Another
            </button>

            <a
              href="${txUrl}"
              target="_blank"
              class="block mt-4 text-[var(--text-secondary)] hover:text-[var(--text-primary)] text-sm transition-colors"
            >
              View on BaseScan
            </a>
          </div>
        </div>
      `;
    }

    function renderLoginPage() {
      return `
        <div class="min-h-screen flex flex-col items-center justify-center p-6" style="background: var(--bg-primary);">
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.12) 0%, transparent 50%);"></div>

          <div class="max-w-md w-full text-center relative z-10 animate-fade-in">
            <!-- Logo -->
            <div class="w-28 h-28 mx-auto mb-6">
              <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-contain" style="filter: drop-shadow(0 0 30px rgba(139, 92, 246, 0.6)) drop-shadow(0 0 60px rgba(139, 92, 246, 0.4));" />
            </div>

            <!-- Header -->
            <h1 class="text-4xl font-bold text-gradient mb-2">Neynartodes</h1>
            <p class="text-xl text-[var(--text-primary)] font-medium mb-8">Trustless Onchain Gamified Raffle</p>

            <!-- Subheading list -->
            <div class="space-y-2 mb-10">
              <p class="text-[var(--text-secondary)]">Bless Your Followers</p>
              <p class="text-[var(--text-secondary)]">Promote Your Project</p>
              <p class="text-[var(--text-secondary)]">Claim the Leaderboard</p>
              <p class="text-[var(--accent-light)]">Feed The Neynartodes</p>
            </div>

            ${state.isCheckingWhitelist ? `
              <div class="mb-4 p-4 glass-card">
                <div class="animate-spin text-2xl mb-2">ðŸŒ€</div>
                <p class="text-sm font-medium text-[var(--text-primary)]">${state.walletStatus || 'Checking access...'}</p>
                <p class="text-xs text-[var(--text-muted)] mt-1">Unlock wallet if prompted</p>
              </div>
            ` : ''}

            <!-- Enter Button -->
            <button
              id="connectButton"
              ${state.isCheckingWhitelist ? 'disabled' : ''}
              class="btn-primary w-full py-4 text-xl font-semibold disabled:opacity-50 mb-4"
            >
              ${state.isCheckingWhitelist ? 'Connecting...' : 'Enter'}
            </button>

            <!-- Powered by -->
            <div class="mt-10 pt-6 border-t border-[var(--border-subtle)]">
              <p class="text-xs text-[var(--text-muted)] mb-2">Powered by</p>
              <button
                id="buyTokenButton"
                class="text-[var(--accent-light)] hover:text-[var(--accent)] font-semibold text-lg transition-colors bg-transparent border-none cursor-pointer"
              >
                $NEYNARTODES
              </button>
              <p class="font-mono text-xs text-[var(--text-muted)] mt-2 break-all">0x8de1622fe07f56cda2e2273e615a513f1d828b07</p>
              <p class="text-xs text-[var(--text-muted)] mt-1">Tap to buy tokens</p>
            </div>

            <!-- How to use -->
            <a
              href="https://github.com/95m6sbvh6c-byte/neynartode#readme"
              target="_blank"
              class="mt-6 inline-block text-[var(--text-muted)] hover:text-[var(--text-secondary)] text-sm transition-colors"
            >
              How to Use
            </a>
          </div>
        </div>
      `;
    }

    function renderHeader() {
      return `
        <header class="glass-card p-4 mb-6 animate-fade-in">
          <!-- Top bar with logo and user info -->
          <div class="flex items-center justify-between mb-4">
            <div class="flex items-center gap-3">
              <div class="w-10 h-10 rounded-xl overflow-hidden">
                <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-cover" style="filter: drop-shadow(0 0 8px rgba(139, 92, 246, 0.6));" />
              </div>
              <div>
                <h1 class="text-xl font-bold text-gradient">NEYNARtodes</h1>
                <p class="text-xs text-[var(--text-muted)]">Season 0 Beta</p>
              </div>
            </div>
            <div class="flex items-center gap-3">
              <div class="text-right">
                <p class="text-sm font-medium text-[var(--text-primary)]">
                  ${parseFloat(state.userBalance).toLocaleString()} <span class="text-[var(--accent-light)]">$NEYNARTODES</span>
                </p>
                <p class="text-xs text-[var(--text-muted)]">
                  ${state.userAddress.substring(0, 6)}...${state.userAddress.substring(38)}
                  ${state.userBadges.length > 0 ? `<span class="ml-1">${state.userBadges.map(b => getBadgeEmoji(b)).join('')}</span>` : ''}
                </p>
              </div>
              <div class="w-2 h-2 rounded-full ${window.activeEthProvider ? 'bg-[var(--success)]' : 'bg-[var(--error)]'}"></div>
            </div>
          </div>

          <!-- Active page title -->
          <div class="mb-2 py-3 text-center">
            <h2 class="text-xl font-bold text-gradient">
              ${state.currentView === 'create' ? 'Create Contest' :
                state.currentView === 'history' ? 'Contest History' :
                state.currentView === 'leaderboard' ? 'Leaderboard' :
                state.currentView === 'active' ? 'Active Contests' :
                'Suggestions'}
            </h2>
          </div>

          <!-- Other navigation tabs (excluding current page) -->
          <nav class="flex gap-1 p-1 bg-[var(--bg-secondary)] rounded-xl">
            ${state.currentView !== 'create' ? `
              <button id="viewCreate" class="btn-ghost flex-1 text-[10px] py-2 px-1">Create</button>
            ` : ''}
            ${state.currentView !== 'active' ? `
              <button id="viewActive" class="btn-ghost flex-1 text-[10px] py-2 px-1">Active</button>
            ` : ''}
            ${state.currentView !== 'history' ? `
              <button id="viewHistory" class="btn-ghost flex-1 text-[10px] py-2 px-1">History</button>
            ` : ''}
            ${state.currentView !== 'leaderboard' ? `
              <button id="viewLeaderboard" class="btn-ghost flex-1 text-[10px] py-2 px-1">Stats</button>
            ` : ''}
            ${state.currentView !== 'suggestions' ? `
              <button id="viewSuggestions" class="btn-ghost flex-1 text-[10px] py-2 px-1">Ideas</button>
            ` : ''}
          </nav>
        </header>
      `;
    }

    function renderLeaderboard() {
      return `
        <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
          <!-- Subtle background gradient -->
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>

          <div class="max-w-6xl mx-auto relative z-10">
            ${renderHeader()}

            <div class="space-y-4">
              <!-- Current Leader - Full Width Row -->
              <div class="stat-card">
                <div class="stat-label text-center">Current Leader</div>
                ${state.leaderboardData.length > 0 ? `
                  <a href="https://warpcast.com/${state.leaderboardData[0].username}" target="_blank" class="flex flex-col items-center hover:opacity-80 transition-opacity mt-2">
                    ${state.leaderboardData[0].pfpUrl
                      ? `<img src="${state.leaderboardData[0].pfpUrl}" alt="" class="w-12 h-12 rounded-full object-cover mb-2" onerror="this.style.display='none';" />`
                      : `<span class="w-12 h-12 rounded-full bg-[var(--bg-tertiary)] flex items-center justify-center text-xl mb-2">${state.leaderboardData[0].pfp}</span>`
                    }
                    <span class="stat-value stat-value-sm">@${state.leaderboardData[0].username}</span>
                    <div class="stat-subtitle">${state.leaderboardData[0].totalScore.toLocaleString()} points</div>
                  </a>
                ` : `
                  <div class="text-center mt-2">
                    <div class="stat-value stat-value-sm">TBA</div>
                    <div class="stat-subtitle">Be the first!</div>
                  </div>
                `}
              </div>

              <!-- Stats Grid -->
              <div class="grid grid-cols-3 gap-3">
                <!-- Season Countdown -->
                <div class="stat-card">
                  <div class="stat-label">Season Ends</div>
                  ${(() => {
                    const countdown = getSeasonCountdown();
                    if (!countdown) return '<div id="countdown-text" class="stat-value stat-value-sm">Loading...</div>';
                    if (countdown.ended) return '<div id="countdown-text" class="stat-value stat-value-sm">Ended</div>';
                    return `
                      <div id="countdown-text" class="stat-value stat-value-sm">${countdown.text}</div>
                      <div class="stat-subtitle">Season ${state.currentSeason}</div>
                    `;
                  })()}
                </div>

                <!-- Host Prize Pool -->
                <div class="stat-card">
                  <div class="stat-label">Prize Pool</div>
                  <div class="stat-value stat-value-sm">${state.hostPoolETH.toFixed(4)} <span class="text-[var(--text-muted)] text-lg">ETH</span></div>
                  <div class="stat-subtitle">For hosts</div>
                </div>

                <!-- Tokens Burned -->
                <div class="stat-card">
                  <div class="stat-label">Tokens Burned</div>
                  <div class="stat-value stat-value-sm">${Number(state.totalTokensBurned).toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                  <div class="stat-subtitle">From supply</div>
                </div>
              </div>

              <!-- All-Time Prizes - Full Width -->
              <div class="stat-card">
                <div class="flex items-center justify-between">
                  <div>
                    <div class="stat-label">All-Time Prizes Distributed</div>
                    <div class="stat-value">${state.totalPrizesGiven.toFixed(4)} <span class="text-[var(--text-muted)] text-xl">ETH</span></div>
                  </div>
                  <div class="text-4xl opacity-20">ðŸ’Ž</div>
                </div>
              </div>

              <!-- Feed the Neynartodes -->
              ${parseFloat(state.pendingClankerFees) > 0 ? `
                <div class="glass-card-accent p-5">
                  <div class="flex items-center justify-between gap-4">
                    <div class="flex-1">
                      <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-1">Feed the Neynartodes</h3>
                      <p class="text-sm text-[var(--text-secondary)]">
                        ${parseFloat(state.pendingClankerFees).toFixed(2)} tokens available from Clanker fees
                      </p>
                    </div>
                    <button onclick="feedTheNeynartodes()" class="btn-primary whitespace-nowrap">
                      Feed Now
                    </button>
                  </div>
                </div>
              ` : ''}

              <!-- Voting Power -->
              <div class="glass-card p-5">
                <div class="flex items-center justify-between mb-4">
                  <div>
                    <h3 class="text-lg font-semibold text-[var(--accent-light)]">Your Voting Power</h3>
                    <p class="text-sm text-[var(--text-secondary)]">1000 tokens per vote â€¢ Resets daily</p>
                  </div>
                  <div class="text-right">
                    <div class="text-3xl font-bold text-[var(--accent-light)]">${state.votesRemaining}<span class="text-[var(--text-muted)] text-lg">/10</span></div>
                    <div class="text-xs text-[var(--text-muted)]">votes remaining</div>
                  </div>
                </div>
                <div class="divider"></div>
                <div class="grid grid-cols-3 gap-4 text-center text-sm">
                  <div>
                    <div class="text-[var(--text-muted)] mb-1">Cost</div>
                    <div class="text-[var(--text-primary)] font-medium">1000 tokens</div>
                  </div>
                  <div>
                    <div class="text-[var(--text-muted)] mb-1">Upvote</div>
                    <div class="text-[var(--success)] font-medium">+200 pts</div>
                  </div>
                  <div>
                    <div class="text-[var(--text-muted)] mb-1">Downvote</div>
                    <div class="text-[var(--error)] font-medium">-200 pts</div>
                  </div>
                </div>
              </div>

              <!-- Leaderboard Table -->
              <div class="glass-card p-5">
                <div class="flex items-center justify-between mb-5">
                  <div>
                    <h2 class="text-xl font-bold"><span class="text-gradient">NEYNARtodes</span> <span class="text-[var(--text-primary)]">Leaderboard</span></h2>
                    <p class="text-sm text-[var(--text-muted)]">Season ${state.currentSeason} Rankings</p>
                  </div>
                  <a
                    href="https://github.com/95m6sbvh6c-byte/neynartode/blob/main/docs/GUIDE_LEADERBOARD.md"
                    target="_blank"
                    class="btn-ghost text-sm"
                  >Guide</a>
                </div>

                <div class="overflow-x-auto">
                  ${state.leaderboardData.length === 0 ? `
                    <div class="text-center py-12">
                      <div class="w-16 h-16 mx-auto mb-4">
                        <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-contain" style="filter: drop-shadow(0 0 15px rgba(139, 92, 246, 0.5));" />
                      </div>
                      <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-2">No Hosts Yet</h3>
                      <p class="text-[var(--text-secondary)] text-sm">Be the first to launch a contest!</p>
                    </div>
                  ` : `
                  <table class="w-full">
                    <thead>
                      <tr class="border-b border-[var(--border-subtle)]">
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Rank</th>
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Host</th>
                        <th class="text-right py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Score</th>
                        <th class="text-center py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Vote</th>
                        <th class="text-right py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Contests</th>
                        <th class="text-right py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Neynar</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${state.leaderboardData.map(host => `
                        <tr class="border-b border-[var(--border-subtle)] hover:bg-[var(--bg-secondary)] transition-colors">
                          <td class="py-4 px-2">
                            <div class="font-bold text-lg ${
                              host.rank === 1 ? 'text-yellow-400' :
                              host.rank === 2 ? 'text-gray-400' :
                              host.rank === 3 ? 'text-orange-400' :
                              'text-[var(--text-muted)]'
                            }">
                              ${host.rank <= 3 ? ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][host.rank - 1] : host.rank}
                            </div>
                          </td>
                          <td class="py-4 px-2">
                            <a href="https://warpcast.com/${host.username}" target="_blank" class="flex flex-col items-center hover:opacity-80 transition-opacity">
                              ${host.pfpUrl
                                ? `<img src="${host.pfpUrl}" alt="" class="w-8 h-8 rounded-full object-cover mb-1" onerror="this.style.display='none';" />`
                                : `<span class="w-8 h-8 rounded-full bg-[var(--bg-tertiary)] flex items-center justify-center text-sm mb-1">${host.pfp}</span>`
                              }
                              <div class="text-xs font-medium text-[var(--text-primary)] text-center">
                                @${host.username}
                                ${host.badges.map(badge => `<span title="${getBadgeTitle(badge)}">${getBadgeEmoji(badge)}</span>`).join('')}
                              </div>
                            </a>
                          </td>
                          <td class="py-4 px-2 text-right">
                            <div class="font-semibold text-[var(--accent-light)]" title="Contest: ${(host.contestScore || 0).toLocaleString()} | Votes: ${(host.voteScore || 0).toLocaleString()}">
                              ${(host.totalScore || 0).toLocaleString()}
                            </div>
                            <div class="text-xs text-[var(--text-muted)] mt-0.5">
                              ${(host.socialScore || 0).toLocaleString()} social Â· ${(host.tokenScore || 0).toLocaleString()} token
                            </div>
                          </td>
                          <td class="py-4 px-2">
                            <div class="flex gap-1 justify-center">
                              <button
                                onclick="voteForHost(${host.fid}, true)"
                                ${state.votesRemaining <= 0 ? 'disabled' : ''}
                                class="w-8 h-8 flex items-center justify-center rounded-lg bg-[var(--success-glow)] hover:bg-[var(--success)] hover:bg-opacity-30 disabled:opacity-30 disabled:cursor-not-allowed text-[var(--success)] transition-colors text-sm"
                                title="Upvote (+200 pts)"
                              >â–²</button>
                              <button
                                onclick="voteForHost(${host.fid}, false)"
                                ${state.votesRemaining <= 0 ? 'disabled' : ''}
                                class="w-8 h-8 flex items-center justify-center rounded-lg bg-[var(--error-glow)] hover:bg-[var(--error)] hover:bg-opacity-30 disabled:opacity-30 disabled:cursor-not-allowed text-[var(--error)] transition-colors text-sm"
                                title="Downvote (-200 pts)"
                              >â–¼</button>
                            </div>
                          </td>
                          <td class="py-4 px-2 text-right">
                            <div class="font-medium text-[var(--text-primary)]">${host.completedContests || host.contests || 0}</div>
                            <div class="text-xs text-[var(--text-muted)]">${host.contests || 0} total</div>
                          </td>
                          <td class="py-4 px-2 text-right">
                            <span class="tag tag-accent">${host.neynarScore}</span>
                          </td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                  `}
                </div>

                <!-- Scoring Info - Collapsed by default -->
                <details class="mt-4">
                  <summary class="text-sm text-[var(--text-muted)] cursor-pointer hover:text-[var(--text-secondary)] transition-colors">
                    How scoring works
                  </summary>
                  <div class="mt-3 p-4 bg-[var(--bg-secondary)] rounded-xl text-sm text-[var(--text-secondary)] space-y-1">
                    <div><span class="text-[var(--text-primary)]">Total Score</span> = Contest Score + Vote Score</div>
                    <div><span class="text-[var(--text-primary)]">Contest Score</span> = (Social Ã— 3) + Token</div>
                    <div><span class="text-[var(--text-primary)]">Vote Score</span> = (Upvotes - Downvotes) Ã— 200</div>
                  </div>
                </details>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderActiveContests() {
      const activeContests = state.upcomingContests.filter(c => new Date(c.endTime) > new Date()).slice(0, 20);

      let contestsHtml = '';
      if (activeContests.length > 0) {
        contestsHtml = activeContests.map(contest => {
          const now = new Date();
          const isLive = new Date(contest.startTime) <= now && new Date(contest.endTime) > now;
          const isPending = contest.status === 1;
          const timeLeft = Math.max(0, Math.floor((new Date(contest.endTime) - now) / 1000));
          const hoursLeft = Math.floor(timeLeft / 3600);
          const minutesLeft = Math.floor((timeLeft % 3600) / 60);

          const statusTag = isLive
            ? '<span class="tag tag-success"><span class="w-1.5 h-1.5 rounded-full bg-[var(--success)] animate-pulse"></span>Live</span>'
            : isPending
            ? '<span class="tag tag-warning">Pending</span>'
            : '<span class="tag tag-accent">Upcoming</span>';

          const hostImg = contest.hostUser?.pfpUrl ? `<img src="${contest.hostUser.pfpUrl}" class="w-7 h-7 rounded-full" onerror="this.style.display='none'" />` : '';
          const hostName = contest.hostUser?.username ? '@' + contest.hostUser.username : contest.host.slice(0, 10) + '...';

          let prizeHtml = '';
          if (contest.isNft) {
            const nftImg = contest.nftImage
              ? `<img src="${contest.nftImage}" alt="${contest.nftName || ''}" class="w-10 h-10 rounded-lg object-cover" onerror="this.style.display='none'" />`
              : `<div class="w-10 h-10 rounded-lg bg-purple-500/20 flex items-center justify-center text-purple-400 text-xs">NFT</div>`;
            prizeHtml = `
              <div class="flex items-center gap-2">
                ${nftImg}
                <div>
                  <div class="text-sm font-semibold text-[var(--success)]">${contest.nftName || contest.prize || 'NFT Prize'}</div>
                  <span class="text-xs text-[var(--text-muted)]">${contest.nftCollection || contest.nftType || 'NFT'}</span>
                </div>
              </div>
            `;
          } else {
            prizeHtml = `<div class="text-sm font-semibold text-[var(--success)]">${contest.prize}</div>`;
          }

          let reqTags = '';
          if (contest.requireRecast) reqTags += '<span class="tag tag-accent">Recast</span>';
          if (contest.requireLike) reqTags += '<span class="tag tag-accent">Like</span>';
          if (contest.requireReply) reqTags += '<span class="tag tag-accent">Reply</span>';
          if (contest.volumeRequirement > 0) reqTags += `<span class="tag tag-warning">$${contest.volumeRequirement} vol</span>`;
          if (!contest.requireRecast && !contest.requireLike && !contest.requireReply && !contest.volumeRequirement) {
            reqTags = '<span class="tag" style="background: var(--bg-tertiary); color: var(--text-secondary);">Open to all</span>';
          }

          // Extract just the cast hash (before any | character) from castId
          const castHashForView = contest.castId ? contest.castId.split('|')[0] : '';
          const viewBtn = castHashForView ? `
            <a
              href="https://warpcast.com/~/conversations/${castHashForView}"
              target="_blank"
              class="btn-secondary text-sm py-2 px-4"
            >
              View
            </a>
          ` : '';

          return `
            <div class="p-4 rounded-xl bg-[var(--bg-secondary)] border border-[var(--border-subtle)] hover:border-[var(--border-light)] transition-all">
              <div class="flex items-start justify-between gap-4">
                <div class="flex-1 min-w-0">
                  <div class="flex items-center gap-2 mb-3">
                    ${statusTag}
                    <span class="text-sm text-[var(--text-muted)]">#${contest.contestId}</span>
                  </div>
                  <div class="flex items-center gap-2 mb-3">
                    ${hostImg}
                    <span class="font-medium text-[var(--text-primary)]">${hostName}</span>
                  </div>
                  <div class="grid grid-cols-2 gap-3 mb-3">
                    <div>
                      <div class="text-xs text-[var(--text-muted)] mb-0.5">Prize</div>
                      ${prizeHtml}
                    </div>
                    <div>
                      <div class="text-xs text-[var(--text-muted)] mb-0.5">Time Left</div>
                      <div class="text-sm font-semibold text-[var(--text-primary)]">${hoursLeft}h ${minutesLeft}m</div>
                    </div>
                  </div>
                  <div class="flex flex-wrap gap-1.5 mb-3">
                    ${reqTags}
                  </div>
                  <div class="flex gap-2 flex-wrap">
                    <button
                      data-contest-id="${contest.contestId}"
                      data-prize="${encodeURIComponent(contest.prize)}"
                      data-hours="${hoursLeft}"
                      data-minutes="${minutesLeft}"
                      data-volume="${contest.volumeRequirement || 0}"
                      data-token="${encodeURIComponent(contest.tokenRequirementSymbol || '')}"
                      data-host="${encodeURIComponent(contest.hostUser?.username || '')}"
                      data-recast="${contest.requireRecast || false}"
                      data-like="${contest.requireLike || false}"
                      data-reply="${contest.requireReply || false}"
                      data-cast-id="${contest.castId || ''}"
                      data-is-nft="${contest.isNft || false}"
                      data-nft-image="${encodeURIComponent(contest.nftImage || '')}"
                      onclick="openCastModalFromData(this)"
                      class="btn-primary text-sm py-2 px-4"
                    >
                      Share
                    </button>
                    ${viewBtn}
                  </div>
                </div>
              </div>
            </div>
          `;
        }).join('');
      }

      const moreText = state.upcomingContests.length > 20
        ? `<div class="mt-4 text-center text-sm text-[var(--text-muted)]">+ ${state.upcomingContests.length - 20} more contests</div>`
        : '';

      if (state.upcomingContests.length > 0) {
        return `
          <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
            <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>
            <div class="max-w-6xl mx-auto relative z-10">
              ${renderHeader()}
              <div class="glass-card p-5">
                <div class="flex items-center justify-between mb-4">
                  <div>
                    <h2 class="text-xl font-bold"><span class="text-[var(--text-primary)]">Active</span> <span class="text-gradient">Contests</span></h2>
                    <p class="text-sm text-[var(--text-muted)]">${state.upcomingContests.length} live now</p>
                  </div>
                  <div class="flex items-center gap-2">
                    <div class="w-2 h-2 rounded-full bg-[var(--success)] animate-pulse"></div>
                    <button onclick="checkAllEligibility()" class="btn-accent text-sm py-2 px-4">Check Eligibility</button>
                  </div>
                </div>
                <div class="space-y-3">${contestsHtml}</div>
                ${moreText}
              </div>
            </div>
          </div>
        `;
      } else {
        return `
          <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
            <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>
            <div class="max-w-6xl mx-auto relative z-10">
              ${renderHeader()}
              <div class="glass-card p-8 text-center">
                <div class="text-4xl mb-4">ðŸ¸</div>
                <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-2">No Active Contests</h3>
                <p class="text-sm text-[var(--text-muted)] mb-4">Be the first to create one!</p>
                <button onclick="state.currentView = 'create'; render();" class="btn-primary">Create Contest</button>
              </div>
            </div>
          </div>
        `;
      }
    }

    function renderHistory() {
      return `
        <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>

          <div class="max-w-6xl mx-auto relative z-10">
            ${renderHeader()}

            <!-- Stats Summary -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-4">
              <div class="stat-card">
                <div class="stat-label">Total Contests</div>
                <div class="stat-value stat-value-sm">${state.historyTotal || 0}</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Completed</div>
                <div class="stat-value stat-value-sm text-[var(--success)]">${(state.historyData || []).filter(c => c.status === 2).length}</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Active</div>
                <div class="stat-value stat-value-sm text-[var(--info)]">${(state.historyData || []).filter(c => c.status === 0).length}</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Pending VRF</div>
                <div class="stat-value stat-value-sm text-[var(--warning)]">${(state.historyData || []).filter(c => c.status === 1).length}</div>
              </div>
            </div>

            <!-- Contest History Table -->
            <div class="glass-card p-5">
              <div class="flex items-center justify-between mb-5">
                <div>
                  <h2 class="text-xl font-bold text-[var(--text-primary)]">Contest History</h2>
                  <p class="text-sm text-[var(--text-muted)]">Last 20 contests</p>
                </div>
                <div class="flex items-center gap-2">
                  <a
                    href="https://github.com/95m6sbvh6c-byte/neynartode/blob/main/docs/GUIDE_HISTORY.md"
                    target="_blank"
                    class="btn-ghost text-sm"
                  >Guide</a>
                  <button onclick="loadHistory()" class="btn-secondary text-sm py-2 px-3">
                    Refresh
                  </button>
                </div>
              </div>

              ${state.historyLoading ? `
                <div class="text-center py-12">
                  <div class="w-16 h-16 mx-auto mb-4 animate-bounce">
                    <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-contain" style="filter: drop-shadow(0 0 15px rgba(139, 92, 246, 0.5));" />
                  </div>
                  <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-2">Loading Contests...</h3>
                  <p class="text-[var(--text-muted)] text-sm">Fetching on-chain data</p>
                </div>
              ` : state.historyError ? `
                <div class="text-center py-12">
                  <div class="text-5xl mb-4 opacity-50">âŒ</div>
                  <h3 class="text-lg font-semibold text-[var(--error)] mb-2">Error Loading History</h3>
                  <p class="text-[var(--text-muted)] text-sm mb-4">${state.historyError}</p>
                  <button onclick="loadHistory()" class="btn-secondary text-sm">
                    Try Again
                  </button>
                </div>
              ` : state.historyData.length === 0 ? `
                <div class="text-center py-12">
                  <div class="w-16 h-16 mx-auto mb-4">
                    <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-contain" style="filter: drop-shadow(0 0 15px rgba(139, 92, 246, 0.5));" />
                  </div>
                  <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-2">No Contests Yet</h3>
                  <p class="text-[var(--text-secondary)] text-sm">Be the first to launch a contest!</p>
                </div>
              ` : `
                <div class="overflow-x-auto">
                  <table class="w-full">
                    <thead>
                      <tr class="border-b border-[var(--border-subtle)]">
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">#</th>
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Host</th>
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Prize</th>
                        <th class="text-center py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Duration</th>
                        <th class="text-center py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Entries</th>
                        <th class="text-center py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Status</th>
                        <th class="text-left py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Winner</th>
                        <th class="text-right py-3 px-2 text-xs font-medium text-[var(--text-muted)] uppercase tracking-wider">Ended</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${state.historyData.map(contest => `
                        <tr class="border-b border-[var(--border-subtle)] hover:bg-[var(--bg-secondary)] transition-colors">
                          <td class="py-4 px-2">
                            <div class="font-medium text-[var(--accent-light)]">${contest.contestId}</div>
                          </td>
                          <td class="py-4 px-2">
                            ${contest.hostUser ? `
                              <a href="https://warpcast.com/${contest.hostUser.username}" target="_blank" class="flex flex-col items-center hover:opacity-80 transition-opacity">
                                ${contest.hostUser.pfpUrl
                                  ? `<img src="${contest.hostUser.pfpUrl}" alt="" class="w-7 h-7 rounded-full object-cover mb-1" onerror="this.style.display='none';" />`
                                  : `<span class="w-7 h-7 rounded-full bg-[var(--bg-tertiary)] flex items-center justify-center text-xs mb-1">ðŸ‘¤</span>`
                                }
                                <span class="text-xs font-medium text-[var(--text-primary)]">@${contest.hostUser.username}</span>
                              </a>
                            ` : `
                              <span class="font-mono text-xs text-[var(--text-muted)]">${contest.host.slice(0, 8)}...</span>
                            `}
                          </td>
                          <td class="py-4 px-2">
                            <div class="font-medium text-[var(--success)]">
                              ${contest.prizeAmount.toLocaleString(undefined, { maximumFractionDigits: 4 })} $${contest.prizeTokenSymbol}
                            </div>
                            ${contest.volumeRequirement > 0 ? `
                              <div class="text-xs text-[var(--text-muted)]">
                                Min: $${contest.volumeRequirement}
                              </div>
                            ` : ''}
                          </td>
                          <td class="py-4 px-2 text-center">
                            <span class="text-[var(--text-secondary)]">
                              ${formatDuration(contest.durationHours, contest.durationMinutes)}
                            </span>
                          </td>
                          <td class="py-4 px-2 text-center">
                            <span class="tag tag-accent">${contest.participantCount}</span>
                          </td>
                          <td class="py-4 px-2 text-center">
                            <span class="tag ${contest.status === 0 ? 'tag-accent' : contest.status === 1 ? 'tag-warning' : contest.status === 2 ? 'tag-success' : 'tag-error'}">
                              ${contest.statusText}
                            </span>
                          </td>
                          <td class="py-4 px-2">
                            ${contest.status === 2 && contest.winner !== '0x0000000000000000000000000000000000000000' ? `
                              ${contest.winnerUser ? `
                                <a href="https://warpcast.com/${contest.winnerUser.username}" target="_blank" class="flex flex-col items-center hover:opacity-80 transition-opacity">
                                  ${contest.winnerUser.pfpUrl
                                    ? `<img src="${contest.winnerUser.pfpUrl}" alt="" class="w-7 h-7 rounded-full object-cover mb-1" onerror="this.style.display='none';" />`
                                    : `<span class="w-7 h-7 rounded-full bg-[var(--bg-tertiary)] flex items-center justify-center text-xs mb-1">ðŸ†</span>`
                                  }
                                  <span class="text-xs font-medium text-yellow-400">@${contest.winnerUser.username}</span>
                                </a>
                              ` : `
                                <span class="font-mono text-xs text-[var(--text-muted)]">${contest.winner.slice(0, 8)}...</span>
                              `}
                            ` : `
                              <span class="text-[var(--text-muted)]">â€”</span>
                            `}
                          </td>
                          <td class="py-4 px-2 text-right">
                            <span class="text-sm text-[var(--text-muted)]">
                              ${formatDate(contest.endTime)}
                            </span>
                          </td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>

                <!-- Legend - collapsed -->
                <details class="mt-4">
                  <summary class="text-sm text-[var(--text-muted)] cursor-pointer hover:text-[var(--text-secondary)] transition-colors">
                    Status legend
                  </summary>
                  <div class="mt-3 flex flex-wrap gap-2 text-xs">
                    <span class="tag tag-accent">Active</span>
                    <span class="tag tag-warning">PendingVRF</span>
                    <span class="tag tag-success">Completed</span>
                    <span class="tag tag-error">Cancelled</span>
                  </div>
                </details>
              `}
            </div>
          </div>
        </div>
      `;
    }

    function renderSuggestions() {
      const isDev = isDevWallet(state.userAddress);

      // Build DEV-only suggestions list
      let suggestionsHtml = '';
      if (isDev) {
        if (state.suggestionsLoading) {
          suggestionsHtml = `
            <div class="text-center py-8">
              <div class="text-3xl mb-2 animate-bounce opacity-50">ðŸ’¡</div>
              <p class="text-[var(--text-muted)]">Loading...</p>
            </div>
          `;
        } else if (state.suggestions.length === 0) {
          suggestionsHtml = `
            <div class="text-center py-8">
              <div class="text-3xl mb-2 opacity-50">ðŸ“­</div>
              <p class="text-[var(--text-muted)]">No suggestions yet</p>
            </div>
          `;
        } else {
          suggestionsHtml = `
            <div class="space-y-3 max-h-80 overflow-y-auto">
              ${state.suggestions.map(s => `
                <div class="bg-[var(--bg-tertiary)] rounded-lg p-4">
                  <div class="flex items-start justify-between gap-3">
                    <p class="text-[var(--text-primary)] flex-1 text-sm">${s.text}</p>
                    <span class="text-xs text-[var(--text-muted)] whitespace-nowrap">${new Date(s.timestamp).toLocaleDateString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
            <p class="text-xs text-[var(--text-muted)] mt-4">${state.suggestions.length} total</p>
          `;
        }
      }

      return `
        <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>

          <div class="max-w-2xl mx-auto relative z-10">
            ${renderHeader()}

            <div class="glass-card p-5">
              <div class="mb-6">
                <h2 class="text-xl font-bold text-[var(--text-primary)]">Suggestion Box</h2>
                <p class="text-sm text-[var(--text-muted)]">Help us improve NEYNARtodes</p>
              </div>

              <!-- Submission Form -->
              <div class="space-y-4 mb-6">
                <p class="text-sm text-[var(--text-secondary)]">
                  Submissions are <span class="text-[var(--accent-light)]">completely anonymous</span>
                </p>
                <textarea
                  id="suggestionInput"
                  placeholder="Share your idea, feedback, or suggestion..."
                  class="input-modern resize-none h-28"
                  maxlength="1000"
                >${state.suggestionText}</textarea>
                <div class="flex items-center justify-between">
                  <span class="text-xs text-[var(--text-muted)]">${state.suggestionText.length}/1000</span>
                  <button
                    id="submitSuggestion"
                    class="btn-primary py-2 px-5 text-sm disabled:opacity-50"
                    ${state.suggestionText.trim().length < 10 ? 'disabled' : ''}
                  >
                    Submit
                  </button>
                </div>
              </div>

              ${isDev ? `
              <!-- DEV Only: View All Suggestions -->
              <div class="p-4 bg-[var(--bg-secondary)] rounded-xl border border-[var(--warning)] border-opacity-30">
                <div class="flex items-center justify-between mb-4">
                  <h3 class="text-sm font-medium text-[var(--warning)]">Dev: All Suggestions</h3>
                  <button id="refreshSuggestions" class="btn-ghost text-xs">
                    Refresh
                  </button>
                </div>
                ${suggestionsHtml}
              </div>
              ` : `
              <!-- Non-DEV: Thank you message -->
              <div class="p-4 bg-[var(--bg-secondary)] rounded-xl text-center">
                <p class="text-[var(--text-secondary)] text-sm">
                  Thank you for helping improve NEYNARtodes
                </p>
              </div>
              `}
            </div>
          </div>
        </div>
      `;
    }

    function renderCreateContest() {
      return `
        <div class="min-h-screen p-4 md:p-6" style="background: var(--bg-primary);">
          <div class="fixed inset-0 pointer-events-none" style="background: radial-gradient(ellipse at top, rgba(139, 92, 246, 0.08) 0%, transparent 50%);"></div>

          <div class="max-w-2xl mx-auto relative z-10">
            ${renderHeader()}

            <!-- Safeguards Notice - collapsible -->
            <details class="glass-card p-4 mb-4">
              <summary class="font-medium text-[var(--text-primary)] cursor-pointer flex items-center justify-between">
                <span>Season 0 Safeguards</span>
                <span class="tag tag-accent">Active</span>
              </summary>
              <div class="mt-3 text-sm text-[var(--text-secondary)] space-y-1">
                <p>â€¢ Whitelist required for participation</p>
                <p>â€¢ Minimum 20,000 $NEYNARTODES token gate</p>
                <p>â€¢ 4+ words required per reply</p>
                <p>â€¢ $20 min volume for NEYNARTODES</p>
              </div>
            </details>

            <div class="glass-card p-5">
              <div class="flex items-center justify-between mb-6">
                <h2 class="text-xl font-bold text-[var(--text-primary)]">Create Contest</h2>
                <a
                  href="https://github.com/95m6sbvh6c-byte/neynartode/blob/main/docs/GUIDE_CREATE.md"
                  target="_blank"
                  class="btn-ghost text-sm"
                >Guide</a>
              </div>

              <div class="space-y-6">
                <!-- Contest Period -->
                <div class="space-y-4">
                  <h3 class="text-sm font-medium text-[var(--accent-light)] uppercase tracking-wider">Duration</h3>

                  <div>
                    <label class="block text-sm text-[var(--text-secondary)] mb-2">Start Mode</label>
                    <div class="flex gap-2">
                      <button id="startNow" class="flex-1 py-2.5 rounded-xl font-medium transition-all ${state.startMode === 'now' ? 'bg-[var(--accent)] text-white' : 'bg-[var(--bg-tertiary)] text-[var(--text-secondary)] hover:text-[var(--text-primary)]'}">
                        Start Now
                      </button>
                      <button id="startScheduled" class="flex-1 py-2.5 rounded-xl font-medium transition-all ${state.startMode === 'scheduled' ? 'bg-[var(--accent)] text-white' : 'bg-[var(--bg-tertiary)] text-[var(--text-secondary)] hover:text-[var(--text-primary)]'}">
                        Schedule
                      </button>
                    </div>
                  </div>

                  ${state.startMode === 'scheduled' ? `
                    <div>
                      <label class="block text-sm text-[var(--text-secondary)] mb-2">Start Date & Time</label>
                      <input type="datetime-local" id="startDate" value="${state.startDate}" class="input-modern" />
                    </div>
                  ` : ''}

                  <div>
                    <label class="block text-sm text-[var(--text-secondary)] mb-2">Contest Duration</label>
                    <div class="grid grid-cols-2 gap-3">
                      <div>
                        <label class="block text-xs text-[var(--text-muted)] mb-1">Hours</label>
                        <input type="number" id="durationHours" value="${state.durationHours}" min="0" max="720" class="input-modern" />
                      </div>
                      <div>
                        <label class="block text-xs text-[var(--text-muted)] mb-1">Minutes</label>
                        <input type="number" id="durationMinutes" value="${state.durationMinutes}" min="0" max="59" class="input-modern" />
                      </div>
                    </div>
                  </div>

                  ${state.startMode === 'scheduled' && state.startDate && state.durationHours !== '' && state.durationMinutes !== '' ? `
                    <div class="p-3 bg-[var(--bg-secondary)] rounded-xl text-sm">
                      <div class="text-[var(--text-muted)] mb-1">Timeline</div>
                      <div class="text-[var(--text-primary)]">
                        Starts: ${new Date(state.startDate).toLocaleString()}<br/>
                        Duration: ${state.durationHours}h ${state.durationMinutes}m<br/>
                        Ends: ${(() => {
                          const start = new Date(state.startDate);
                          const hours = parseInt(state.durationHours) || 0;
                          const minutes = parseInt(state.durationMinutes) || 0;
                          const end = new Date(start.getTime() + (hours * 60 + minutes) * 60 * 1000);
                          return end.toLocaleString();
                        })()}
                      </div>
                    </div>
                  ` : state.startMode === 'now' && state.durationHours !== '' && state.durationMinutes !== '' ? `
                    <div class="p-3 bg-[var(--bg-secondary)] rounded-xl text-sm">
                      <div class="text-[var(--text-muted)] mb-1">Timeline</div>
                      <div class="text-[var(--text-primary)]">
                        Starts immediately â€¢ Duration: ${state.durationHours}h ${state.durationMinutes}m
                      </div>
                    </div>
                  ` : ''}
                </div>

                <div class="divider"></div>

                <!-- Prize Settings -->
                <div class="space-y-4">
                  <h3 class="text-sm font-medium text-[var(--accent-light)] uppercase tracking-wider">Prize</h3>

                  <!-- Prize Type Toggle -->
                  <div class="flex gap-2">
                    <button onclick="state.prizeType = 'token'; render();" class="flex-1 py-3 px-4 rounded-xl text-sm font-medium transition-all ${state.prizeType === 'token' ? 'bg-[var(--accent)] text-white' : 'bg-[var(--bg-secondary)] text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)]'}">
                      Token
                    </button>
                    ${isDevWallet(state.userAddress) ? `
                      <button onclick="state.prizeType = 'nft'; render();" class="flex-1 py-3 px-4 rounded-xl text-sm font-medium transition-all ${state.prizeType === 'nft' ? 'bg-[var(--accent)] text-white' : 'bg-[var(--bg-secondary)] text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)]'}">
                        NFT (Dev)
                      </button>
                    ` : `
                      <button disabled class="flex-1 py-3 px-4 rounded-xl text-sm font-medium bg-[var(--bg-secondary)] text-[var(--text-muted)] opacity-50 cursor-not-allowed" title="Coming soon">
                        NFT (Soon)
                      </button>
                    `}
                  </div>

                  ${state.prizeType === 'token' ? `
                    <!-- Token Prize -->
                    <div class="relative">
                      <label class="block text-sm text-[var(--text-secondary)] mb-2">Search Token</label>
                      <input type="text" id="prizeTokenSearch" value="${state.prizeTokenSearch}" placeholder="USDC, ETH, NEYNARTODES..." class="input-modern" />
                      ${state.showPrizeTokenSuggestions ? `
                        <div class="absolute z-10 w-full mt-1 bg-[var(--bg-secondary)] border border-[var(--border-light)] rounded-xl shadow-lg max-h-64 overflow-y-auto">
                          ${searchTokens(state.prizeTokenSearch).map((token, idx) => `
                            <button onclick="selectPrizeToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-[var(--bg-tertiary)] border-b border-[var(--border-subtle)] transition-colors flex items-center gap-3">
                              <img src="${token.image}" alt="${token.ticker}" class="w-8 h-8 rounded-full object-cover" onerror="this.src='https://via.placeholder.com/32/8b5cf6/ffffff?text=${token.ticker[0]}'" />
                              <div class="flex-1 min-w-0">
                                <div class="font-medium text-[var(--text-primary)]">${token.ticker}</div>
                                <div class="text-xs text-[var(--text-muted)] truncate">${token.name}</div>
                              </div>
                              <div class="text-right">
                                <div class="text-sm font-medium text-[var(--success)]">$${(token.mcap / 1000000).toFixed(1)}M</div>
                              </div>
                            </button>
                          `).join('')}
                        </div>
                      ` : ''}
                    </div>

                    ${state.prizeTokenAddress ? `
                      <div class="p-4 bg-[var(--bg-secondary)] rounded-xl flex items-center gap-3">
                        <img src="${state.prizeTokenImage}" alt="${state.prizeTokenTicker}" class="w-10 h-10 rounded-full object-cover" onerror="this.src='https://via.placeholder.com/40/8b5cf6/ffffff?text=${state.prizeTokenTicker[0]}'" />
                        <div class="flex-1">
                          <div class="text-xs text-[var(--success)] mb-0.5">Selected</div>
                          <div class="font-medium text-[var(--text-primary)]">${state.prizeTokenTicker}</div>
                        </div>
                      </div>
                    ` : ''}

                    <div>
                      <label class="block text-sm text-[var(--text-secondary)] mb-2">Prize Amount</label>
                      <input type="number" id="prizeTokenAmount" value="${state.prizeTokenAmount}" placeholder="1000" class="input-modern" />
                    </div>
                  ` : `
                    <!-- NFT Prize -->
                    <div class="space-y-3">
                      <div>
                        <label class="block text-sm text-[var(--text-secondary)] mb-2">NFT Contract Address</label>
                        <input type="text" id="prizeNftAddress" value="${state.prizeNftAddress}" placeholder="0x..." class="input-modern" />
                      </div>
                      <div>
                        <label class="block text-sm text-[var(--text-secondary)] mb-2">Token ID</label>
                        <div class="flex gap-2">
                          <input type="text" id="prizeNftTokenId" value="${state.prizeNftTokenId}" placeholder="1" class="input-modern flex-1" />
                          <button onclick="loadNftMetadata()" class="btn-primary px-4 py-2 text-sm whitespace-nowrap" ${state.loadingNftMetadata ? 'disabled' : ''}>
                            ${state.loadingNftMetadata ? '<span class="animate-spin">...</span>' : 'Load NFT'}
                          </button>
                        </div>
                      </div>

                      ${state.prizeNftImage ? `
                        <div class="p-4 bg-[var(--bg-secondary)] rounded-xl">
                          <div class="flex gap-4">
                            <img src="${state.prizeNftImage}" alt="${state.prizeNftName}" class="w-24 h-24 rounded-xl object-cover" onerror="this.src='https://via.placeholder.com/96/8b5cf6/ffffff?text=NFT'" />
                            <div class="flex-1">
                              <div class="text-xs text-[var(--success)] mb-1">NFT Loaded</div>
                              <div class="font-medium text-[var(--text-primary)] mb-1">${state.prizeNftName}</div>
                              <div class="text-xs text-[var(--text-muted)]">${state.prizeNftCollection}</div>
                              <div class="mt-2">
                                <span class="tag tag-accent">${state.prizeNftType}</span>
                              </div>
                            </div>
                          </div>
                        </div>
                      ` : `
                        <div class="p-4 bg-[var(--bg-secondary)] rounded-xl text-center text-[var(--text-muted)] text-sm">
                          Enter contract address and token ID, then click "Load NFT" to preview
                        </div>
                      `}

                      ${state.prizeNftType === 'ERC1155' ? `
                        <div>
                          <label class="block text-sm text-[var(--text-secondary)] mb-2">Amount (ERC1155)</label>
                          <input type="number" id="prizeNftAmount" value="${state.prizeNftAmount}" placeholder="1" min="1" class="input-modern" />
                        </div>
                      ` : ''}

                      <!-- NFT Approval Step -->
                      ${state.prizeNftImage ? `
                        <div class="p-4 bg-[var(--bg-tertiary)] rounded-xl border ${state.nftApprovalStatus === 'approved' ? 'border-[var(--success)]' : 'border-[var(--warning)]'}">
                          <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium ${state.nftApprovalStatus === 'approved' ? 'text-[var(--success)]' : 'text-[var(--warning)]'}">
                              ${state.nftApprovalStatus === 'approved' ? 'NFT Approved' : state.nftApprovalStatus === 'pending' ? 'Approving...' : 'Step 1: Approve NFT'}
                            </span>
                            ${state.nftApprovalStatus === 'approved' ? '<span class="text-[var(--success)]">&#10003;</span>' : ''}
                          </div>
                          ${state.nftApprovalStatus !== 'approved' ? `
                            <p class="text-xs text-[var(--text-muted)] mb-3">
                              Before creating the contest, you must approve the escrow contract to transfer your NFT.
                            </p>
                            <button onclick="approveNftForEscrow()" class="btn-primary w-full py-2 text-sm ${state.nftApprovalStatus === 'pending' ? 'opacity-50 cursor-not-allowed' : ''}" ${state.nftApprovalStatus === 'pending' ? 'disabled' : ''}>
                              ${state.nftApprovalStatus === 'pending' ? 'Approving... Check Wallet' : 'Approve NFT for Escrow'}
                            </button>
                            ${state.nftApprovalTxHash ? `
                              <a href="https://basescan.org/tx/${state.nftApprovalTxHash}" target="_blank" class="block text-center text-xs text-[var(--accent-light)] mt-2 hover:underline">
                                View approval tx on BaseScan
                              </a>
                            ` : ''}
                          ` : `
                            <p class="text-xs text-[var(--success)]">
                              Escrow contract can transfer your NFT. You can now launch the contest.
                            </p>
                          `}
                        </div>
                      ` : ''}
                    </div>
                  `}
                </div>

                <div class="divider"></div>

                <!-- Social Dynamics -->
                <div class="space-y-4">
                  <div class="flex items-center justify-between">
                    <h3 class="text-sm font-medium text-[var(--accent-light)] uppercase tracking-wider">Social Requirements</h3>
                    <span class="tag tag-accent">Required</span>
                  </div>

                  <!-- Cast URL/Hash -->
                  <div class="p-4 bg-[var(--warning-glow)] rounded-xl border border-[var(--warning)] relative">
                    <div class="flex items-center justify-between mb-2">
                      <label class="text-sm font-medium text-[var(--warning)]">Contest Cast URL</label>
                      <button onclick="fetchRecentCasts()" class="text-xs px-3 py-1 rounded-lg bg-[var(--accent)] text-white hover:bg-[var(--accent-dark)] transition-colors flex items-center gap-1">
                        ${state.loadingRecentCasts ? '<span class="animate-spin">â³</span>' : 'ðŸ“‹'} My Recent Casts
                      </button>
                    </div>
                    <input type="text" id="castHash" value="${state.castHash}" placeholder="https://farcaster.id/username/0x1234abcd" class="input-modern" />

                    ${state.showRecentCasts ? `
                      <div class="absolute z-20 left-4 right-4 mt-2 bg-[var(--bg-secondary)] border border-[var(--border-light)] rounded-xl shadow-lg overflow-hidden">
                        <div class="flex items-center justify-between px-3 py-2 border-b border-[var(--border-subtle)]">
                          <span class="text-xs font-medium text-[var(--text-secondary)]">Select a cast</span>
                          <button onclick="state.showRecentCasts = false; render();" class="text-[var(--text-muted)] hover:text-[var(--text-primary)] text-lg">&times;</button>
                        </div>
                        ${state.recentCasts.length > 0 ? state.recentCasts.map(cast => `
                          <div class="p-3 border-b border-[var(--border-subtle)] hover:bg-[var(--bg-tertiary)] transition-colors">
                            <div class="flex items-start justify-between gap-2 mb-2">
                              <p class="text-sm text-[var(--text-primary)] flex-1">${cast.text || '(No text)'}</p>
                              <span class="text-xs text-[var(--text-muted)] whitespace-nowrap">${cast.timestamp}</span>
                            </div>
                            <div class="flex items-center gap-2">
                              <code class="text-xs text-[var(--accent-light)] bg-[var(--bg-tertiary)] px-2 py-1 rounded flex-1 truncate">${cast.hash}</code>
                              <button onclick="copyToClipboard('${cast.hash}')" class="text-xs px-2 py-1 rounded bg-[var(--bg-tertiary)] text-[var(--text-secondary)] hover:text-[var(--text-primary)] transition-colors" title="Copy hash">ðŸ“‹</button>
                              <button onclick="selectRecentCast('${cast.url}')" class="text-xs px-2 py-1 rounded bg-[var(--accent)] text-white hover:bg-[var(--accent-dark)] transition-colors">Use</button>
                            </div>
                          </div>
                        `).join('') : `
                          <div class="p-4 text-center text-[var(--text-muted)] text-sm">No recent casts found</div>
                        `}
                      </div>
                    ` : ''}

                    <p class="text-xs text-[var(--text-muted)] mt-2">Post your contest on Farcaster first, then paste the URL here</p>
                  </div>

                  <div class="grid grid-cols-3 gap-3">
                    <div>
                      <label class="block text-xs text-[var(--text-muted)] mb-2">Min Likes</label>
                      <input type="number" id="minLikes" value="${state.minLikes}" min="0" max="1" class="input-modern text-center" />
                    </div>
                    <div>
                      <label class="block text-xs text-[var(--text-muted)] mb-2">Min Recasts</label>
                      <input type="number" id="minRecasts" value="${state.minRecasts}" min="0" max="1" class="input-modern text-center" />
                    </div>
                    <div>
                      <label class="block text-xs text-[var(--text-muted)] mb-2">Min Replies</label>
                      <input type="number" id="minReplies" value="${state.minReplies}" min="0" class="input-modern text-center" />
                    </div>
                  </div>
                  <p class="text-xs text-[var(--text-muted)]">Replies require 4+ words</p>
                </div>

                <div class="divider"></div>

                <!-- Tokenomics -->
                <div class="space-y-4">
                  <div class="flex items-center justify-between">
                    <h3 class="text-sm font-medium text-[var(--accent-light)] uppercase tracking-wider">Volume Requirement</h3>
                    <label class="flex items-center gap-2 cursor-pointer">
                      <span class="text-sm text-[var(--text-secondary)]">Enable</span>
                      <div class="relative">
                        <input type="checkbox" id="tokenomicsToggle" ${state.tokenomicsEnabled ? 'checked' : ''} class="sr-only peer" />
                        <div class="w-11 h-6 bg-[var(--bg-tertiary)] peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-[var(--accent)]"></div>
                      </div>
                      ${!isDevWallet(state.userAddress) && !state.tokenomicsEnabled ? `<span class="text-xs text-[var(--warning)]">-0.001 ETH</span>` : ''}
                    </label>
                  </div>

                  ${state.tokenomicsEnabled ? `
                  <div class="space-y-4">
                    <!-- Default Token -->
                    <div class="p-4 bg-[var(--bg-secondary)] rounded-xl flex items-center gap-3">
                      <div class="w-10 h-10 rounded-full overflow-hidden">
                        <img src="/neynartode-sticker.png" alt="Neynartode" class="w-full h-full object-cover" style="filter: drop-shadow(0 0 8px rgba(139, 92, 246, 0.6));" />
                      </div>
                      <div class="flex-1">
                        <div class="text-xs text-[var(--success)] mb-0.5">Default (Free)</div>
                        <div class="font-medium text-[var(--text-primary)]">NEYNARTODES</div>
                      </div>
                    </div>

                    <!-- Custom Token Option -->
                    <div class="p-4 border border-dashed border-[var(--border-light)] rounded-xl">
                      <div class="flex items-center gap-2 mb-3">
                        <input type="checkbox" id="useCustomToken" ${state.useCustomTokenMode || (state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase()) ? 'checked' : ''} class="w-4 h-4 rounded border-[var(--border-light)] text-[var(--accent)] focus:ring-[var(--accent)]" />
                        <label for="useCustomToken" class="text-sm text-[var(--text-secondary)]">Custom token <span class="text-[var(--warning)]">(+0.01 ETH)</span></label>
                      </div>

                      <div id="customTokenSection" class="${state.useCustomTokenMode || (state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase()) ? '' : 'hidden'}">
                        <div class="relative mb-3">
                          <input type="text" id="tokenSearch" value="${state.tokenSearch}" placeholder="Search token..." class="input-modern" />
                          ${state.showTokenSuggestions ? `
                            <div class="absolute z-10 w-full mt-1 bg-[var(--bg-secondary)] border border-[var(--border-light)] rounded-xl shadow-lg max-h-64 overflow-y-auto">
                              ${searchTokens(state.tokenSearch).map((token, idx) => `
                                <button onclick="selectToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-[var(--bg-tertiary)] border-b border-[var(--border-subtle)] transition-colors flex items-center gap-3">
                                  <img src="${token.image}" alt="${token.ticker}" class="w-8 h-8 rounded-full object-cover" onerror="this.src='https://via.placeholder.com/32/8b5cf6/ffffff?text=${token.ticker[0]}'" />
                                  <div class="flex-1 min-w-0">
                                    <div class="font-medium text-[var(--text-primary)]">${token.ticker}</div>
                                  </div>
                                  <div class="text-sm text-[var(--success)]">$${(token.mcap / 1000000).toFixed(1)}M</div>
                                </button>
                              `).join('')}
                            </div>
                          ` : ''}
                        </div>

                        <!-- Custom Token Address Button -->
                        <button onclick="showCustomTokenModal()" class="w-full mb-3 px-4 py-2 bg-[var(--accent)] text-white rounded-lg hover:bg-[var(--accent-dark)] transition-colors text-sm font-medium flex items-center justify-center gap-2">
                          <span>âž•</span> Enter Token Address
                        </button>

                        ${state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase() ? `
                          <div class="p-3 bg-[var(--bg-tertiary)] rounded-lg flex items-center gap-3">
                            <img src="${state.tokenImage}" alt="${state.tokenTicker}" class="w-8 h-8 rounded-full" onerror="this.style.display='none'" />
                            <div class="flex-1">
                              <div class="text-xs text-[var(--warning)] mb-0.5">Custom (+0.01 ETH)</div>
                              <div class="font-medium text-[var(--text-primary)]">${state.tokenTicker}</div>
                            </div>
                          </div>
                        ` : ''}
                      </div>
                    </div>

                    <!-- Volume Input -->
                    <div>
                      <label class="block text-sm text-[var(--text-secondary)] mb-2">Min Volume ($)</label>
                      ${state.tokenAddress && state.tokenAddress.toLowerCase() === CONFIG.CONTRACTS.neynartodes.toLowerCase() ? `
                        <input type="number" id="minTradeVolume" value="20" readonly class="input-modern opacity-60 cursor-not-allowed" />
                        <p class="text-xs text-[var(--text-muted)] mt-1">NEYNARTODES locked at $20</p>
                      ` : `
                        <input type="number" id="minTradeVolume" value="${state.minTradeVolume}" placeholder="0" class="input-modern" />
                        <p class="text-xs text-[var(--text-muted)] mt-1">Max = prize amount</p>
                      `}
                    </div>
                  </div>
                  ` : `
                  <div class="p-4 bg-[var(--bg-secondary)] rounded-xl text-center">
                    <p class="text-[var(--text-secondary)] text-sm">No volume requirements</p>
                  </div>
                  `}
                </div>

                <div class="divider"></div>

                <!-- Winner Announcement -->
                <div class="space-y-3">
                  <h3 class="text-sm font-medium text-[var(--accent-light)] uppercase tracking-wider">Winner Message</h3>
                  <textarea id="customMessage" rows="2" placeholder="You just won our amazing contest!" class="input-modern resize-none">${state.customMessage}</textarea>
                </div>

                <!-- Pending Transaction -->
                ${state.pendingTx ? `
                  <div class="p-4 bg-[var(--warning-glow)] border border-[var(--warning)] rounded-xl">
                    <div class="flex items-center justify-center gap-2 text-[var(--warning)] font-medium">
                      <span class="animate-spin">â³</span>
                      <span>Transaction pending...</span>
                    </div>
                    <a href="https://basescan.org/tx/${state.pendingTx}" target="_blank" class="block text-center text-sm text-[var(--accent-light)] mt-2 hover:underline">
                      View on BaseScan
                    </a>
                  </div>
                ` : ''}

                <!-- Launch Button -->
                ${(() => {
                  // Check if NFT contest needs approval first
                  const isNftContest = state.prizeType === 'nft';
                  const nftNeedsApproval = isNftContest && state.prizeNftImage && state.nftApprovalStatus !== 'approved';
                  const isDisabled = state.pendingTx || nftNeedsApproval;

                  return `
                    <button id="launchButton" class="btn-primary w-full py-4 text-lg font-semibold ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}" ${isDisabled ? 'disabled' : ''}>
                      ${state.pendingTx ? 'Launching...' : nftNeedsApproval ? 'Approve NFT First' : 'Launch Contest'}
                    </button>
                    ${nftNeedsApproval ? `
                      <p class="text-center text-sm text-[var(--warning)] mt-2">
                        Please approve your NFT above before launching
                      </p>
                    ` : ''}
                  `;
                })()}
                <p id="launchStatus" class="text-center text-sm text-[var(--accent-light)] mt-2"></p>
                <p class="text-center text-xs text-[var(--text-muted)]">
                  Prize will be locked in escrow
                </p>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // ===== DROPDOWN HELPERS =====
    function updatePrizeTokenDropdown() {
      const container = document.getElementById('prizeTokenSearch')?.parentElement;
      if (!container) return;

      // Remove old dropdown if exists
      const oldDropdown = container.querySelector('.absolute');
      if (oldDropdown) oldDropdown.remove();

      // Create new dropdown if needed
      if (state.showPrizeTokenSuggestions && state.prizeTokenSearch.length >= 2) {
        const results = searchTokens(state.prizeTokenSearch);
        const dropdown = document.createElement('div');
        dropdown.className = 'absolute z-10 w-full mt-1 bg-white border-2 border-purple-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto';
        dropdown.style.top = '100%';
        dropdown.style.left = '0';

        if (results.length === 0) {
          // Show "no results" message with option to use custom address
          dropdown.innerHTML = `
            <div class="p-4 text-center">
              <div class="text-gray-600 mb-2">No tokens found for "${state.prizeTokenSearch}"</div>
              <div class="text-xs text-gray-500 mb-3">
                Token not listed? You can use a custom address below after closing this.
              </div>
              <button onclick="showCustomPrizeToken()" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors text-sm font-semibold">
                âž• Use Custom Token Address
              </button>
            </div>
          `;
        } else {
          dropdown.innerHTML = results.map((token, idx) => `
            <button onclick="selectPrizeToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-purple-50 border-b border-gray-100 transition-colors flex items-center gap-3">
              <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-purple-200" onerror="this.src='https://via.placeholder.com/40/9333ea/ffffff?text=${token.ticker[0]}'" />
              <div class="flex-1">
                <div class="font-semibold text-gray-800">${token.name} <span class="text-purple-600">(${token.ticker})</span></div>
                <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
              </div>
              <div class="text-right">
                <div class="text-xs text-gray-600">Market Cap</div>
                <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
              </div>
            </button>
          `).join('') + `
            <button onclick="showCustomPrizeToken()" class="w-full text-left px-4 py-3 bg-purple-50 hover:bg-purple-100 transition-colors border-t-2 border-purple-200">
              <div class="font-semibold text-purple-700 text-center">âž• Use Custom Token Address</div>
            </button>
          `;
        }

        container.appendChild(dropdown);
      }
    }

    function updateTokenDropdown() {
      const container = document.getElementById('tokenSearch')?.parentElement;
      if (!container) return;

      // Remove old dropdown if exists
      const oldDropdown = container.querySelector('.absolute');
      if (oldDropdown) oldDropdown.remove();

      // Create new dropdown if needed
      if (state.showTokenSuggestions && state.tokenSearch.length >= 2) {
        const results = searchTokens(state.tokenSearch);
        const dropdown = document.createElement('div');
        dropdown.className = 'absolute z-10 w-full mt-1 bg-white border-2 border-green-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto';
        dropdown.style.top = '100%';
        dropdown.style.left = '0';

        if (results.length === 0) {
          // Show "no results" message with option to use custom address
          dropdown.innerHTML = `
            <div class="p-4 text-center">
              <div class="text-gray-600 mb-2">No tokens found for "${state.tokenSearch}"</div>
              <div class="text-xs text-gray-500 mb-3">
                Token not listed? You can use a custom address below after closing this.
              </div>
              <button onclick="showCustomToken()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-semibold">
                âž• Use Custom Token Address
              </button>
            </div>
          `;
        } else {
          dropdown.innerHTML = results.map((token, idx) => `
            <button onclick="selectToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-green-50 border-b border-gray-100 transition-colors flex items-center gap-3">
              <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-green-200" onerror="this.src='https://via.placeholder.com/40/22c55e/ffffff?text=${token.ticker[0]}'" />
              <div class="flex-1">
                <div class="font-semibold text-gray-800">${token.name} <span class="text-green-600">(${token.ticker})</span></div>
                <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
              </div>
              <div class="text-right">
                <div class="text-xs text-gray-600">Market Cap</div>
                <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
              </div>
            </button>
          `).join('') + `
            <button onclick="showCustomToken()" class="w-full text-left px-4 py-3 bg-green-50 hover:bg-green-100 transition-colors border-t-2 border-green-200">
              <div class="font-semibold text-green-700 text-center">âž• Use Custom Token Address</div>
            </button>
          `;
        }

        container.appendChild(dropdown);
      }
    }

    // ===== EVENT LISTENERS =====
    function attachEventListeners() {
      // Login page
      const connectButton = document.getElementById('connectButton');
      if (connectButton) {
        connectButton.onclick = connectWallet;
      }

      // Buy token button - opens Warpcast wallet swap directly in-app
      const buyTokenButton = document.getElementById('buyTokenButton');
      if (buyTokenButton) {
        buyTokenButton.onclick = async () => {
          // Use CONFIG for token address and chain ID
          const tokenAddress = CONFIG.CONTRACTS.neynartodes;
          // CAIP-19 format: eip155:{chainId}/erc20:{tokenAddress}
          const buyTokenCaip19 = `eip155:${CONFIG.CHAIN_ID}/erc20:${tokenAddress}`;
          const sdk = window.FarcasterSDK;

          if (sdk && sdk.actions && sdk.actions.swapToken) {
            try {
              // Use native SDK swapToken action - opens swap form in-app
              await sdk.actions.swapToken({
                buyToken: buyTokenCaip19
              });
            } catch (e) {
              console.log('Swap error:', e);
              showToast(`$NEYNARTODES: ${tokenAddress}`, 'info', 8000);
            }
          } else {
            // SDK not available - show contract address
            showToast(`$NEYNARTODES Contract: ${tokenAddress}`, 'info', 8000);
          }
        };
      }

      // Cast success button - on contest creation confirmation page
      const castSuccessButton = document.getElementById('castSuccessButton');
      if (castSuccessButton && state.launchSuccess) {
        castSuccessButton.onclick = () => {
          const {
            contestId,
            castHash,
            prizeAmount,
            prizeTicker,
            durationHours,
            durationMinutes,
            requireRecast,
            requireLike,
            requireReply,
            volumeReq,
            tokenTicker,
            isNft,
            nftImage,
            nftName
          } = state.launchSuccess;

          // Get user tag
          const hostUsername = state.userProfile?.username || '';

          // Build prize string - use NFT name for NFT contests
          const prize = isNft ? nftName : `${prizeAmount} $${prizeTicker}`;

          // Build duration string
          const hours = parseInt(durationHours) || 0;
          const mins = parseInt(durationMinutes) || 0;

          // Call shareContest directly (no modal needed)
          shareContest(
            contestId,
            prize,
            hours,
            mins,
            volumeReq || 0,
            tokenTicker,
            hostUsername,
            requireRecast,
            requireLike,
            requireReply,
            castHash,
            isNft,
            nftImage
          );
        };
      }

      // View switching
      const viewCreate = document.getElementById('viewCreate');
      const viewHistory = document.getElementById('viewHistory');
      const viewLeaderboard = document.getElementById('viewLeaderboard');

      if (viewCreate) viewCreate.onclick = () => {
        state.currentView = 'create';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'create' });
        stopHistoryAutoRefresh();
        stopCountdownTimer();
        render();
      };
      if (viewHistory) viewHistory.onclick = () => {
        state.currentView = 'history';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'history' });
        stopCountdownTimer();
        // Refresh history when switching to this view (manual refresh via Refresh button also available)
        loadHistory();
      };
      if (viewLeaderboard) viewLeaderboard.onclick = () => {
        state.currentView = 'leaderboard';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'leaderboard' });
        stopHistoryAutoRefresh();
        startCountdownTimer();
        render();
      };

      // Active contests tab
      const viewActive = document.getElementById('viewActive');
      if (viewActive) viewActive.onclick = () => {
        state.currentView = 'active';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'active' });
        stopHistoryAutoRefresh();
        stopCountdownTimer();
        render();
      };

      // Suggestions tab
      const viewSuggestions = document.getElementById('viewSuggestions');
      if (viewSuggestions) viewSuggestions.onclick = () => {
        state.currentView = 'suggestions';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'suggestions' });
        stopHistoryAutoRefresh();
        stopCountdownTimer();
        // Load suggestions for DEV
        if (isDevWallet(state.userAddress)) {
          loadSuggestions();
        }
        render();
      };

      // Suggestions form handlers
      const suggestionInput = document.getElementById('suggestionInput');
      if (suggestionInput) {
        // Restore value from state (preserves text across renders)
        suggestionInput.value = state.suggestionText;
        // Update state on input but DON'T re-render (prevents keyboard closing on mobile)
        suggestionInput.oninput = (e) => {
          state.suggestionText = e.target.value;
          // Update character count without full re-render
          const charCount = document.querySelector('#suggestionInput + div .text-xs');
          if (charCount) charCount.textContent = `${e.target.value.length}/1000`;
          // Update button disabled state
          const submitBtn = document.getElementById('submitSuggestion');
          if (submitBtn) submitBtn.disabled = e.target.value.trim().length < 10;
        };
      }

      const submitSuggestion = document.getElementById('submitSuggestion');
      if (submitSuggestion) {
        submitSuggestion.onclick = () => submitAnonymousSuggestion();
      }

      const refreshSuggestions = document.getElementById('refreshSuggestions');
      if (refreshSuggestions) {
        refreshSuggestions.onclick = () => loadSuggestions();
      }

      // Create contest form
      const startNow = document.getElementById('startNow');
      const startScheduled = document.getElementById('startScheduled');
      if (startNow) startNow.onclick = () => { state.startMode = 'now'; render(); };
      if (startScheduled) startScheduled.onclick = () => { state.startMode = 'scheduled'; render(); };

      // Tokenomics toggle handler
      const tokenomicsToggle = document.getElementById('tokenomicsToggle');
      if (tokenomicsToggle) {
        tokenomicsToggle.onchange = async (e) => {
          const wantsDisable = !e.target.checked;

          // Dev wallet can toggle freely
          if (isDevWallet(state.userAddress)) {
            state.tokenomicsEnabled = e.target.checked;
            if (!state.tokenomicsEnabled) {
              state.minTradeVolume = '0';
            } else {
              state.minTradeVolume = '20'; // Reset to default
            }
            render();
            return;
          }

          // Regular users must pay 0.001 ETH to disable
          if (wantsDisable) {
            const confirmed = confirm('ðŸ’° Disable Tokenomics?\n\nThis will remove all trading volume requirements.\n\nCost: 0.001 ETH\n\nProceed?');
            if (!confirmed) {
              e.target.checked = true; // Revert toggle
              return;
            }

            try {
              // Send 0.001 ETH to treasury
              const ethProvider = window.activeEthProvider || window.ethereum;
              if (!ethProvider) {
                showToast('No wallet connected!', 'error');
                e.target.checked = true;
                return;
              }

              const provider = new ethers.providers.Web3Provider(ethProvider);
              const signer = provider.getSigner();
              const fee = ethers.utils.parseEther('0.001');

              showToast('Sending 0.001 ETH fee... Confirm in wallet!', 'info');

              const tx = await signer.sendTransaction({
                to: CONFIG.CONTRACTS.treasury,
                value: fee
              });

              showToast('Transaction submitted! Waiting for confirmation...', 'info', 10000);
              await tx.wait();

              state.tokenomicsEnabled = false;
              state.minTradeVolume = '0';
              showToast('Tokenomics disabled! You can now create contests without volume requirements.', 'success');
              render();
            } catch (error) {
              console.error('Fee payment error:', error);
              showToast('Fee payment failed: ' + error.message, 'error');
              e.target.checked = true; // Revert toggle
            }
          } else {
            // Enabling is free
            state.tokenomicsEnabled = true;
            state.minTradeVolume = '10'; // Reset to default
            render();
          }
        };
      }

      // Custom token checkbox handler
      const useCustomToken = document.getElementById('useCustomToken');
      if (useCustomToken) {
        useCustomToken.onchange = (e) => {
          if (e.target.checked) {
            // Set state to show we want custom token mode
            state.useCustomTokenMode = true;
            // Clear the current token to trigger custom section display
            state.tokenAddress = '';
            state.tokenTicker = '';
            state.tokenImage = '';
            state.tokenSearch = '';
          } else {
            // Reset to default NEYNARTODES
            state.useCustomTokenMode = false;
            state.tokenAddress = CONFIG.CONTRACTS.neynartodes;
            state.tokenTicker = 'NEYNARTODES';
            state.tokenImage = '';
            state.tokenSearch = '';
            state.minTradeVolume = '20'; // Reset volume
          }
          render();
        };
      }

      const prizeTokenSearch = document.getElementById('prizeTokenSearch');
      if (prizeTokenSearch) {
        prizeTokenSearch.oninput = (e) => {
          state.prizeTokenSearch = e.target.value;
          state.showPrizeTokenSuggestions = e.target.value.length >= 2;
          // Don't call render() - let dropdown stay open and update via direct DOM manipulation
          updatePrizeTokenDropdown();
        };
        prizeTokenSearch.onfocus = (e) => {
          if (e.target.value.length >= 2) {
            state.showPrizeTokenSuggestions = true;
            updatePrizeTokenDropdown();
          }
        };
      }

      const tokenSearch = document.getElementById('tokenSearch');
      if (tokenSearch) {
        tokenSearch.oninput = (e) => {
          state.tokenSearch = e.target.value;
          state.showTokenSuggestions = e.target.value.length >= 2;
          // Don't call render() - let dropdown stay open and update via direct DOM manipulation
          updateTokenDropdown();
        };
        tokenSearch.onfocus = (e) => {
          if (e.target.value.length >= 2) {
            state.showTokenSuggestions = true;
            updateTokenDropdown();
          }
        };
      }

      // Form inputs
      const startDate = document.getElementById('startDate');
      const endDate = document.getElementById('endDate');
      const durationHours = document.getElementById('durationHours');
      const durationMinutes = document.getElementById('durationMinutes');
      const castHash = document.getElementById('castHash');
      const minLikes = document.getElementById('minLikes');
      const minRecasts = document.getElementById('minRecasts');
      const minReplies = document.getElementById('minReplies');
      const customMessage = document.getElementById('customMessage');
      const prizeTokenAmount = document.getElementById('prizeTokenAmount');
      const minTradeVolume = document.getElementById('minTradeVolume');

      if (startDate) startDate.onchange = (e) => { state.startDate = e.target.value; render(); };
      if (endDate) endDate.onchange = (e) => { state.endDate = e.target.value; };
      if (durationHours) {
        durationHours.oninput = (e) => {
          state.durationHours = e.target.value;
        };
        durationHours.onchange = (e) => {
          state.durationHours = e.target.value;
          render();
        };
        durationHours.onblur = () => { render(); };
      }
      if (durationMinutes) {
        durationMinutes.oninput = (e) => {
          state.durationMinutes = e.target.value;
        };
        durationMinutes.onchange = (e) => {
          state.durationMinutes = e.target.value;
          render();
        };
        durationMinutes.onblur = () => { render(); };
      }
      if (castHash) castHash.oninput = (e) => { state.castHash = e.target.value; };
      if (minLikes) minLikes.oninput = (e) => { state.minLikes = e.target.value; };
      if (minRecasts) minRecasts.oninput = (e) => { state.minRecasts = e.target.value; };
      if (minReplies) minReplies.oninput = (e) => { state.minReplies = e.target.value; };
      if (customMessage) customMessage.oninput = (e) => { state.customMessage = e.target.value; };
      if (prizeTokenAmount) prizeTokenAmount.oninput = (e) => { state.prizeTokenAmount = e.target.value; };
      if (minTradeVolume) minTradeVolume.oninput = (e) => { state.minTradeVolume = e.target.value; };

      // NFT Prize inputs
      const prizeNftAddress = document.getElementById('prizeNftAddress');
      const prizeNftTokenId = document.getElementById('prizeNftTokenId');
      const prizeNftAmount = document.getElementById('prizeNftAmount');
      if (prizeNftAddress) prizeNftAddress.oninput = (e) => { state.prizeNftAddress = e.target.value; };
      if (prizeNftTokenId) prizeNftTokenId.oninput = (e) => { state.prizeNftTokenId = e.target.value; };
      if (prizeNftAmount) prizeNftAmount.oninput = (e) => { state.prizeNftAmount = e.target.value; };

      const launchButton = document.getElementById('launchButton');
      if (launchButton) {
        launchButton.onclick = async () => {
          try {
            console.log('ðŸ”˜ Launch button clicked');

            // Show status in UI since alerts don't work in Warpcast
            const statusDiv = document.getElementById('launchStatus');
            if (statusDiv) statusDiv.textContent = 'Step 1: Launch clicked...';

            // Check if dev wallet (unlimited contest launches)
            const isDev = isDevWallet(state.userAddress);

          // Check if user already launched a contest today (skip for dev wallet)
          if (!isDev) {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

            if (state.lastLaunchDate) {
              const lastLaunch = new Date(state.lastLaunchDate);
              const lastLaunchDay = new Date(lastLaunch.getFullYear(), lastLaunch.getMonth(), lastLaunch.getDate());

              if (today.getTime() === lastLaunchDay.getTime()) {
                showToast('Daily Contest Limit! You can only launch 1 contest per day. Try again tomorrow!', 'warning');
                return;
              }
            }
          }

          // Validate duration
          const hours = parseInt(state.durationHours) || 0;
          const minutes = parseInt(state.durationMinutes) || 0;
          const totalMinutes = hours * 60 + minutes;

          if (totalMinutes < 1) {
            showToast('Contest duration must be at least 1 minute!', 'error');
            return;
          }

          // Validate scheduled start date
          if (state.startMode === 'scheduled' && !state.startDate) {
            showToast('Please set contest start date!', 'error');
            return;
          }

          // Validate prize based on type (token or NFT)
          if (state.prizeType === 'nft') {
            if (!state.prizeNftAddress || !state.prizeNftTokenId) {
              showToast('Please enter NFT contract address and token ID!', 'error');
              return;
            }
            if (!state.prizeNftImage) {
              showToast('Could not load NFT metadata. Please verify the contract address and token ID.', 'error');
              return;
            }
          } else {
            if (!state.prizeTokenAddress || !state.prizeTokenAmount) {
              showToast('Please select a prize token and enter the amount!', 'error');
              return;
            }
          }

          // Cast hash is ALWAYS required
          if (!state.castHash) {
            showToast('Cast Required! Post your contest announcement on Warpcast first, then paste the URL.', 'warning');
            return;
          }

          // Extract and validate cast hash
          const extractedHash = extractCastHash(state.castHash);
          if (!extractedHash) {
            showToast('Invalid cast URL/hash format. Please enter a valid Warpcast or Farcaster URL.', 'error');
            return;
          }

          // Validate cast exists (pass raw input for short hash resolution from farcaster.xyz)
          if (statusDiv) statusDiv.textContent = 'Step 2: Validating cast...';
          const castValidation = await validateCast(extractedHash, state.castHash);
          if (!castValidation.valid) {
            if (statusDiv) statusDiv.textContent = 'âŒ Cast validation failed: ' + castValidation.error;
            return;
          }

          // Check if this is the user's own cast (required for leaderboard integrity)
          if (!castValidation.isOwnCast && !isDev) {
            if (statusDiv) statusDiv.textContent = 'âŒ Not your cast! Must be your own post.';
            return;
          }

          if (statusDiv) statusDiv.textContent = 'Step 3: Cast verified âœ“ Preparing transaction...';

          // Store the validated hash (use resolved full hash if available)
          state.castHash = castValidation.hash || extractedHash;

          // Volume requirement validation (only for token contests)
          const volumeReq = parseFloat(state.minTradeVolume) || 0;

          if (state.prizeType !== 'nft') {
            const prizeAmount = parseFloat(state.prizeTokenAmount) || 0;
            const isCustomToken = state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase();

            if (isCustomToken) {
              // Custom token: volume must be <= prize amount
              if (volumeReq > prizeAmount) {
                showToast(`Volume requirement cannot exceed prize amount (${prizeAmount} ${state.prizeTokenTicker})`, 'error');
                return;
              }
            } else {
              // Default NEYNARTODES: fixed cap at $20
              if (volumeReq > 20) {
                showToast('Volume requirement cannot exceed $20 for NEYNARTODES!', 'error');
                return;
              }
            }
          } else {
            // NFT contests: volume requirement is in USD, capped at $20
            if (volumeReq > 20) {
              showToast('Volume requirement cannot exceed $20 for NFT contests!', 'error');
              return;
            }
          }

          // Ensure token address defaults to NEYNARTODES if not set
          if (!state.tokenAddress) {
            state.tokenAddress = CONFIG.CONTRACTS.neynartodes;
            state.tokenTicker = 'NEYNARTODES';
          }

          // Calculate end time
          let startTime, endTime;
          if (state.startMode === 'scheduled') {
            startTime = new Date(state.startDate);
            endTime = new Date(startTime.getTime() + totalMinutes * 60 * 1000);
          } else {
            startTime = new Date();
            endTime = new Date(startTime.getTime() + totalMinutes * 60 * 1000);
          }

          // Record this launch
          state.lastLaunchDate = new Date();

          // Add to upcoming contests
          const newContest = {
            id: Date.now(),
            contestId: null, // Will be set after on-chain tx
            host: state.userAddress,
            hostUser: state.userProfile ? {
              fid: state.userProfile.fid,
              username: state.userProfile.username,
              displayName: state.userProfile.displayName,
              pfpUrl: state.userProfile.pfpUrl
            } : null,
            prize: state.prizeType === 'token' ? `${state.prizeTokenAmount} ${state.prizeTokenTicker}` : `NFT #${state.prizeNftId}`,
            startTime: startTime,
            endTime: endTime,
            duration: `${hours}h ${minutes}m`,
            socialEnabled: state.socialEnabled,
            // Token is only enabled if tokenomics is enabled AND tokenEnabled is true
            tokenEnabled: state.tokenomicsEnabled && state.tokenEnabled,
            // Entry requirements
            requireRecast: parseInt(state.minRecasts) > 0,
            requireLike: parseInt(state.minLikes) > 0,
            requireReply: parseInt(state.minReplies) > 0,
            // Volume is locked at $10 for NEYNARTODES token, otherwise use user input
            volumeRequirement: state.tokenomicsEnabled && state.tokenEnabled ? (
              state.tokenAddress.toLowerCase() === CONFIG.CONTRACTS.neynartodes.toLowerCase()
                ? 10
                : parseFloat(state.minTradeVolume) || 0
            ) : 0,
            tokenRequirementSymbol: state.tokenomicsEnabled && state.tokenEnabled ? state.tokenTicker : null,
            status: 0, // Active
            participantCount: 0
          };

          // Launch contest on ContestEscrow contract
          // Contest is only added to state AFTER successful on-chain tx (inside launchContestOnChain)
          if (statusDiv) statusDiv.textContent = 'Step 4: Calling contract...';
          await launchContestOnChain(newContest, totalMinutes * 60);

          } catch (error) {
            console.error('âŒ Launch button error:', error);
            const statusDiv = document.getElementById('launchStatus');
            if (statusDiv) statusDiv.textContent = 'âŒ Error: ' + (error.message || error);
          }
        };
      }

      // Note: Document-level click listener for dropdown close is attached once in initDropdownCloseHandler()
    }

    // Close dropdowns when clicking outside - attached ONCE, not on every render
    let dropdownCloseHandlerAttached = false;
    function initDropdownCloseHandler() {
      if (dropdownCloseHandlerAttached) return;
      dropdownCloseHandlerAttached = true;

      document.addEventListener('click', (e) => {
        const prizeTokenSearch = document.getElementById('prizeTokenSearch');
        const tokenSearch = document.getElementById('tokenSearch');

        // Close prize token dropdown if clicking outside
        if (prizeTokenSearch && !prizeTokenSearch.parentElement.contains(e.target)) {
          state.showPrizeTokenSuggestions = false;
          updatePrizeTokenDropdown();
        }

        // Close tokenomics dropdown if clicking outside
        if (tokenSearch && !tokenSearch.parentElement.contains(e.target)) {
          state.showTokenSuggestions = false;
          updateTokenDropdown();
        }
      });
    }

    // ContestEscrow ABI for creating contests
    const CONTEST_ESCROW_ABI = [
      'function createContestETH(uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function createContestERC20(address _prizeToken, uint256 _prizeAmount, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function getContest(uint256 _contestId) external view returns (address host, address prizeToken, uint256 prizeAmount, uint256 startTime, uint256 endTime, string memory castId, address tokenRequirement, uint256 volumeRequirement, uint8 status, address winner)',
      'function customTokenFee() external view returns (uint256)',
      'function defaultToken() external view returns (address)',
      'event ContestCreated(uint256 indexed contestId, address indexed host, address prizeToken, uint256 prizeAmount, uint256 endTime, string castId)'
    ];

    const ERC20_ABI = [
      'function approve(address spender, uint256 amount) external returns (bool)',
      'function allowance(address owner, address spender) external view returns (uint256)',
      'function balanceOf(address account) external view returns (uint256)',
      'function decimals() external view returns (uint8)'
    ];

    const NFT_CONTEST_ESCROW_ABI = [
      // Legacy functions (may fail for restricted NFTs)
      'function createContestERC721(address _nftContract, uint256 _tokenId, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function createContestERC1155(address _nftContract, uint256 _tokenId, uint256 _amount, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      // V3 functions for two-step flow (user transfers NFT first, then registers)
      'function registerContest(uint256 depositId, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function withdrawDeposit(uint256 depositId) external',
      'function nftToDepositId(address nftContract, uint256 tokenId) external view returns (uint256)',
      'function getPendingDeposit(uint256 depositId) external view returns (address depositor, uint8 nftType, address nftContract, uint256 tokenId, uint256 amount, uint256 depositTime, bool claimed)',
      // Common functions
      'function contestFee() external view returns (uint256)',
      'function defaultToken() external view returns (address)',
      // Events
      'event NFTDeposited(uint256 indexed depositId, address indexed depositor, address nftContract, uint256 tokenId, uint256 amount, uint8 nftType)',
      'event NFTContestCreated(uint256 indexed contestId, address indexed host, uint8 nftType, address nftContract, uint256 tokenId, uint256 amount, uint256 endTime, string castId)'
    ];

    // ERC721_ABI and ERC1155_ABI are defined at the top of the file near CONFIG

    // Launch contest on ContestEscrow contract
    async function launchContestOnChain(contest, durationSeconds) {
      const statusDiv = document.getElementById('launchStatus');
      try {
        console.log('ðŸš€ launchContestOnChain() called');
        if (statusDiv) statusDiv.textContent = 'Step 5: Getting wallet provider...';

        // Use the stored provider (Farcaster or MetaMask)
        const ethProvider = window.activeEthProvider || window.ethereum;
        if (!ethProvider) {
          if (statusDiv) statusDiv.textContent = 'âŒ No wallet provider found!';
          return;
        }

        if (statusDiv) statusDiv.textContent = 'Step 6: Getting account from provider...';

        // For smart wallets, get address directly from provider first
        let signerAddress;
        try {
          const accounts = await ethProvider.request({ method: 'eth_accounts' });
          signerAddress = accounts[0];
          if (statusDiv) statusDiv.textContent = 'Step 6b: Got address: ' + signerAddress.slice(0,10) + '...';
        } catch (e) {
          if (statusDiv) statusDiv.textContent = 'Step 6b ERROR: ' + e.message;
          throw e;
        }

        if (statusDiv) statusDiv.textContent = 'Step 7: Creating ethers provider/signer...';
        const provider = new ethers.providers.Web3Provider(ethProvider);
        const signer = provider.getSigner(signerAddress);
        if (statusDiv) statusDiv.textContent = 'Step 7b: Signer ready for ' + signerAddress.slice(0,10) + '...';

        if (statusDiv) statusDiv.textContent = 'Step 7c: Creating contract...';

        // Use shared rpcProvider for reading contract data (avoids smart wallet issues)
        const contestEscrowRead = new ethers.Contract(
          CONFIG.CONTRACTS.contestEscrow,
          CONTEST_ESCROW_ABI,
          rpcProvider
        );

        // Contract with signer for transactions
        const contestEscrow = new ethers.Contract(
          CONFIG.CONTRACTS.contestEscrow,
          CONTEST_ESCROW_ABI,
          signer
        );
        console.log('   ContestEscrow contract:', CONFIG.CONTRACTS.contestEscrow);

        if (statusDiv) statusDiv.textContent = 'Step 7d: Reading contract config...';

        // Get custom token fee and default token (use read-only provider)
        const customTokenFee = await contestEscrowRead.customTokenFee();
        const defaultToken = await contestEscrowRead.defaultToken();
        console.log('   Custom token fee:', ethers.utils.formatEther(customTokenFee), 'ETH');
        console.log('   Default token:', defaultToken);

        // Determine if we need to pay custom token fee
        const tokenRequirement = state.tokenEnabled ? state.tokenAddress : defaultToken;
        const isCustomToken = tokenRequirement.toLowerCase() !== defaultToken.toLowerCase();
        console.log('   Token requirement:', tokenRequirement);
        console.log('   Is custom token:', isCustomToken);

        // Sanitize volume requirement - ensure valid number
        let volumeRequirement = ethers.BigNumber.from(0);
        if (state.tokenomicsEnabled && state.tokenEnabled && state.minTradeVolume) {
          try {
            // For NEYNARTODES, lock at $20
            if (state.tokenAddress.toLowerCase() === CONFIG.CONTRACTS.neynartodes.toLowerCase()) {
              volumeRequirement = ethers.utils.parseEther('20');
            } else {
              // Clean the input - remove any invalid chars and limit decimals
              const cleanVolume = parseFloat(state.minTradeVolume).toFixed(18).replace(/\.?0+$/, '');
              if (cleanVolume && !isNaN(parseFloat(cleanVolume))) {
                volumeRequirement = ethers.utils.parseEther(cleanVolume);
              }
            }
          } catch (e) {
            console.error('Invalid volume format:', e);
            volumeRequirement = ethers.BigNumber.from(0);
          }
        }
        console.log('   Volume requirement:', ethers.utils.formatEther(volumeRequirement));
        console.log('   Tokenomics enabled:', state.tokenomicsEnabled);

        // Cast ID - validated cast hash from user input (REQUIRED)
        // Encode social requirements into castId: "castHash|R1L0P1" format
        // R = recast required (1 if minRecasts > 0), L = like required, P = reply required
        const reqRecast = parseInt(state.minRecasts) > 0 ? '1' : '0';
        const reqLike = parseInt(state.minLikes) > 0 ? '1' : '0';
        const reqReply = parseInt(state.minReplies) > 0 ? '1' : '0';

        // VALIDATION: At least one social requirement must be enabled
        if (reqRecast === '0' && reqLike === '0' && reqReply === '0') {
          console.error('âŒ No social requirements enabled');
          showToast('At least one social requirement (Recast, Like, or Reply) must be enabled!', 'error');
          return;
        }

        const requirementsCode = `R${reqRecast}L${reqLike}P${reqReply}`;
        // For NFT contests, also encode the image URL in castId for caching
        // Format: castHash|R1L0P1|imageUrl (image URL is optional, only for NFT)
        let castId = `${state.castHash}|${requirementsCode}`;
        if (state.prizeType === 'nft' && state.prizeNftImage) {
          // Encode image URL (truncate if too long to fit in string storage)
          const imageUrl = state.prizeNftImage.slice(0, 200); // Limit to 200 chars
          castId = `${state.castHash}|${requirementsCode}|${imageUrl}`;
          console.log('   NFT image URL cached in castId');
        }
        console.log('   Cast ID to send (with requirements):', castId);
        console.log('   Requirements encoded: Recast=' + reqRecast + ', Like=' + reqLike + ', Reply=' + reqReply);
        if (!state.castHash || !state.castHash.startsWith('0x')) {
          console.error('âŒ Invalid cast hash - empty or doesnt start with 0x');
          showToast('Invalid cast hash. Please start over and enter a valid cast URL/hash.', 'error');
          return;
        }

        let tx;

        if (state.prizeType === 'token') {
          // Check if prize is ETH (address(0) or WETH)
          const isETHPrize = state.prizeTokenAddress.toLowerCase() === '0x0000000000000000000000000000000000000000' ||
                            state.prizeTokenAddress.toLowerCase() === '0x4200000000000000000000000000000000000006'; // WETH on Base

          console.log('   Prize type: token');
          console.log('   Is ETH prize:', isETHPrize);
          console.log('   Prize token ticker:', state.prizeTokenTicker);

          if (isETHPrize || state.prizeTokenTicker === 'ETH') {
            // ETH prize - call createContestETH
            // Sanitize prize amount
            const cleanPrize = parseFloat(state.prizeTokenAmount).toFixed(18).replace(/\.?0+$/, '');
            if (!cleanPrize || isNaN(parseFloat(cleanPrize))) {
              showToast('Invalid prize amount. Please enter a valid number.', 'error');
              return;
            }
            const prizeAmount = ethers.utils.parseEther(cleanPrize);
            const totalValue = isCustomToken ? prizeAmount.add(customTokenFee) : prizeAmount;

            console.log('ðŸ“ Calling createContestETH with:');
            console.log('   _duration:', durationSeconds);
            console.log('   _castId:', castId);
            console.log('   _tokenRequirement:', tokenRequirement);
            console.log('   _volumeRequirement:', volumeRequirement.toString());
            console.log('   value (ETH):', ethers.utils.formatEther(totalValue));

            if (statusDiv) statusDiv.textContent = 'Step 8: Building transaction...';

            // Encode the function call
            const iface = new ethers.utils.Interface(CONTEST_ESCROW_ABI);
            const txData = iface.encodeFunctionData('createContestETH', [
              durationSeconds,
              castId,
              tokenRequirement,
              volumeRequirement
            ]);

            if (statusDiv) statusDiv.textContent = 'Step 8b: Sending transaction...';
            console.log('â³ Waiting for wallet confirmation...');

            // Try eth_sendTransaction first (smart wallets), fall back to ethers signer (EOA)
            try {
              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [{
                  from: signerAddress,
                  to: CONFIG.CONTRACTS.contestEscrow,
                  value: '0x' + totalValue.toBigInt().toString(16),
                  data: txData
                }]
              });
              tx = { hash: txHash };
              if (statusDiv) statusDiv.textContent = 'Step 9: TX sent! Hash: ' + txHash.slice(0,15) + '...';
              console.log('âœ… Wallet confirmed (smart wallet)! TX:', txHash);
            } catch (txError) {
              // If eth_sendTransaction fails, try ethers.js signer (EOA wallets)
              if (txError.message?.includes('unsupported') || txError.message?.includes('not supported')) {
                console.log('Smart wallet method failed, trying EOA signer...');
                if (statusDiv) statusDiv.textContent = 'Step 8c: Trying EOA signer...';
                try {
                  tx = await contestEscrow.createContestETH(
                    durationSeconds,
                    castId,
                    tokenRequirement,
                    volumeRequirement,
                    { value: totalValue }
                  );
                  if (statusDiv) statusDiv.textContent = 'Step 9: TX sent! Hash: ' + tx.hash.slice(0,15) + '...';
                  console.log('âœ… Wallet confirmed (EOA)! TX:', tx.hash);
                } catch (eoaError) {
                  if (statusDiv) statusDiv.textContent = 'âŒ TX Error: ' + (eoaError.message || eoaError).slice(0, 50);
                  console.error('EOA TX Error:', eoaError);
                  throw eoaError;
                }
              } else {
                if (statusDiv) statusDiv.textContent = 'âŒ TX Error: ' + (txError.message || txError).slice(0, 50);
                console.error('TX Error:', txError);
                throw txError;
              }
            }
          } else {
            // ERC20 prize - need to approve then call createContestERC20
            if (statusDiv) statusDiv.textContent = 'Step 8: Preparing ERC20 prize...';

            // Get decimals using read-only provider
            const prizeTokenRead = new ethers.Contract(state.prizeTokenAddress, ERC20_ABI, rpcProvider);
            let decimals;
            try {
              decimals = await prizeTokenRead.decimals();
            } catch {
              decimals = 18; // Default to 18 decimals
            }

            // Sanitize prize amount - limit to token's decimal places
            const cleanPrize = parseFloat(state.prizeTokenAmount).toFixed(decimals).replace(/\.?0+$/, '');
            if (!cleanPrize || isNaN(parseFloat(cleanPrize))) {
              if (statusDiv) statusDiv.textContent = 'âŒ Invalid prize amount';
              return;
            }
            const prizeAmount = ethers.utils.parseUnits(cleanPrize, decimals);

            // Check allowance using read-only provider
            if (statusDiv) statusDiv.textContent = 'Step 8b: Checking allowance...';
            const allowance = await prizeTokenRead.allowance(signerAddress, CONFIG.CONTRACTS.contestEscrow);

            if (allowance.lt(prizeAmount)) {
              if (statusDiv) statusDiv.textContent = 'Step 8c: Approval needed - check wallet!';

              // Encode approve function call
              const approveIface = new ethers.utils.Interface(ERC20_ABI);
              const approveData = approveIface.encodeFunctionData('approve', [
                CONFIG.CONTRACTS.contestEscrow,
                prizeAmount
              ]);

              // Try eth_sendTransaction first (smart wallets), fall back to ethers signer (EOA)
              try {
                await ethProvider.request({
                  method: 'eth_sendTransaction',
                  params: [{
                    from: signerAddress,
                    to: state.prizeTokenAddress,
                    data: approveData
                  }]
                });
              } catch (approveError) {
                // If eth_sendTransaction fails, try ethers.js signer (EOA wallets)
                if (approveError.message?.includes('unsupported') || approveError.message?.includes('not supported')) {
                  console.log('Smart wallet approve failed, trying EOA signer...');
                  const prizeToken = new ethers.Contract(state.prizeTokenAddress, ERC20_ABI, signer);
                  const approveTx = await prizeToken.approve(CONFIG.CONTRACTS.contestEscrow, prizeAmount);
                  await approveTx.wait();
                } else {
                  if (statusDiv) statusDiv.textContent = 'âŒ Approve Error: ' + (approveError.message || approveError).slice(0, 50);
                  throw approveError;
                }
              }

              if (statusDiv) statusDiv.textContent = 'Step 8d: Waiting for approval confirmation...';

              // Wait for approval tx to be mined
              let approved = false;
              for (let i = 0; i < 60; i++) {
                await new Promise(r => setTimeout(r, 2000));
                const newAllowance = await prizeTokenRead.allowance(signerAddress, CONFIG.CONTRACTS.contestEscrow);
                if (newAllowance.gte(prizeAmount)) {
                  approved = true;
                  break;
                }
              }
              if (!approved) {
                if (statusDiv) statusDiv.textContent = 'âŒ Approval not confirmed after 2 minutes';
                return;
              }
              if (statusDiv) statusDiv.textContent = 'Step 8e: Approval confirmed!';
            }

            const ethValue = isCustomToken ? customTokenFee : ethers.BigNumber.from(0);

            console.log('ðŸ“ Calling createContestERC20 with:');
            console.log('   _prizeToken:', state.prizeTokenAddress);
            console.log('   _prizeAmount:', prizeAmount.toString());
            console.log('   _duration:', durationSeconds);
            console.log('   _castId:', castId);
            console.log('   _tokenRequirement:', tokenRequirement);
            console.log('   _volumeRequirement:', volumeRequirement.toString());
            console.log('   value (ETH for fee):', ethers.utils.formatEther(ethValue));

            if (statusDiv) statusDiv.textContent = 'Step 9: Sending ERC20 contest tx... Check wallet!';

            // Encode createContestERC20 function call
            const createIface = new ethers.utils.Interface(CONTEST_ESCROW_ABI);
            const createData = createIface.encodeFunctionData('createContestERC20', [
              state.prizeTokenAddress,
              prizeAmount,
              durationSeconds,
              castId,
              tokenRequirement,
              volumeRequirement
            ]);

            // Try eth_sendTransaction first (smart wallets), fall back to ethers signer (EOA)
            try {
              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [{
                  from: signerAddress,
                  to: CONFIG.CONTRACTS.contestEscrow,
                  value: ethValue.gt(0) ? '0x' + ethValue.toBigInt().toString(16) : '0x0',
                  data: createData
                }]
              });
              tx = { hash: txHash };
              if (statusDiv) statusDiv.textContent = 'Step 10: TX sent! Hash: ' + txHash.slice(0,15) + '...';
              console.log('âœ… Wallet confirmed! TX:', txHash);
            } catch (txError) {
              // If eth_sendTransaction fails with "unsupported", try ethers.js signer (EOA wallets)
              if (txError.message?.includes('unsupported') || txError.message?.includes('not supported')) {
                console.log('Smart wallet createContestERC20 failed, trying EOA signer...');
                if (statusDiv) statusDiv.textContent = 'Step 9b: Trying EOA signer...';
                const contestEscrowSigner = new ethers.Contract(CONFIG.CONTRACTS.contestEscrow, CONTEST_ESCROW_ABI, signer);
                tx = await contestEscrowSigner.createContestERC20(
                  state.prizeTokenAddress,
                  prizeAmount,
                  durationSeconds,
                  castId,
                  tokenRequirement,
                  volumeRequirement,
                  { value: ethValue }
                );
                if (statusDiv) statusDiv.textContent = 'Step 10: TX sent! Hash: ' + tx.hash.slice(0,15) + '...';
                console.log('âœ… EOA wallet confirmed! TX:', tx.hash);
              } else {
                if (statusDiv) statusDiv.textContent = 'âŒ TX Error: ' + (txError.message || txError).slice(0, 50);
                console.error('TX Error:', txError);
                throw txError;
              }
            }
          }
        } else {
          // NFT prize - use NFTContestEscrow contract
          // Approval should already be done via the separate "Approve NFT" button
          if (statusDiv) statusDiv.textContent = 'Step 8: Preparing NFT prize...';

          if (!state.prizeNftAddress || !state.prizeNftTokenId || !state.prizeNftType) {
            showToast('Please load NFT metadata first by clicking "Load NFT"', 'error');
            return;
          }

          // Verify approval status (should already be approved from separate step)
          if (state.nftApprovalStatus !== 'approved') {
            showToast('Please approve your NFT first using the "Approve NFT" button', 'error');
            return;
          }

          // Use NFT Contest Escrow contract
          const nftEscrowRead = new ethers.Contract(
            CONFIG.CONTRACTS.nftContestEscrow,
            NFT_CONTEST_ESCROW_ABI,
            rpcProvider
          );

          // Get contest fee
          const contestFee = await nftEscrowRead.contestFee();
          console.log('NFT Contest Fee:', ethers.utils.formatEther(contestFee), 'ETH');

          const tokenId = parseInt(state.prizeNftTokenId) || 0;

          if (state.prizeNftType === 'ERC721') {
            // ERC721 NFT - V3 uses two-step flow for restricted NFTs
            if (statusDiv) statusDiv.textContent = 'Step 8b: Verifying NFT ownership...';

            const nft721Read = new ethers.Contract(state.prizeNftAddress, ERC721_ABI, rpcProvider);
            const owner = await nft721Read.ownerOf(tokenId);
            if (owner.toLowerCase() !== signerAddress.toLowerCase()) {
              showToast('You do not own this NFT!', 'error');
              return;
            }

            console.log('NFT Contest params:', {
              nftContract: state.prizeNftAddress,
              tokenId: tokenId,
              duration: durationSeconds,
              castId: castId,
              volumeReq: volumeRequirement.toString(),
              fee: ethers.utils.formatEther(contestFee),
              signerAddress: signerAddress
            });

            // V3 Two-Step Flow: Transfer NFT directly, then register contest
            // This works with NFTs that have transfer restrictions
            showToast('NFT Contest requires 2 transactions: Transfer + Register', 'info');
            if (statusDiv) statusDiv.textContent = 'TX 1 of 2: Transfer NFT to escrow... Check wallet!';

            // Step 1: User transfers NFT directly to escrow
            const nftIface = new ethers.utils.Interface(ERC721_ABI);
            const transferData = nftIface.encodeFunctionData('safeTransferFrom(address,address,uint256)', [
              signerAddress,
              CONFIG.CONTRACTS.nftContestEscrow,
              tokenId
            ]);

            console.log('Step 1: Transferring NFT directly to escrow...');
            console.log('From:', signerAddress);
            console.log('To:', CONFIG.CONTRACTS.nftContestEscrow);
            console.log('TokenId:', tokenId);

            const transferTxParams = {
              from: signerAddress,
              to: state.prizeNftAddress,
              data: transferData,
              gas: '0x493E0' // 300,000 gas for transfer (proxy NFTs + escrow onReceived can use ~200k)
            };

            let transferTxHash;
            try {
              transferTxHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [transferTxParams]
              });
              console.log('NFT Transfer TX sent:', transferTxHash);
              if (statusDiv) statusDiv.textContent = 'TX 1 of 2: Transfer sent! Confirming...';
            } catch (transferErr) {
              console.error('NFT transfer failed:', transferErr);
              showToast('NFT transfer failed: ' + (transferErr.message || transferErr), 'error');
              if (statusDiv) statusDiv.textContent = 'FAILED: ' + (transferErr.message || 'Transfer rejected');
              return;
            }

            // Wait for transfer to be mined
            if (statusDiv) statusDiv.textContent = 'TX 1 of 2: Waiting for blockchain confirmation...';
            let transferConfirmed = false;
            for (let i = 0; i < 60; i++) {
              try {
                const receipt = await rpcProvider.getTransactionReceipt(transferTxHash);
                if (receipt && receipt.blockNumber) {
                  if (receipt.status === 0) {
                    showToast('NFT transfer failed on-chain', 'error');
                    if (statusDiv) statusDiv.textContent = 'FAILED: NFT transfer reverted';
                    return;
                  }
                  console.log('NFT Transfer confirmed in block:', receipt.blockNumber);
                  transferConfirmed = true;
                  break;
                }
              } catch (e) { }
              await new Promise(r => setTimeout(r, 2000));
            }

            if (!transferConfirmed) {
              showToast('NFT transfer not confirmed in time. Check your wallet.', 'warning');
              if (statusDiv) statusDiv.textContent = 'WARNING: Transfer not confirmed yet';
              return;
            }

            // Step 2: Get the deposit ID from the escrow contract
            showToast('NFT transferred! Now registering contest...', 'success');
            if (statusDiv) statusDiv.textContent = 'TX 1 complete! Preparing TX 2...';
            await new Promise(r => setTimeout(r, 2000)); // Wait for state to update

            const escrowRead = new ethers.Contract(CONFIG.CONTRACTS.nftContestEscrow, NFT_CONTEST_ESCROW_ABI, rpcProvider);
            const depositId = await escrowRead.nftToDepositId(state.prizeNftAddress, tokenId);
            console.log('Deposit ID:', depositId.toString());

            if (depositId.eq(0)) {
              showToast('Deposit not found. NFT may not have been received properly.', 'error');
              if (statusDiv) statusDiv.textContent = 'FAILED: Deposit not found';
              return;
            }

            // Step 3: Register the contest
            if (statusDiv) statusDiv.textContent = 'TX 2 of 2: Register contest... Check wallet!';

            const registerIface = new ethers.utils.Interface(NFT_CONTEST_ESCROW_ABI);
            const registerData = registerIface.encodeFunctionData('registerContest', [
              depositId,
              durationSeconds,
              castId,
              tokenRequirement,
              volumeRequirement
            ]);

            const registerTxParams = {
              from: signerAddress,
              to: CONFIG.CONTRACTS.nftContestEscrow,
              data: registerData,
              gas: '0x7A120' // 500,000 gas
            };
            if (contestFee.gt(0)) {
              registerTxParams.value = contestFee.toHexString();
            }

            try {
              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [registerTxParams]
              });
              tx = { hash: txHash };
              if (statusDiv) statusDiv.textContent = 'TX 2 of 2: Registration sent! Confirming...';
            } catch (regError) {
              console.error('Contest registration failed:', regError);
              // If registration fails, user can withdraw their NFT
              showToast('Contest registration failed. Your NFT is safe - you can withdraw it.', 'error');
              if (statusDiv) statusDiv.textContent = 'FAILED: ' + (regError.message || 'Registration rejected');
              return;
            }

          } else if (state.prizeNftType === 'ERC1155') {
            // ERC1155 NFT
            if (statusDiv) statusDiv.textContent = 'Step 8b: Checking NFT balance...';

            const nft1155Read = new ethers.Contract(state.prizeNftAddress, ERC1155_ABI, rpcProvider);
            const amount = parseInt(state.prizeNftAmount) || 1;
            const balance = await nft1155Read.balanceOf(signerAddress, tokenId);
            if (balance.lt(amount)) {
              showToast(`You don't have enough of this NFT (need ${amount}, have ${balance})`, 'error');
              return;
            }

            // Verify approval is still valid (double check - should be done in separate step)
            if (statusDiv) statusDiv.textContent = 'Step 8c: Verifying approval...';
            const isApproved = await nft1155Read.isApprovedForAll(signerAddress, CONFIG.CONTRACTS.nftContestEscrow);
            if (!isApproved) {
              showToast('NFT approval expired. Please approve again.', 'error');
              state.nftApprovalStatus = 'none';
              render();
              return;
            }

            if (statusDiv) statusDiv.textContent = 'Step 9: Creating NFT contest... Check wallet!';

            // Encode createContestERC1155
            const createIface = new ethers.utils.Interface(NFT_CONTEST_ESCROW_ABI);
            const createData = createIface.encodeFunctionData('createContestERC1155', [
              state.prizeNftAddress,
              tokenId,
              amount,
              durationSeconds,
              castId,
              tokenRequirement,
              volumeRequirement
            ]);

            // Build transaction params - only include value if fee > 0
            const txParams1155 = {
              from: signerAddress,
              to: CONFIG.CONTRACTS.nftContestEscrow,
              data: createData,
              gas: '0x4C4B40' // 5,000,000 gas limit for NFT transfer + contest creation
            };
            if (contestFee.gt(0)) {
              txParams1155.value = contestFee.toHexString();
            }

            try {
              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [txParams1155]
              });
              tx = { hash: txHash };
              if (statusDiv) statusDiv.textContent = 'Step 10: TX sent! Hash: ' + txHash.slice(0,15) + '...';
            } catch (txError) {
              if (txError.message?.includes('unsupported') || txError.message?.includes('not supported')) {
                const nftEscrow = new ethers.Contract(CONFIG.CONTRACTS.nftContestEscrow, NFT_CONTEST_ESCROW_ABI, signer);
                const txOptions1155 = { gasLimit: 5000000 };
                if (contestFee.gt(0)) txOptions1155.value = contestFee;
                tx = await nftEscrow.createContestERC1155(
                  state.prizeNftAddress,
                  tokenId,
                  amount,
                  durationSeconds,
                  castId,
                  tokenRequirement,
                  volumeRequirement,
                  txOptions1155
                );
                if (statusDiv) statusDiv.textContent = 'Step 10: TX sent! Hash: ' + tx.hash.slice(0,15) + '...';
              } else {
                throw txError;
              }
            }

          } else {
            showToast('Unknown NFT type. Please reload the NFT.', 'error');
            return;
          }
        }

        console.log('ðŸ“¤ Transaction submitted:', tx.hash);

        // Show persistent notification while waiting
        const txUrl = `https://basescan.org/tx/${tx.hash}`;
        state.pendingTx = tx.hash;
        if (statusDiv) statusDiv.textContent = 'Waiting for confirmation...';

        // Wait for transaction receipt using read provider (since tx.wait() doesn't work with raw hashes)
        let receipt = null;
        for (let i = 0; i < 60; i++) {
          await new Promise(r => setTimeout(r, 2000));
          receipt = await rpcProvider.getTransactionReceipt(tx.hash);
          if (receipt) break;
        }

        if (!receipt) {
          if (statusDiv) statusDiv.textContent = 'â³ TX submitted but not confirmed yet. Check Basescan.';
          console.log('â³ TX not confirmed after 2 min, but was submitted');
        } else {
          console.log('âœ… Transaction confirmed:', receipt.transactionHash);
          console.log('ðŸ“œ Receipt logs:', receipt.logs);
        }

        // Parse contest ID from event
        let contestId = 'Unknown';
        const isNftContest = state.prizeType === 'nft';

        if (receipt?.logs) {
          // Parse from raw logs using appropriate contract interface
          const parseIface = new ethers.utils.Interface(isNftContest ? NFT_CONTEST_ESCROW_ABI : CONTEST_ESCROW_ABI);
          const eventName = isNftContest ? 'NFTContestCreated' : 'ContestCreated';

          for (const log of receipt.logs) {
            try {
              const parsed = parseIface.parseLog(log);
              if (parsed.name === eventName) {
                contestId = parsed.args.contestId.toString();
                console.log(`âœ… Found contestId via interface.parseLog (${eventName}):`, contestId);
                break;
              }
            } catch (e) {
              // Log doesn't match our event, skip
            }
          }

          // Method 2: Direct topic parsing as last resort
          if (contestId === 'Unknown' && receipt.logs.length > 0) {
            // Try both event signatures
            const contestCreatedTopic = ethers.utils.id('ContestCreated(uint256,address,address,uint256,uint256,string)');
            const nftContestCreatedTopic = ethers.utils.id('NFTContestCreated(uint256,address,uint8,address,uint256,uint256,uint256,string)');

            const eventLog = receipt.logs.find(log =>
              log.topics[0] === contestCreatedTopic || log.topics[0] === nftContestCreatedTopic
            );
            if (eventLog && eventLog.topics[1]) {
              contestId = ethers.BigNumber.from(eventLog.topics[1]).toString();
              console.log('âœ… Found contestId from raw topic:', contestId);
            } else {
              console.log('âš ï¸ Could not find ContestCreated or NFTContestCreated event');
              console.log('   Available logs:', receipt.logs.map(l => l.topics[0]));
            }
          }
        }

        // Clear pending tx
        state.pendingTx = null;

        // Store successful contest info
        const successInfo = {
          contestId,
          castHash: castId,
          txHash: receipt.transactionHash,
          timestamp: new Date().toISOString()
        };

        // Save to localStorage for persistence
        const launchedContests = JSON.parse(localStorage.getItem('neynartodes_launched_contests') || '[]');
        launchedContests.push(successInfo);
        localStorage.setItem('neynartodes_launched_contests', JSON.stringify(launchedContests));

        console.log('ðŸŽ‰ Contest created:', successInfo);

        // Track contest creation
        if (window.analytics?.track) {
          window.analytics.track('Contest Created', {
            contestId,
            prizeType: state.prizeType,
            token: state.tokenAddress,
            tokenTicker: state.tokenTicker,
            duration: state.durationHours,
            txHash: receipt?.transactionHash
          });
        }

        // Store custom message for winner announcement (if provided)
        const apiBaseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        if (state.customMessage && contestId !== 'Unknown') {
          try {
            await fetch(`${apiBaseUrl}/api/store-message`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contestId: contestId,
                message: state.customMessage
              })
            });
            console.log('âœ… Custom message stored for winner announcement');
          } catch (e) {
            console.log('âš ï¸ Could not store custom message:', e.message);
          }
        }

        // Store token price at contest creation (for fair volume calculations)
        if (contestId !== 'Unknown' && tokenRequirement !== ethers.constants.AddressZero) {
          try {
            await fetch(`${apiBaseUrl}/api/store-contest-price`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contestId: contestId,
                tokenAddress: tokenRequirement
              })
            });
            console.log('âœ… Token price captured at contest creation');
          } catch (e) {
            console.log('âš ï¸ Could not store token price:', e.message);
          }
        }

        // Add contest to state ONLY after successful on-chain tx
        contest.onChainId = contestId;
        contest.contestId = contestId !== 'Unknown' ? parseInt(contestId) : null;
        state.upcomingContests.push(contest);
        state.upcomingContests.sort((a, b) => a.startTime - b.startTime);

        // Update last launch date
        state.lastLaunchDate = new Date();

        // Show success screen (don't use alert - Warpcast blocks it)
        // Save all contest details BEFORE form reset for Cast It
        state.launchSuccess = {
          contestId,
          castHash: castId,
          txHash: tx.hash,
          txUrl,
          // Contest details for Cast It
          prizeAmount: state.prizeTokenAmount,
          prizeTicker: state.prizeTokenTicker || 'ETH',
          durationHours: state.durationHours || '24',
          durationMinutes: state.durationMinutes || '0',
          requireRecast: parseInt(state.minRecasts) > 0,
          requireLike: parseInt(state.minLikes) > 0,
          requireReply: parseInt(state.minReplies) > 0,
          volumeReq: state.minTradeVolume ? parseFloat(state.minTradeVolume) : 0,
          tokenTicker: state.tokenTicker || 'NEYNARTODES',
          // NFT-specific fields
          isNft: state.prizeType === 'nft',
          nftImage: state.prizeType === 'nft' ? state.prizeNftImage : '',
          nftName: state.prizeType === 'nft' ? `${state.prizeNftName || 'NFT'} #${state.prizeNftId}` : ''
        };

        // Reset form only after successful launch
        state.prizeTokenAddress = '';
        state.prizeTokenAmount = '';
        state.prizeTokenTicker = '';
        state.prizeTokenImage = '';
        state.prizeTokenSearch = '';
        state.tokenAddress = '';
        state.tokenTicker = '';
        state.tokenImage = '';
        state.tokenSearch = '';
        state.castHash = '';
        state.customMessage = '';
        state.minLikes = '0';
        state.minRecasts = '0';
        state.minReplies = '0';
        state.minTradeVolume = '';

        render();
      } catch (error) {
        console.error('Contest launch error:', error);

        if (error.code === 4001) {
          showToast('Transaction rejected by user', 'error');
        } else if (error.message?.includes('Prize required')) {
          showToast('Prize amount required! Please enter an amount greater than 0.', 'error');
        } else if (error.message?.includes('Include custom token fee')) {
          showToast('Custom token fee required! Using a custom token costs 0.01 ETH.', 'error');
        } else if (error.message?.includes('Invalid duration')) {
          showToast('Invalid duration! Contest duration must be greater than 0.', 'error');
        } else {
          showToast('Contest launch failed: ' + (error.reason || error.message || 'Unknown error'), 'error');
        }
      }
    }

    // Feed the Neynartodes function - DEPRECATED (Clanker fees now go direct to Treasury)
    window.feedTheNeynartodes = async () => {
      showToast('This feature has been retired! Clanker fees now flow directly to Treasury.', 'info');
    };

    // Make functions globally accessible for inline onclick handlers
    window.voteForHost = voteForHost;

    // Custom token prompt functions
    window.showCustomPrizeToken = () => {
      state.showPrizeTokenSuggestions = false;
      updatePrizeTokenDropdown();

      let address = prompt('Enter the token contract address:\n\n(e.g., 0x532f27101965dd16442E59d40670FaF5eBB142E4)');
      if (!address) return;

      // Trim whitespace and normalize
      address = address.trim();

      if (!address.startsWith('0x') || address.length !== 42) {
        showToast(`Invalid address format. Must start with 0x and be 42 characters.`, 'error');
        return;
      }

      const ticker = prompt('Enter the token symbol/ticker:\n\n(e.g., BRETT, USDC, FIRKIT)');
      if (!ticker) return;

      const name = prompt('Enter the token name (optional):', ticker);

      // Add custom token to database
      const customToken = {
        name: name || ticker,
        ticker: ticker.toUpperCase(),
        address: address.toLowerCase(),
        mcap: 1000000,
        supply: 1000000000,
        image: `https://via.placeholder.com/40/9333ea/ffffff?text=${ticker[0]}`
      };

      // Save to localStorage with 1-year expiration
      saveCustomToken(customToken);

      tokenDatabase.push(customToken);

      // Auto-select the custom token
      state.prizeTokenAddress = customToken.address;
      state.prizeTokenTicker = customToken.ticker;
      state.prizeTokenImage = customToken.image;
      state.prizeTokenSearch = customToken.name;
      render();
    };

    // Show custom token modal (for mini app compatibility - no prompt() dialogs)
    window.showCustomTokenModal = () => {
      try {
        state.showTokenSuggestions = false;
        state.showCustomTokenModal = true;
        state.customTokenInput = '';
        state.customTokenTickerInput = '';
        updateTokenDropdown();
        renderCustomTokenModal();
      } catch (err) {
        console.error('showCustomTokenModal error:', err);
        showToast('Error opening custom token modal: ' + err.message, 'error');
      }
    };

    window.closeCustomTokenModal = () => {
      state.showCustomTokenModal = false;
      const modal = document.getElementById('customTokenModal');
      if (modal) modal.remove();
    };

    window.submitCustomToken = () => {
      const addressInput = document.getElementById('customTokenAddressInput');
      const tickerInput = document.getElementById('customTokenTickerInput');

      let address = (addressInput?.value || '').trim();
      const ticker = (tickerInput?.value || '').trim();

      if (!address) {
        showToast('Please enter a token address', 'error');
        return;
      }

      if (!address.startsWith('0x') || address.length !== 42) {
        showToast('Invalid address format. Must start with 0x and be 42 characters.', 'error');
        return;
      }

      if (!ticker) {
        showToast('Please enter a token ticker/symbol', 'error');
        return;
      }

      // Add custom token to database
      const customToken = {
        name: ticker.toUpperCase(),
        ticker: ticker.toUpperCase(),
        address: address.toLowerCase(),
        mcap: 1000000,
        supply: 1000000000,
        image: `https://via.placeholder.com/40/8b5cf6/ffffff?text=${ticker[0].toUpperCase()}`
      };

      // Save to localStorage with 1-year expiration
      saveCustomToken(customToken);
      tokenDatabase.push(customToken);

      // Auto-select the custom token
      state.tokenAddress = customToken.address;
      state.tokenTicker = customToken.ticker;
      state.tokenImage = customToken.image;
      state.tokenMcap = customToken.mcap;
      state.tokenSearch = customToken.name;

      // Close modal and render
      state.showCustomTokenModal = false;
      const modal = document.getElementById('customTokenModal');
      if (modal) modal.remove();
      render();

      showToast(`Custom token ${customToken.ticker} added!`, 'success');
    };

    function renderCustomTokenModal() {
      // Remove existing modal if any
      const existingModal = document.getElementById('customTokenModal');
      if (existingModal) existingModal.remove();

      if (!state.showCustomTokenModal) return;

      const modal = document.createElement('div');
      modal.id = 'customTokenModal';
      modal.className = 'fixed inset-0 z-50 flex items-center justify-center p-4';
      modal.innerHTML = `
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" onclick="closeCustomTokenModal()"></div>
        <div class="relative bg-[var(--bg-secondary)] rounded-2xl p-6 max-w-sm w-full shadow-2xl border border-[var(--border-light)]">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-bold text-[var(--text-primary)]">Add Custom Token</h3>
            <button onclick="closeCustomTokenModal()" class="text-[var(--text-muted)] hover:text-[var(--text-primary)] text-xl">&times;</button>
          </div>

          <div class="space-y-4">
            <div>
              <label class="block text-sm text-[var(--text-secondary)] mb-2">Token Contract Address</label>
              <input type="text" id="customTokenAddressInput" placeholder="0x..." class="input-modern font-mono text-sm" />
              <p class="text-xs text-[var(--text-muted)] mt-1">The token's contract address on Base</p>
            </div>

            <div>
              <label class="block text-sm text-[var(--text-secondary)] mb-2">Token Symbol</label>
              <input type="text" id="customTokenTickerInput" placeholder="e.g., BRETT" class="input-modern uppercase" maxlength="10" />
              <p class="text-xs text-[var(--text-muted)] mt-1">The token's ticker symbol</p>
            </div>
          </div>

          <div class="flex gap-3 mt-6">
            <button onclick="closeCustomTokenModal()" class="flex-1 px-4 py-3 border border-[var(--border-light)] rounded-xl text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)] transition-colors">
              Cancel
            </button>
            <button onclick="submitCustomToken()" class="flex-1 px-4 py-3 bg-[var(--accent)] text-white rounded-xl hover:bg-[var(--accent-dark)] transition-colors font-medium">
              Add Token
            </button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);

      // Focus the address input
      setTimeout(() => {
        document.getElementById('customTokenAddressInput')?.focus();
      }, 100);
    }

    window.showCustomToken = () => {
      // Redirect to modal-based approach
      showCustomTokenModal();
    };

    window.showCustomTokenLegacy = () => {
      state.showTokenSuggestions = false;
      updateTokenDropdown();

      let address = prompt('Enter the token contract address:\n\n(e.g., 0x532f27101965dd16442E59d40670FaF5eBB142E4)');
      if (!address) return;

      // Trim whitespace and normalize
      address = address.trim();

      if (!address.startsWith('0x') || address.length !== 42) {
        showToast(`Invalid address format. Must start with 0x and be 42 characters.`, 'error');
        return;
      }

      const ticker = prompt('Enter the token symbol/ticker:\n\n(e.g., BRETT, USDC, FIRKIT)');
      if (!ticker) return;

      const name = prompt('Enter the token name (optional):', ticker);

      // Add custom token to database
      const customToken = {
        name: name || ticker,
        ticker: ticker.toUpperCase(),
        address: address.toLowerCase(),
        mcap: 1000000,
        supply: 1000000000,
        image: `https://via.placeholder.com/40/22c55e/ffffff?text=${ticker[0]}`
      };

      // Save to localStorage with 1-year expiration
      saveCustomToken(customToken);

      tokenDatabase.push(customToken);

      // Auto-select the custom token
      state.tokenAddress = customToken.address;
      state.tokenTicker = customToken.ticker;
      state.tokenImage = customToken.image;
      state.tokenMcap = customToken.mcap;
      state.tokenSearch = customToken.name;
      render();

      // Show caps info
      const basePercent = customToken.mcap < 10000 ? 0.01 : customToken.mcap < 20000 ? 0.005 : customToken.mcap < 1000000 ? 0.0025 : customToken.mcap < 10000000 ? 0.001 : 0.0005;
      const multiplier = getBadgeMultiplier(state.userBadges);
      const maxPercent = basePercent * multiplier;
      const maxTokens = Math.floor(customToken.supply * maxPercent);

      showToast(`Custom token added! Market Cap: $${customToken.mcap.toLocaleString()}, Max: ${maxTokens.toLocaleString()} ${customToken.ticker}`, 'success');
    };

    window.selectPrizeToken = (idx) => {
      const results = searchTokens(state.prizeTokenSearch);
      if (results[idx]) {
        const token = results[idx];
        state.prizeTokenAddress = token.address;
        state.prizeTokenTicker = token.ticker;
        state.prizeTokenImage = token.image;
        state.prizeTokenSearch = token.name;
        state.showPrizeTokenSuggestions = false;
        render();
      }
    };

    window.selectToken = (idx) => {
      const results = searchTokens(state.tokenSearch);
      if (results[idx]) {
        const token = results[idx];
        state.tokenAddress = token.address;
        state.tokenTicker = token.ticker;
        state.tokenImage = token.image;
        state.tokenMcap = token.mcap;
        state.tokenSearch = token.name;
        state.showTokenSuggestions = false;

        // Track token selection
        if (window.analytics?.track) {
          window.analytics.track('Token Selected', {
            token: token.address,
            ticker: token.ticker,
            mcap: token.mcap
          });
        }

        render();

        // Show info about caps
        const basePercent = token.mcap < 10000 ? 0.01 : token.mcap < 20000 ? 0.005 : token.mcap < 1000000 ? 0.0025 : token.mcap < 10000000 ? 0.001 : 0.0005;
        const multiplier = getBadgeMultiplier(state.userBadges);
        const maxPercent = basePercent * multiplier;
        const maxTokens = Math.floor(token.supply * maxPercent);

        showToast(`Token selected! Market Cap: $${token.mcap.toLocaleString()}, Max: ${maxTokens.toLocaleString()} ${token.ticker}`, 'success');
      }
    };

    // ===== INIT =====
    // Load token list from Base on startup
    fetchBaseTokens().catch(err => console.warn('Token list fetch failed:', err));

    // Attach document-level event handlers ONCE (not on every render)
    initDropdownCloseHandler();

    // Initial render
    render();

    // Re-render when Farcaster SDK loads (it's async)
    window.addEventListener('farcaster-ready', () => {
      console.log('Farcaster SDK ready event received, re-rendering...');
      render();
    });
  </script>
</body>
</html>
