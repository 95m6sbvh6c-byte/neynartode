<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Danng Neynartodes!! - Season 0</title>

  <!-- Farcaster Mini App Embed -->
  <meta name="fc:frame" content='{"version":"1","imageUrl":"https://frame-opal-eight.vercel.app/Neynartodes_1200x638_splash.png","button":{"title":"Launch NEYNARtodes","action":{"type":"launch_frame","name":"NEYNARtodes","url":"https://frame-opal-eight.vercel.app/app","splashImageUrl":"https://frame-opal-eight.vercel.app/Neynartodes_1200x638_splash.png","splashBackgroundColor":"#667eea"}}}' />

  <!-- Open Graph -->
  <meta property="og:title" content="NEYNARtodes - Season 0 Beta" />
  <meta property="og:description" content="Create contests on Farcaster!" />
  <meta property="og:image" content="https://frame-opal-eight.vercel.app/Neynartodes_1200x638_splash.png" />
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Vercel Analytics -->
  <script type="module">
    import { inject, track } from 'https://esm.sh/@vercel/analytics';
    inject();
    window.analytics = { track };
  </script>

  <!-- Farcaster Mini App SDK - loads and signals when ready -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    window.FarcasterSDK = sdk;
    await sdk.actions.ready();
    // Signal that SDK is ready - main script will listen for this
    window.FarcasterSDKReady = true;
    window.dispatchEvent(new Event('farcaster-ready'));
    console.log('Farcaster Mini App SDK ready');
  </script>
  <style>
    @keyframes bubble {
      0%, 100% { transform: translateY(0) scale(1); opacity: 0.5; }
      50% { transform: translateY(-20px) scale(1.1); opacity: 0.8; }
    }
    .bubble { animation: bubble 3s ease-in-out infinite; }
    body { font-family: system-ui, -apple-system, sans-serif; }

    /* Toast notifications (replacement for alert) */
    #toast-container {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 90vw;
      pointer-events: none;
    }
    .toast {
      background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
      color: white;
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-line;
      animation: toastIn 0.3s ease-out;
      pointer-events: auto;
      max-width: 350px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .toast.success { border-left: 4px solid #10b981; }
    .toast.error { border-left: 4px solid #ef4444; }
    .toast.info { border-left: 4px solid #3b82f6; }
    .toast.warning { border-left: 4px solid #f59e0b; }
    @keyframes toastIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes toastOut {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-20px); }
    }
  </style>
</head>
<body>
  <div id="toast-container"></div>

  <!-- Cast Share Modal -->
  <div id="cast-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4">
    <!-- Backdrop -->
    <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" onclick="closeCastModal()"></div>

    <!-- Modal Content -->
    <div class="relative bg-white rounded-2xl shadow-2xl w-full max-w-md p-6 border-4 border-purple-300">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-xl font-black text-purple-800">üì£ Share Contest</h3>
        <button onclick="closeCastModal()" class="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
      </div>

      <p class="text-sm text-gray-600 mb-3">Customize your message before casting:</p>

      <textarea
        id="cast-modal-text"
        rows="8"
        class="w-full p-3 border-2 border-purple-200 rounded-xl focus:border-purple-400 focus:outline-none resize-none text-sm"
        placeholder="Enter your cast message..."
      ></textarea>

      <p class="text-xs text-gray-500 mt-2 mb-4">
        üí° The NEYNARtodes app link will be automatically added
      </p>

      <div class="flex gap-3">
        <button
          onclick="closeCastModal()"
          class="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold py-3 px-4 rounded-xl transition-all"
        >
          Cancel
        </button>
        <button
          onclick="submitCastModal()"
          class="flex-1 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white font-bold py-3 px-4 rounded-xl transition-all transform hover:scale-105 shadow-lg"
        >
          üöÄ Cast Now
        </button>
      </div>
    </div>
  </div>

  <div id="app"></div>

  <script>
    // Toast notification system (replaces alert() which is blocked in Farcaster iframe)
    function showToast(message, type = 'info', duration = 5000) {
      const container = document.getElementById('toast-container');
      if (!container) return;

      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      container.appendChild(toast);

      // Auto-remove after duration
      setTimeout(() => {
        toast.style.animation = 'toastOut 0.3s ease-out forwards';
        setTimeout(() => toast.remove(), 300);
      }, duration);

      // Click to dismiss
      toast.onclick = () => {
        toast.style.animation = 'toastOut 0.3s ease-out forwards';
        setTimeout(() => toast.remove(), 300);
      };
    }

    // Cast sharing modal functions
    function openCastModal(contestId, prize, hoursLeft, minutesLeft, volumeReq, tokenSymbol, hostUsername, requireRecast, requireLike, requireReply) {
      const hostTag = hostUsername ? `@${hostUsername}` : 'a host';

      // Build requirements string
      const reqs = [];
      if (requireRecast) reqs.push('üîÑ Recast');
      if (requireLike) reqs.push('‚ù§Ô∏è Like');
      if (requireReply) reqs.push('üí¨ Reply');
      if (volumeReq > 0) reqs.push(`üí∞ $${volumeReq} ${tokenSymbol} volume`);

      const reqsLine = reqs.length > 0 ? `üìã To Enter: ${reqs.join(' + ')}` : 'üéÅ Open to everyone!';
      const reactLine = reqs.length > 0 ? 'üëá React to the cast below to enter!' : '';

      const defaultText = `ü¶é Contest #${contestId} by ${hostTag} is LIVE on NEYNARtodes! üî•

üéÅ Prize: ${prize}
‚è±Ô∏è Time Left: ${hoursLeft}h ${minutesLeft}m
${reqsLine}
${reactLine}

Launch Your own! üëá`;

      // Store in window for access
      window.castModalState = {
        contestId,
        text: defaultText
      };

      // Show the modal
      const modal = document.getElementById('cast-modal');
      const textarea = document.getElementById('cast-modal-text');
      if (modal && textarea) {
        textarea.value = defaultText;
        modal.classList.remove('hidden');
        textarea.focus();
      }
    }

    function closeCastModal() {
      const modal = document.getElementById('cast-modal');
      if (modal) {
        modal.classList.add('hidden');
      }
    }

    function submitCastModal() {
      const textarea = document.getElementById('cast-modal-text');
      if (!textarea) return;

      const text = textarea.value.trim();
      if (!text) {
        showToast('Please enter a message', 'warning');
        return;
      }

      // Add the frame embed link
      const fullText = text + '\n\nhttps://frame-opal-eight.vercel.app';

      // Build Warpcast compose URL
      let warpcastUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(fullText)}`;

      // Quote the original cast if we have a castId
      const castId = window.castModalState?.castId;
      if (castId) {
        // Add the original cast as an embed (quote cast)
        const castUrl = `https://warpcast.com/~/conversations/${castId}`;
        warpcastUrl += `&embeds[]=${encodeURIComponent(castUrl)}`;
      }

      window.open(warpcastUrl, '_blank');

      // Close modal
      closeCastModal();
    }
  </script>

  <script>
    // ===== CONFIGURATION =====
    const CONFIG = {
      NEYNAR_API_KEY: 'AA2E0FC2-FDC0-466D-9EBA-4BCA968C9B1D',
      BASE_RPC_URL: 'https://base-mainnet.g.alchemy.com/v2/QooWtq9nKQlkeqKF_-rvC',
      CONTRACTS: {
        prizeNFT: '0x54E3972839A79fB4D1b0F70418141723d02E56e1', // V2 deployed 2025-12-01
        votingManager: '0x267Bd7ae64DA1060153b47d6873a8830dA4236f8', // V2 deployed 2025-11-29
        contestEscrow: '0x0A8EAf7de19268ceF2d2bA4F9000c60680cAde7A',
        treasury: '0xd4d84f3477eb482783aAB48F00e357C801c48928', // V2 deployed 2025-12-01
        neynartodes: '0x8de1622fe07f56cda2e2273e615a513f1d828b07'
      },
      SEASON_0_MIN_TOKENS: ethers.utils.parseEther('20000') // 20K tokens
    };

    // ===== SHARED RPC PROVIDER (reduces duplicate connections) =====
    const rpcProvider = new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC_URL);

    // Dev wallets with unlimited privileges (no contest launch limit, no voting limit)
    const DEV_WALLETS = [
      '0x78EeAA6F014667A339fCF8b4eCd74743366603fb', // MetaMask
      '0xAB4F21321A7A16eb57171994C7D7D1C808506E5d'  // Farcaster
    ];
    const DEV_WALLET = DEV_WALLETS[0]; // Keep for backwards compat
    const isDevWallet = (addr) => DEV_WALLETS.some(w => w.toLowerCase() === addr?.toLowerCase());

    // ===== STATE =====
    const state = {
      // Auth
      isLoggedIn: false,
      isCheckingWhitelist: false,
      walletStatus: null, // Status message during wallet connection
      isWhitelisted: false,
      hasTokens: false,
      userAddress: '',
      userFid: null,
      userProfile: null, // Full Farcaster profile {fid, username, displayName, pfpUrl}
      userBalance: '0',
      currentView: 'create', // 'create', 'leaderboard', 'history', 'suggestions'
      pendingTx: null, // Pending transaction hash

      // Voting
      votesRemaining: 10,
      votesUsedToday: 0,

      // Season & Prize Pool
      currentSeason: 0,
      seasonEndTime: null, // Unix timestamp when season ends
      prizePoolETH: 0,
      hostPoolETH: 0,  // On-chain host prize pool
      voterPoolETH: 0, // On-chain voter prize pool
      pendingClankerFees: '0', // Pending Clanker fees to collect
      totalTokensBurned: '0', // All-time Neynartodes burned from voting
      totalPrizesGiven: 0, // All-time prizes distributed (ETH)

      // Contest settings
      startMode: 'now', // 'now' or 'scheduled'
      startDate: '',
      endDate: '',
      durationHours: '1',
      durationMinutes: '0',
      lastLaunchDate: null, // Track last contest launch per wallet
      upcomingContests: [], // Array of scheduled contests
      prizeType: 'token', // Always token now (NFT removed)
      prizeTokenAddress: '',
      prizeTokenAmount: '',
      prizeTokenTicker: '',
      prizeTokenImage: '',
      prizeTokenSearch: '',
      showPrizeTokenSuggestions: false,

      // Social Dynamics
      socialEnabled: true,
      castHash: '',
      minLikes: '0',
      minRecasts: '0',
      minReplies: '0',

      // Tokenomics (can be toggled off for 0.001 ETH)
      tokenomicsEnabled: true, // Main toggle for tokenomics section
      tokenEnabled: true,
      tokenAddress: '0x8de1622fe07f56cda2e2273e615a513f1d828b07', // Default to NEYNARTODES
      tokenTicker: 'NEYNARTODES',
      tokenImage: '',
      tokenMcap: 0,
      tokenSearch: '',
      showTokenSuggestions: false,
      minTradeVolume: '10', // Default to $10 for NEYNARTODES

      // Winner announcement
      customMessage: '',

      // Cast sharing modal
      showCastModal: false,
      castModalText: '',
      castModalContestId: null,

      // Contest state
      contestLaunched: false,
      showCastPreview: false,
      announcementCast: '',
      contestActive: false,
      winner: null,
      totalParticipants: 0,
      contestStats: null,
      winnerCast: '',
      autoPosted: false,
      prizeReleased: false,

      // Leaderboard
      leaderboardData: [],

      // User badges
      userBadges: [],

      // Contest History
      historyData: [],
      historyLoading: false,
      historyError: null,
      historyTotal: 0,

      // Suggestions (anonymous)
      suggestions: [],
      suggestionText: '',
      suggestionsLoading: false
    };

    // ===== TOKEN DATABASE =====
    // Popular Base network tokens (fallback/cache)
    let tokenDatabase = [
      {
        name: 'Ethereum',
        ticker: 'ETH',
        address: '0x4200000000000000000000000000000000000006', // WETH on Base
        mcap: 450000000000,
        supply: 120000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png'
      },
      {
        name: 'USD Coin',
        ticker: 'USDC',
        address: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base
        mcap: 35000000000,
        supply: 35000000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png'
      },
      {
        name: 'Neynartodes',
        ticker: 'NEYNARTODES',
        address: '0x8de1622fe07f56cda2e2273e615a513f1d828b07',
        mcap: 85000,
        supply: 1000000000,
        image: 'https://i.imgur.com/placeholder-neynartodes.png'
      },
      {
        name: 'Dai Stablecoin',
        ticker: 'DAI',
        address: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb', // DAI on Base
        mcap: 5000000000,
        supply: 5000000000,
        image: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png'
      },
      {
        name: 'Aerodrome Finance',
        ticker: 'AERO',
        address: '0x940181a94A35A4569E4529A3CDfB74e38FD98631',
        mcap: 500000000,
        supply: 500000000,
        image: 'https://assets.coingecko.com/coins/images/31745/small/token.png'
      },
      {
        name: 'Brett',
        ticker: 'BRETT',
        address: '0x532f27101965dd16442E59d40670FaF5eBB142E4',
        mcap: 100000000,
        supply: 10000000000,
        image: 'https://assets.coingecko.com/coins/images/35711/small/brett.jpg'
      }
    ];

    // Cache for API token results
    let tokenCache = new Map();
    let lastFetchTime = 0;

    // ===== LOCALSTORAGE HELPERS FOR CUSTOM TOKENS =====
    const CUSTOM_TOKENS_KEY = 'neynartodes_custom_tokens';
    const ONE_YEAR_MS = 365 * 24 * 60 * 60 * 1000; // 1 year in milliseconds

    // Load custom tokens from localStorage (filters out expired ones)
    function loadCustomTokens() {
      try {
        const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
        if (!stored) return [];

        const data = JSON.parse(stored);
        const now = Date.now();

        // Filter out expired tokens (older than 1 year)
        const validTokens = data.filter(item => {
          return item.expiresAt && item.expiresAt > now;
        });

        // Save back the filtered list if we removed any expired tokens
        if (validTokens.length !== data.length) {
          localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(validTokens));
        }

        return validTokens.map(item => item.token);
      } catch (error) {
        console.warn('Failed to load custom tokens from localStorage:', error);
        return [];
      }
    }

    // Save a custom token to localStorage with 1-year expiration
    function saveCustomToken(token) {
      try {
        const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
        let data = stored ? JSON.parse(stored) : [];
        const now = Date.now();

        // Check if token already exists (by address)
        const existingIndex = data.findIndex(item =>
          item.token.address.toLowerCase() === token.address.toLowerCase()
        );

        if (existingIndex >= 0) {
          // Update expiration date for existing token
          data[existingIndex].expiresAt = now + ONE_YEAR_MS;
        } else {
          // Add new token with expiration
          data.push({
            token: token,
            expiresAt: now + ONE_YEAR_MS,
            addedAt: now
          });
        }

        localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(data));
        console.log(`Saved custom token ${token.ticker} to localStorage (expires in 1 year)`);
      } catch (error) {
        console.warn('Failed to save custom token to localStorage:', error);
      }
    }

    // ===== UTILITY FUNCTIONS =====
    // Fetch tokens from multiple sources for comprehensive Base token coverage
    async function fetchBaseTokens() {
      try {
        // First, load custom tokens from localStorage
        const customTokens = loadCustomTokens();
        if (customTokens.length > 0) {
          const existing = new Set(tokenDatabase.map(t => t.address.toLowerCase()));
          customTokens.forEach(token => {
            if (!existing.has(token.address.toLowerCase())) {
              tokenDatabase.push(token);
              existing.add(token.address.toLowerCase());
            }
          });
          console.log(`Loaded ${customTokens.length} custom tokens from localStorage`);
        }

        // Try multiple token list sources
        const tokenListUrls = [
          'https://tokens.coingecko.com/base/all.json', // CoinGecko Base tokens
          'https://raw.githubusercontent.com/Uniswap/default-token-list/main/build/uniswap-default.tokenlist.json', // Uniswap default
          'https://tokens.1inch.io/v1.1/8453' // 1inch Base tokens (chainId 8453)
        ];

        for (const url of tokenListUrls) {
          try {
            const response = await fetch(url);
            if (!response.ok) continue;

            const data = await response.json();
            let tokens = [];

            // Handle different token list formats
            if (data.tokens && Array.isArray(data.tokens)) {
              // Uniswap/CoinGecko format
              tokens = data.tokens.filter(t => t.chainId === 8453 || !t.chainId); // Base chainId is 8453
            } else if (typeof data === 'object' && !Array.isArray(data)) {
              // 1inch format (object with addresses as keys)
              tokens = Object.values(data);
            }

            if (tokens.length > 0) {
              const newTokens = tokens.map(token => ({
                name: token.name,
                ticker: token.symbol,
                address: (token.address || '').toLowerCase(),
                mcap: token.marketCap || 1000000,
                supply: token.totalSupply || 1000000000,
                image: token.logoURI || token.logo || `https://via.placeholder.com/40/9333ea/ffffff?text=${token.symbol?.[0] || '?'}`
              })).filter(t => t.address && t.address.startsWith('0x'));

              // Merge unique tokens
              const existing = new Set(tokenDatabase.map(t => t.address.toLowerCase()));
              newTokens.forEach(token => {
                if (!existing.has(token.address)) {
                  tokenDatabase.push(token);
                  existing.add(token.address);
                }
              });

              console.log(`Loaded ${newTokens.length} Base tokens from token list`);
              break; // Success, stop trying other sources
            }
          } catch (err) {
            console.warn('Failed to fetch from', url, err);
            continue; // Try next source
          }
        }
      } catch (error) {
        console.warn('Failed to fetch Base token lists, using fallback:', error);
      }
    }

    // Search tokens (synchronous search through cached database)
    function searchTokens(query) {
      if (!query || query.length < 2) return [];
      const q = query.toLowerCase();
      return tokenDatabase.filter(token =>
        token.name.toLowerCase().includes(q) ||
        token.ticker.toLowerCase().includes(q) ||
        token.address.toLowerCase().includes(q)
      ).slice(0, 20); // Limit to 20 results for performance
    }

    function getBadgeMultiplier(badges) {
      if (!badges || badges.length === 0) return 1;
      let multiplier = 1;
      badges.forEach(badge => {
        if (badge === 'gold') multiplier += 2;
        else if (badge === 'silver') multiplier += 1;
        else if (badge === 'bronze') multiplier += 0.5;
        else if (badge === 'purple') multiplier += 0.25;
      });
      return multiplier;
    }

    function getBadgeEmoji(badge) {
      if (badge === 'gold') return 'ü•á';
      if (badge === 'silver') return 'ü•à';
      if (badge === 'bronze') return 'ü•â';
      if (badge === 'purple') return 'üü£';
      if (badge === 'season0_beta') return 'ü¶é';
      return '';
    }

    function getBadgeTitle(badge) {
      if (badge === 'gold') return 'Gold Badge';
      if (badge === 'silver') return 'Silver Badge';
      if (badge === 'bronze') return 'Bronze Badge';
      if (badge === 'purple') return 'Purple Badge';
      if (badge === 'season0_beta') return 'Season 0 Beta Tester - Forever OG';
      return badge;
    }

    // ===== SEASON 0 BETA BADGE TRACKING =====
    function getSeasonTesterBadges() {
      try {
        const stored = localStorage.getItem('season0_beta_participants');
        return stored ? JSON.parse(stored) : {};
      } catch (e) {
        return {};
      }
    }

    function awardSeasonBetaBadge(fid, username) {
      if (state.currentSeason === 0 || state.currentSeason === 1) {
        try {
          const badges = getSeasonTesterBadges();
          if (!badges[fid]) {
            badges[fid] = {
              username: username,
              awardedAt: Date.now(),
              season: state.currentSeason
            };
            localStorage.setItem('season0_beta_participants', JSON.stringify(badges));
            console.log(`ü¶é Season 0 Beta badge awarded to @${username} (FID: ${fid})`);
          }
        } catch (e) {
          console.error('Failed to award Season 0 Beta badge:', e);
        }
      }
    }

    function hasSeasonBetaBadge(fid) {
      const badges = getSeasonTesterBadges();
      return !!badges[fid];
    }

    // ===== CAST VALIDATION =====
    // Extract cast hash and username from URL or raw hash
    // Returns { hash, username } - username is only set for farcaster.xyz URLs with short hashes
    function extractCastInfo(input) {
      if (!input) return { hash: null, username: null };
      input = input.trim();

      // Extract from Farcaster.xyz URL: https://farcaster.xyz/username/0x1234abcd
      // These use SHORT hashes that need to be resolved
      const farcasterMatch = input.match(/farcaster\.xyz\/([^/]+)\/(0x[a-fA-F0-9]+)/i);
      if (farcasterMatch) {
        const username = farcasterMatch[1].toLowerCase();
        const hash = farcasterMatch[2].toLowerCase();
        // farcaster.xyz uses short hashes (10 chars like 0x539e9184)
        // Full hashes are 66 chars (0x + 64 hex)
        const isShortHash = hash.length < 42;
        return { hash, username: isShortHash ? username : null };
      }

      // If it's already a hash (starts with 0x)
      if (input.startsWith('0x')) {
        return { hash: input.toLowerCase(), username: null };
      }

      // Extract from Warpcast URL: https://warpcast.com/username/0x1234abcd
      const warpcastMatch = input.match(/warpcast\.com\/[^/]+\/(0x[a-fA-F0-9]+)/i);
      if (warpcastMatch) {
        return { hash: warpcastMatch[1].toLowerCase(), username: null };
      }

      // Try to find any 0x hash in the string
      const hashMatch = input.match(/(0x[a-fA-F0-9]{8,})/i);
      if (hashMatch) {
        return { hash: hashMatch[1].toLowerCase(), username: null };
      }

      return { hash: null, username: null };
    }

    // Legacy function for backwards compatibility
    function extractCastHash(input) {
      return extractCastInfo(input).hash;
    }

    // Resolve a short hash to full hash by looking up user's recent casts
    async function resolveShortHash(shortHash, username) {
      try {
        console.log(`Resolving short hash ${shortHash} for user ${username}`);

        // First get the user's FID from username
        const userResponse = await fetch(`https://api.neynar.com/v2/farcaster/user/by_username?username=${username}`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        if (!userResponse.ok) {
          console.log('Could not find user:', username);
          return null;
        }

        const userData = await userResponse.json();
        const fid = userData.user?.fid;
        if (!fid) return null;

        // Fetch user's recent casts
        const castsResponse = await fetch(`https://api.neynar.com/v2/farcaster/feed/user/casts?fid=${fid}&limit=25`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        if (!castsResponse.ok) return null;

        const castsData = await castsResponse.json();

        // Find the cast that starts with the short hash
        const matchingCast = castsData.casts?.find(cast =>
          cast.hash.toLowerCase().startsWith(shortHash.toLowerCase())
        );

        if (matchingCast) {
          console.log(`Resolved ${shortHash} to full hash: ${matchingCast.hash}`);
          return matchingCast.hash;
        }

        console.log(`No cast found starting with ${shortHash}`);
        return null;
      } catch (e) {
        console.error('Error resolving short hash:', e);
        return null;
      }
    }

    // Validate cast exists via Neynar API
    // Can accept either a hash directly or a raw URL input (for short hash resolution)
    async function validateCast(castHashOrInput, rawInput = null) {
      try {
        let castHash = castHashOrInput;

        // If rawInput is provided, try to resolve short hashes from farcaster.xyz URLs
        if (rawInput) {
          const castInfo = extractCastInfo(rawInput);
          if (castInfo.username && castInfo.hash && castInfo.hash.length < 42) {
            // This is a short hash from farcaster.xyz - resolve it
            console.log(`Detected short hash ${castInfo.hash} from farcaster.xyz, resolving...`);
            const fullHash = await resolveShortHash(castInfo.hash, castInfo.username);
            if (fullHash) {
              castHash = fullHash;
            } else {
              return {
                valid: false,
                error: `Could not resolve short hash ${castInfo.hash} for user @${castInfo.username}.\n\nThe cast may be older than recent history. Try using the full Warpcast URL instead.`
              };
            }
          }
        }

        console.log('Validating cast hash:', castHash);

        const response = await fetch(`https://api.neynar.com/v2/farcaster/cast?identifier=${castHash}&type=hash`, {
          headers: {
            'accept': 'application/json',
            'api_key': CONFIG.NEYNAR_API_KEY
          }
        });

        const data = await response.json();
        console.log('Neynar API response:', data);

        if (!response.ok || data.code === 'NotFound') {
          return {
            valid: false,
            error: `Cast not found for hash: ${castHash}\n\nMake sure you copied the full URL from Warpcast.\nNew casts may take a few seconds to be indexed.`
          };
        }

        if (data.cast) {
          const authorFid = data.cast.author?.fid;
          const authorUsername = data.cast.author?.username || 'unknown';

          // Check if the connected wallet owns this cast
          // Get author's verified addresses from Neynar
          let isOwnCast = false;
          let authorAddresses = [];

          if (authorFid && state.userAddress) {
            try {
              const verifyResponse = await fetch(`https://api.neynar.com/v2/farcaster/user/bulk?fids=${authorFid}`, {
                headers: {
                  'accept': 'application/json',
                  'api_key': CONFIG.NEYNAR_API_KEY
                }
              });
              const verifyData = await verifyResponse.json();

              if (verifyData.users && verifyData.users[0]) {
                // Get all verified addresses for this user
                authorAddresses = verifyData.users[0].verified_addresses?.eth_addresses || [];
                // Also check custody address
                if (verifyData.users[0].custody_address) {
                  authorAddresses.push(verifyData.users[0].custody_address);
                }

                // Check if connected wallet matches any of author's addresses
                const connectedLower = state.userAddress.toLowerCase();
                isOwnCast = authorAddresses.some(addr => addr.toLowerCase() === connectedLower);

                console.log('Author addresses:', authorAddresses);
                console.log('Connected wallet:', state.userAddress);
                console.log('Is own cast:', isOwnCast);
              }
            } catch (e) {
              console.error('Error checking cast ownership:', e);
              // If we can't verify, allow it but warn
            }
          }

          return {
            valid: true,
            cast: data.cast,
            hash: castHash, // Return the resolved full hash
            author: authorUsername,
            authorFid: authorFid,
            authorAddresses: authorAddresses,
            isOwnCast: isOwnCast,
            text: data.cast.text?.substring(0, 100) || ''
          };
        }

        return { valid: false, error: 'Invalid cast data returned from API' };
      } catch (e) {
        console.error('Cast validation error:', e);
        return { valid: false, error: `Network error validating cast: ${e.message}\n\nPlease try again.` };
      }
    }

    // ===== BLOCKCHAIN FUNCTIONS =====
    async function connectWallet() {
      try {
        // Helper for timeout (no longer used for wallet connection - we wait indefinitely)
        const withTimeout = (promise, ms, errorMsg) => Promise.race([
          promise,
          new Promise((_, reject) => setTimeout(() => reject(new Error(errorMsg || 'Request timed out')), ms))
        ]);

        // Try to get Farcaster Mini App SDK provider first (for Warpcast)
        let ethProvider = null;
        let providerSource = 'none';

        // Check for Farcaster SDK first
        if (window.FarcasterSDK) {
          try {
            const sdk = window.FarcasterSDK;
            console.log('Farcaster SDK found');
            console.log('SDK wallet object:', sdk.wallet);
            console.log('SDK wallet methods:', sdk.wallet ? Object.keys(sdk.wallet) : 'no wallet');

            // Get the provider - try different methods
            if (typeof sdk.wallet?.getEthereumProvider === 'function') {
              console.log('Calling getEthereumProvider()...');
              ethProvider = sdk.wallet.getEthereumProvider();
              // Check if it returns a promise
              if (ethProvider && typeof ethProvider.then === 'function') {
                ethProvider = await ethProvider;
              }
              providerSource = 'farcaster';
              console.log('Got Farcaster provider:', ethProvider);
              console.log('Provider methods:', ethProvider ? Object.keys(ethProvider) : 'null');
            } else {
              console.log('getEthereumProvider not found on sdk.wallet');
            }
          } catch (sdkError) {
            console.log('Farcaster SDK wallet error:', sdkError.message);
          }
        }

        // Fallback to window.ethereum (MetaMask, etc)
        if (!ethProvider && window.ethereum) {
          ethProvider = window.ethereum;
          providerSource = 'metamask';
          console.log('Using window.ethereum (MetaMask)');
        }

        if (!ethProvider) {
          showToast('No wallet found! Farcaster SDK: ' + (window.FarcasterSDK ? 'loaded' : 'not loaded'), 'error');
          return false;
        }

        console.log('Using provider from:', providerSource);

        // Show "waiting for wallet" state - NO timeout, wait for user to unlock
        state.isCheckingWhitelist = true;
        state.walletStatus = 'Unlock your wallet to continue...';
        render();

        // Connect to wallet - NO TIMEOUT, wait indefinitely for unlock
        let accounts;
        try {
          console.log('Requesting wallet accounts (waiting for unlock if needed)...');

          // Use a Promise wrapper to allow UI updates during the wait
          accounts = await new Promise((resolve, reject) => {
            // Update UI to show we're waiting
            setTimeout(() => {
              state.walletStatus = 'Waiting for wallet... Check your extension!';
              render();
            }, 2000);

            ethProvider.request({ method: 'eth_requestAccounts' })
              .then(resolve)
              .catch(reject);
          });
        } catch (e) {
          state.isCheckingWhitelist = false;
          state.walletStatus = null;
          render();
          // User rejected or other error
          if (e.code === 4001) {
            showToast('Wallet connection rejected. Please try again.', 'error');
          } else if (e.code === -32002) {
            // Already pending - wallet popup might be hidden
            showToast('Wallet request already pending! Check your wallet extension.', 'warning');
            return false;
          } else {
            showToast(e.message || 'Failed to connect wallet. Please try again.', 'error');
          }
          return false;
        }

        // Store the provider for later use
        window.activeEthProvider = ethProvider;
        state.walletStatus = 'Connected! Checking access...';
        render();

        if (!accounts || accounts.length === 0) {
          state.isCheckingWhitelist = false;
          render();
          showToast('No accounts found. Please unlock your wallet and try again.', 'error');
          return false;
        }

        const address = accounts[0];
        state.userAddress = address;

        // Check network (use the active provider)
        const chainId = await ethProvider.request({ method: 'eth_chainId' });
        if (chainId !== '0x2105') { // Base mainnet
          try {
            await ethProvider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: '0x2105' }]
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              await ethProvider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: '0x2105',
                  chainName: 'Base',
                  nativeCurrency: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
                  rpcUrls: ['https://mainnet.base.org'],
                  blockExplorerUrls: ['https://basescan.org']
                }]
              });
            } else {
              throw switchError;
            }
          }
        }

        // Uses shared rpcProvider for read operations
        console.log('Checking whitelist for:', address);

        // Check whitelist with timeout
        const prizeNFTContract = new ethers.Contract(
          CONFIG.CONTRACTS.prizeNFT,
          ['function whitelisted(address) external view returns (bool)'],
          rpcProvider
        );

        try {
          state.isWhitelisted = await withTimeout(prizeNFTContract.whitelisted(address), 10000, 'Whitelist check timed out');
        } catch (e) {
          console.error('Whitelist check failed:', e);
          // Default to true if check fails (let them try)
          state.isWhitelisted = true;
        }

        if (!state.isWhitelisted) {
          state.isCheckingWhitelist = false;
          render();
          showToast('Season 0 Access Denied! You are not on the whitelist. Stay tuned for public launch!', 'error');
          return false;
        }

        console.log('Checking token balance...');

        // Check token balance with timeout (uses shared rpcProvider)
        const neynartodeContract = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          ['function balanceOf(address) external view returns (uint256)'],
          rpcProvider
        );

        let balance;
        try {
          balance = await withTimeout(neynartodeContract.balanceOf(address), 10000);
          state.userBalance = ethers.utils.formatEther(balance);
        } catch (e) {
          console.error('Balance check failed:', e);
          // Default to enough tokens if check fails
          balance = CONFIG.SEASON_0_MIN_TOKENS;
          state.userBalance = '20000';
        }

        if (balance.lt(CONFIG.SEASON_0_MIN_TOKENS)) {
          state.isCheckingWhitelist = false;
          render();
          showToast(`Insufficient Tokens! Need 20K NEYNARTODES. Your balance: ${parseFloat(state.userBalance).toLocaleString()}`, 'error');
          return false;
        }

        state.hasTokens = true;

        // Fetch user FID from Neynar API
        try {
          const response = await fetch(`https://api.neynar.com/v2/farcaster/user/by-verification?address=${address}`, {
            headers: {
              'accept': 'application/json',
              'api_key': CONFIG.NEYNAR_API_KEY
            }
          });
          if (response.ok) {
            const data = await response.json();
            if (data && data.users && data.users.length > 0) {
              const user = data.users[0];
              state.userFid = user.fid;
              state.userProfile = {
                fid: user.fid,
                username: user.username,
                displayName: user.display_name,
                pfpUrl: user.pfp_url
              };
            }
          }
        } catch (e) {
          console.error('Neynar API error:', e);
        }

        state.isLoggedIn = true;
        state.isCheckingWhitelist = false;
        state.walletStatus = null;

        // Load leaderboard data
        await loadLeaderboard();

        // Track wallet connection
        if (window.analytics?.track) {
          window.analytics.track('Wallet Connected', {
            address,
            fid: state.userFid,
            balance: state.userBalance,
            provider: providerSource
          });
        }

        render();
        return true;
      } catch (error) {
        console.error('Wallet connection error:', error);
        state.isCheckingWhitelist = false;
        state.walletStatus = null;
        render();
        showToast('Failed to connect wallet: ' + error.message, 'error');
        return false;
      }
    }

    // Dedicated function to load burned tokens - checks all burn sources
    // Uses shared rpcProvider for efficiency
    async function loadBurnedTokens() {
      // All common burn addresses on Base/Ethereum
      const BURN_ADDRESSES = [
        '0x000000000000000000000000000000000000dEaD', // Most common burn address
        '0x0000000000000000000000000000000000000000', // Zero address
      ];

      try {
        // Token contract for checking burn address balances (uses shared provider)
        const neynartodeToken = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          ['function balanceOf(address) view returns (uint256)'],
          rpcProvider
        );

        // VotingManager contract for checking burned via burn() function (uses shared provider)
        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          ['function totalTokensBurned() view returns (uint256)'],
          rpcProvider
        );

        // Check all sources in parallel (batched RPC calls)
        const [burnAddressBalances, vmBurned] = await Promise.all([
          // Check burn addresses
          Promise.all(BURN_ADDRESSES.map(addr =>
            neynartodeToken.balanceOf(addr).catch(() => ethers.BigNumber.from(0))
          )),
          // Check VotingManager's tracked burns
          votingManager.totalTokensBurned().catch(() => ethers.BigNumber.from(0))
        ]);

        // Sum all burned tokens from burn addresses
        let totalBurned = ethers.BigNumber.from(0);
        for (const balance of burnAddressBalances) {
          totalBurned = totalBurned.add(balance);
        }

        // Add VotingManager tracked burns (these are actual burn() calls that reduce supply)
        totalBurned = totalBurned.add(vmBurned);

        state.totalTokensBurned = ethers.utils.formatEther(totalBurned);
        console.log('Total tokens burned (all sources):', state.totalTokensBurned, '| VM burned:', ethers.utils.formatEther(vmBurned));
      } catch (e) {
        console.error('Error fetching burned tokens:', e);
        state.totalTokensBurned = '0';
      }
    }

    async function loadPrizePools() {
      // FIRST: Load burned tokens - this runs independently and should always work
      await loadBurnedTokens();

      try {
        console.log('Loading prize pools from PrizeNFT:', CONFIG.CONTRACTS.prizeNFT);

        // Load current season and prize pools from PrizeNFT contract (V2 - no devPool)
        // Uses shared rpcProvider for efficiency
        const prizeNFTABI = [
          'function nextSeasonId() external view returns (uint256)',
          'function seasons(uint256) external view returns (string theme, uint256 startTime, uint256 endTime, uint256 hostPool, uint256 voterPool, bool distributed)'
        ];

        const prizeNFT = new ethers.Contract(
          CONFIG.CONTRACTS.prizeNFT,
          prizeNFTABI,
          rpcProvider
        );

        // Get current season ID (latest season)
        console.log('Calling nextSeasonId()...');
        const nextSeasonId = await prizeNFT.nextSeasonId();
        console.log('nextSeasonId result:', nextSeasonId.toString());
        state.currentSeason = nextSeasonId.toNumber() - 1;
        console.log('currentSeason:', state.currentSeason);

        if (state.currentSeason > 0) {
          // Get season data
          console.log('Calling seasons(' + state.currentSeason + ')...');
          const season = await prizeNFT.seasons(state.currentSeason);
          console.log('Season data:', {
            theme: season.theme,
            startTime: season.startTime.toString(),
            endTime: season.endTime.toString(),
            hostPool: season.hostPool.toString(),
            voterPool: season.voterPool.toString(),
            distributed: season.distributed
          });

          state.hostPoolETH = parseFloat(ethers.utils.formatEther(season.hostPool));
          state.voterPoolETH = parseFloat(ethers.utils.formatEther(season.voterPool));
          state.prizePoolETH = state.hostPoolETH + state.voterPoolETH; // Total
          state.seasonEndTime = season.endTime.toNumber(); // Store season end timestamp
          console.log('seasonEndTime set to:', state.seasonEndTime);
        }

        // Clanker fees now go direct to Treasury - no pending fees to track
        state.pendingClankerFees = '0';

        // For now, calculate prizes given from all seasons (you can add a totalPrizesDistributed to contract later)
        // For beta, we'll use the current season's total as placeholder (V2 has no devPool)
        if (state.currentSeason > 0) {
          state.totalPrizesGiven = state.hostPoolETH + state.voterPoolETH;
        }

        console.log('Prize pools loaded successfully:', {
          season: state.currentSeason,
          hostPool: state.hostPoolETH,
          voterPool: state.voterPoolETH,
          seasonEndTime: state.seasonEndTime,
          pendingFees: state.pendingClankerFees,
          tokensBurned: state.totalTokensBurned,
          prizesGiven: state.totalPrizesGiven
        });
      } catch (error) {
        console.error('Failed to load prize pools:', error);
        console.error('Error details:', error.message, error.code);
      }
    }

    async function loadLeaderboard() {
      // Load prize pools from contracts
      await loadPrizePools();

      try {
        // Fetch leaderboard data from API
        const baseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        const response = await fetch(`${baseUrl}/api/leaderboard?limit=10`);

        if (!response.ok) {
          console.error('Failed to fetch leaderboard:', response.status);
          state.leaderboardData = [];
          return;
        }

        const data = await response.json();
        const hosts = data.hosts || [];

        // Transform API data to match expected leaderboard format
        state.leaderboardData = hosts.map(host => {
          // Award Season 0 Beta badges to all participants
          awardSeasonBetaBadge(host.fid, host.username);

          // Build badges array
          const badges = [];
          if (hasSeasonBetaBadge(host.fid)) {
            badges.push('season0_beta');
          }

          // Get a pfp emoji based on username hash or use first letter
          const pfpEmoji = getPfpEmoji(host.username);

          return {
            rank: host.rank,
            fid: host.fid,
            username: host.username,
            displayName: host.displayName,
            pfp: pfpEmoji,
            pfpUrl: host.pfpUrl,
            badges,
            contests: host.contests,
            completedContests: host.completedContests,
            // Score breakdown
            likes: host.likes,
            recasts: host.recasts,
            replies: host.replies,
            volume: host.volume,
            upvotes: host.upvotes,
            downvotes: host.downvotes,
            socialScore: host.socialScore,
            tokenScore: host.tokenScore,
            contestScore: host.contestScore,
            voteScore: host.voteScore || 0,
            totalScore: host.totalScore,
            neynarScore: host.neynarScore,
          };
        });

        // Fetch on-chain vote scores and merge with leaderboard data
        await fetchOnChainVoteScores();

      } catch (error) {
        console.error('Error loading leaderboard:', error);
        state.leaderboardData = [];
      }

      // Fetch active contests from contest-history API
      try {
        const baseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        const historyResponse = await fetch(`${baseUrl}/api/contest-history?limit=20&includeUsers=true`);
        if (historyResponse.ok) {
          const historyData = await historyResponse.json();
          // Filter to only active (status 0) and pending VRF (status 1) contests
          state.upcomingContests = (historyData.contests || [])
            .filter(c => c.status === 0 || c.status === 1)
            .map(c => ({
              contestId: c.contestId,
              host: c.host,
              hostUser: c.hostUser,
              prize: `${c.prizeAmount.toLocaleString(undefined, { maximumFractionDigits: 4 })} $${c.prizeTokenSymbol}`,
              prizeToken: c.prizeTokenSymbol,
              prizeAmount: c.prizeAmount,
              startTime: new Date(c.startTime * 1000),
              endTime: new Date(c.endTime * 1000),
              volumeRequirement: c.volumeRequirement,
              tokenRequirementSymbol: c.tokenRequirementSymbol,
              status: c.status,
              statusText: c.statusText,
              participantCount: c.participantCount,
              castId: c.castId,
              // Social requirements from API
              requireRecast: c.requireRecast || false,
              requireLike: c.requireLike || false,
              requireReply: c.requireReply || false,
            }));
          console.log(`Loaded ${state.upcomingContests.length} active/pending contests`);
        }
      } catch (e) {
        console.error('Error fetching active contests:', e);
        state.upcomingContests = [];
      }

      // Re-render to show active contests
      render();
    }

    // Fetch vote scores from VotingManager contract and update leaderboard
    async function fetchOnChainVoteScores() {
      if (state.leaderboardData.length === 0) return;

      try {
        // Uses shared rpcProvider for efficiency
        const votingManagerABI = [
          'function getHostVoteStats(uint256 hostFid) external view returns (uint256 upvotes, uint256 downvotes, int256 netScore)'
        ];
        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          rpcProvider
        );

        // Fetch vote stats for each host in parallel
        const votePromises = state.leaderboardData.map(async (host) => {
          try {
            const stats = await votingManager.getHostVoteStats(host.fid);
            return {
              fid: host.fid,
              upvotes: stats.upvotes.toNumber(),
              downvotes: stats.downvotes.toNumber(),
              netScore: stats.netScore.toNumber()
            };
          } catch (e) {
            console.warn(`Failed to get vote stats for FID ${host.fid}:`, e.message);
            return { fid: host.fid, upvotes: 0, downvotes: 0, netScore: 0 };
          }
        });

        const voteStats = await Promise.all(votePromises);

        // Update leaderboard with on-chain vote scores (200 points per net vote)
        state.leaderboardData = state.leaderboardData.map(host => {
          const stats = voteStats.find(s => s.fid === host.fid);
          if (stats) {
            const onChainVoteScore = stats.netScore * 200; // 200 points per net vote
            // Replace API vote score with on-chain score
            const adjustedTotal = host.totalScore - (host.voteScore || 0) + onChainVoteScore;
            return {
              ...host,
              upvotes: stats.upvotes,
              downvotes: stats.downvotes,
              voteScore: onChainVoteScore,
              totalScore: adjustedTotal
            };
          }
          return host;
        });

        // Re-sort and re-rank after updating scores
        state.leaderboardData = state.leaderboardData
          .sort((a, b) => b.totalScore - a.totalScore)
          .map((host, idx) => ({ ...host, rank: idx + 1 }));

        console.log('Updated leaderboard with on-chain vote scores');
        render();

      } catch (error) {
        console.error('Error fetching on-chain vote scores:', error);
      }
    }

    // Get a consistent emoji for a user based on their username
    function getPfpEmoji(username) {
      const emojis = ['ü¶é', 'üê∏', 'üêä', 'ü¶ñ', 'üê¢', 'ü¶ï', 'üêç', 'üê≤', 'üåä', 'ü™∏'];
      if (!username) return 'ü¶é';
      const hash = username.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      return emojis[hash % emojis.length];
    }

    async function loadHistory() {
      state.historyLoading = true;
      state.historyError = null;
      render();

      try {
        const baseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        const response = await fetch(`${baseUrl}/api/contest-history?limit=20&includeUsers=true`);

        if (!response.ok) {
          throw new Error(`Failed to fetch history: ${response.status}`);
        }

        const data = await response.json();
        state.historyData = data.contests || [];
        state.historyTotal = data.total || 0;
        state.historyLoading = false;
        render();

        // Start auto-refresh if there are active/pending contests (and we're on history view)
        if (state.currentView === 'history') {
          startHistoryAutoRefresh();
        }
      } catch (error) {
        console.error('Error loading history:', error);
        state.historyError = error.message;
        state.historyLoading = false;
        render();
      }
    }

    // ===== ANONYMOUS SUGGESTIONS =====
    // Uses localStorage for storage - suggestions are completely anonymous (no user data stored)
    const SUGGESTIONS_KEY = 'neynartodes_suggestions';

    function loadSuggestions() {
      state.suggestionsLoading = true;
      render();

      try {
        const stored = localStorage.getItem(SUGGESTIONS_KEY);
        state.suggestions = stored ? JSON.parse(stored) : [];
        // Sort by newest first
        state.suggestions.sort((a, b) => b.timestamp - a.timestamp);
      } catch (error) {
        console.error('Error loading suggestions:', error);
        state.suggestions = [];
      }

      state.suggestionsLoading = false;
      render();
    }

    function submitAnonymousSuggestion() {
      const text = state.suggestionText.trim();

      if (text.length < 10) {
        showToast('Suggestion must be at least 10 characters', 'error');
        return;
      }

      try {
        // Load existing suggestions
        const stored = localStorage.getItem(SUGGESTIONS_KEY);
        const suggestions = stored ? JSON.parse(stored) : [];

        // Add new suggestion (completely anonymous - no user data)
        suggestions.push({
          id: Date.now().toString(36) + Math.random().toString(36).substr(2),
          text: text,
          timestamp: Date.now()
        });

        // Save back to localStorage
        localStorage.setItem(SUGGESTIONS_KEY, JSON.stringify(suggestions));

        // Clear the input and show success
        state.suggestionText = '';
        showToast('Suggestion submitted anonymously! Thank you for your feedback.', 'success');
        render();

        // Track analytics (without any identifying info)
        if (window.analytics?.track) {
          window.analytics.track('Suggestion Submitted', { anonymous: true });
        }
      } catch (error) {
        console.error('Error submitting suggestion:', error);
        showToast('Failed to submit suggestion. Please try again.', 'error');
      }
    }

    // Auto-refresh for history page when there are active or pending VRF contests
    let historyRefreshInterval = null;

    function startHistoryAutoRefresh() {
      // Clear any existing interval
      stopHistoryAutoRefresh();

      // Check if there are active (status 0) or pending VRF (status 1) contests
      const hasActiveOrPending = (state.historyData || []).some(c => c.status === 0 || c.status === 1);

      if (hasActiveOrPending) {
        console.log('Starting history auto-refresh (active/pending contests detected)');
        historyRefreshInterval = setInterval(async () => {
          // Only refresh if still on history view
          if (state.currentView === 'history') {
            console.log('Auto-refreshing history...');
            await loadHistory();

            // Check if we still need to auto-refresh
            const stillHasActiveOrPending = (state.historyData || []).some(c => c.status === 0 || c.status === 1);
            if (!stillHasActiveOrPending) {
              console.log('No more active/pending contests, stopping auto-refresh');
              stopHistoryAutoRefresh();
            }
          }
        }, 15000); // Refresh every 15 seconds
      }
    }

    function stopHistoryAutoRefresh() {
      if (historyRefreshInterval) {
        clearInterval(historyRefreshInterval);
        historyRefreshInterval = null;
        console.log('Stopped history auto-refresh');
      }
    }

    // Countdown timer interval for leaderboard
    let countdownInterval = null;

    function startCountdownTimer() {
      stopCountdownTimer();
      // Update countdown every minute (targeted update, not full render)
      countdownInterval = setInterval(() => {
        if (state.currentView === 'leaderboard') {
          updateCountdownDisplay();
        }
      }, 60000); // Update every minute
    }

    // Targeted countdown update - avoids rebuilding entire leaderboard DOM
    function updateCountdownDisplay() {
      const countdownEl = document.getElementById('countdown-text');
      if (!countdownEl) return;

      const countdown = getSeasonCountdown();
      if (!countdown) {
        countdownEl.textContent = 'Loading...';
      } else if (countdown.ended) {
        countdownEl.textContent = 'Season Ended!';
      } else {
        countdownEl.textContent = countdown.text;
      }
    }

    function stopCountdownTimer() {
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }

    // Format timestamp to readable date
    function formatDate(timestamp) {
      const date = new Date(timestamp * 1000);
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    // Get season countdown string
    function getSeasonCountdown() {
      if (!state.seasonEndTime) return null;

      const now = Math.floor(Date.now() / 1000);
      const remaining = state.seasonEndTime - now;

      if (remaining <= 0) return { text: 'Season Ended!', days: 0, hours: 0, minutes: 0, ended: true };

      const days = Math.floor(remaining / 86400);
      const hours = Math.floor((remaining % 86400) / 3600);
      const minutes = Math.floor((remaining % 3600) / 60);

      let text = '';
      if (days > 0) text += `${days}d `;
      if (hours > 0 || days > 0) text += `${hours}h `;
      text += `${minutes}m`;

      return { text: text.trim(), days, hours, minutes, ended: false };
    }

    // Format duration
    function formatDuration(hours, minutes) {
      if (hours === 0) return `${minutes}m`;
      if (minutes === 0) return `${hours}h`;
      return `${hours}h ${minutes}m`;
    }

    // Get status color class
    function getStatusColor(status) {
      switch (status) {
        case 0: return 'bg-blue-100 text-blue-700'; // Active
        case 1: return 'bg-yellow-100 text-yellow-700'; // PendingVRF
        case 2: return 'bg-green-100 text-green-700'; // Completed
        case 3: return 'bg-red-100 text-red-700'; // Cancelled
        default: return 'bg-gray-100 text-gray-700';
      }
    }

    // Get status emoji
    function getStatusEmoji(status) {
      switch (status) {
        case 0: return 'üîµ'; // Active
        case 1: return 'üé≤'; // PendingVRF
        case 2: return '‚úÖ'; // Completed
        case 3: return '‚ùå'; // Cancelled
        default: return '‚ùì';
      }
    }

    async function voteForHost(hostFid, isUpvote) {
      // Check if dev wallet (unlimited voting)
      const isDev = isDevWallet(state.userAddress);

      // Block self-voting (except dev for testing)
      if (!isDev && state.userFid && state.userFid === hostFid) {
        showToast("You can't vote for yourself! Nice try though!", 'error');
        return;
      }

      if (!isDev && state.votesRemaining <= 0) {
        showToast('You have used all 10 votes for today! Come back tomorrow.', 'warning');
        return;
      }

      try {
        // Create provider and signer using stored provider
        const ethProvider = window.activeEthProvider || window.ethereum;
        if (!ethProvider) {
          showToast('Wallet not connected! Please reconnect.', 'error');
          return;
        }
        const walletProvider = new ethers.providers.Web3Provider(ethProvider);
        const signer = walletProvider.getSigner();

        // Use shared rpcProvider for read operations (Farcaster wallet doesn't support eth_call)

        // Contract ABIs - VotingManager V2 with upvote/downvote
        const votingManagerABI = [
          'function voteForHost(uint256 hostFid, bool isUpvote) external',
          'function getRemainingVotes(address user) external view returns (uint256)',
          'function canVote(address user) external view returns (bool)',
          'function getHostVoteStats(uint256 hostFid) external view returns (uint256 upvotes, uint256 downvotes, int256 netScore)',
          'function TOKENS_PER_VOTE() external view returns (uint256)'
        ];

        const tokenABI = [
          'function approve(address spender, uint256 amount) external returns (bool)',
          'function allowance(address owner, address spender) external view returns (uint256)',
          'function balanceOf(address account) external view returns (uint256)'
        ];

        // Read-only contract instances for checking balances/allowances (uses shared rpcProvider)
        const votingManagerRead = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          rpcProvider
        );

        const neynartodeTokenRead = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          tokenABI,
          rpcProvider
        );

        // Write contract instances for transactions
        const votingManager = new ethers.Contract(
          CONFIG.CONTRACTS.votingManager,
          votingManagerABI,
          signer
        );

        const neynartodeToken = new ethers.Contract(
          CONFIG.CONTRACTS.neynartodes,
          tokenABI,
          signer
        );

        // Check if can vote (skip for dev wallet) - use read-only provider
        if (!isDev) {
          const canVoteResult = await votingManagerRead.canVote(state.userAddress);
          if (!canVoteResult) {
            showToast('Cannot vote! You may have used all votes today, have insufficient tokens, or not be whitelisted.', 'error');
            return;
          }
        }

        // Get tokens per vote (1000 NEYNARTODES)
        const tokensPerVote = ethers.utils.parseEther('1000');

        // Check balance - use read-only provider
        const balance = await neynartodeTokenRead.balanceOf(state.userAddress);
        if (balance.lt(tokensPerVote)) {
          showToast(`Insufficient balance! You need 1,000 NEYNARTODES to vote. Your balance: ${ethers.utils.formatEther(balance)}`, 'error');
          return;
        }

        // Check and set approval if needed - use read-only provider for allowance check
        const currentAllowance = await neynartodeTokenRead.allowance(state.userAddress, CONFIG.CONTRACTS.votingManager);
        if (currentAllowance.lt(tokensPerVote)) {
          showToast('Approving voting contract... Confirm in wallet.', 'info', 8000);

          // Encode approve call manually for smart wallet compatibility
          const approveInterface = new ethers.utils.Interface(tokenABI);
          const approveData = approveInterface.encodeFunctionData('approve', [
            CONFIG.CONTRACTS.votingManager,
            ethers.constants.MaxUint256
          ]);

          // Send via raw eth_sendTransaction for Farcaster smart wallet
          const approveTxHash = await ethProvider.request({
            method: 'eth_sendTransaction',
            params: [{
              from: state.userAddress,
              to: CONFIG.CONTRACTS.neynartodes,
              data: approveData,
              gas: '0x' + (500000).toString(16) // 500k gas for smart wallet approve
            }]
          });

          showToast('Approval submitted! Waiting for confirmation...', 'info', 10000);

          // Wait for approval confirmation
          let approveReceipt = null;
          for (let i = 0; i < 30; i++) {
            await new Promise(r => setTimeout(r, 2000));
            approveReceipt = await rpcProvider.getTransactionReceipt(approveTxHash);
            if (approveReceipt) break;
          }

          if (approveReceipt) {
            showToast('Approval confirmed! Now submitting vote...', 'success');
          } else {
            showToast('Approval may still be pending. Continuing with vote...', 'warning');
          }
        }

        // Cast vote on-chain
        showToast('Submitting vote... Burns 500 + 500 to treasury. Confirm in wallet!', 'info', 8000);

        // Encode the function call manually (Farcaster provider doesn't support eth_estimateGas)
        const voteInterface = new ethers.utils.Interface(votingManagerABI);
        const voteData = voteInterface.encodeFunctionData('voteForHost', [hostFid, isUpvote]);

        // Send transaction via raw eth_sendTransaction (works with Farcaster wallet)
        const txHash = await ethProvider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: state.userAddress,
            to: CONFIG.CONTRACTS.votingManager,
            data: voteData,
            gas: '0x' + (800000).toString(16) // 800k gas for smart wallet vote (transferFrom + burn + transfer)
          }]
        });

        console.log('Vote tx hash:', txHash);

        // Track vote event
        if (window.analytics?.track) {
          window.analytics.track('Vote Cast', {
            hostFid,
            isUpvote,
            voteType: isUpvote ? 'upvote' : 'downvote',
            txHash: txHash
          });
        }

        showToast('Vote submitted! Waiting for confirmation...', 'info', 15000);

        // Wait for receipt using read provider
        let receipt = null;
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          receipt = await rpcProvider.getTransactionReceipt(txHash);
          if (receipt) break;
        }

        if (!receipt) {
          showToast('Vote submitted but not yet confirmed. Check BaseScan.', 'warning');
        }

        // Update UI after successful vote (200 points per vote to align with scoring system)
        const votePoints = isUpvote ? 200 : -200;
        const oldRankings = state.leaderboardData.map(h => ({ fid: h.fid, rank: h.rank }));

        // Update leaderboard locally
        state.leaderboardData = state.leaderboardData.map(host => {
          if (host.fid === hostFid) {
            return {
              ...host,
              voteScore: host.voteScore + votePoints,
              totalScore: host.totalScore + votePoints
            };
          }
          return host;
        }).sort((a, b) => b.totalScore - a.totalScore).map((host, idx) => ({ ...host, rank: idx + 1 }));

        // Refresh burned tokens counter
        await loadBurnedTokens();

        const votedHost = state.leaderboardData.find(h => h.fid === hostFid);
        const oldRank = oldRankings.find(h => h.fid === hostFid)?.rank;
        const newRank = votedHost.rank;
        const movement = oldRank - newRank;

        let movementText = '';
        if (movement > 0) {
          movementText = `\nüìà @${votedHost.username} moved UP ${movement} position${movement > 1 ? 's' : ''}! (${oldRank} ‚Üí ${newRank})`;
        } else if (movement < 0) {
          movementText = `\nüìâ @${votedHost.username} moved DOWN ${Math.abs(movement)} position${Math.abs(movement) > 1 ? 's' : ''}! (${oldRank} ‚Üí ${newRank})`;
        } else {
          movementText = `\n‚û°Ô∏è @${votedHost.username} stayed at rank #${newRank}`;
        }

        // Only decrement vote counter for non-dev wallets
        if (!isDevWallet) {
          state.votesUsedToday++;
          state.votesRemaining--;
        }

        const ethFromVote = 0.00001;
        state.prizePoolETH += (ethFromVote * 0.5);

        showToast(`${isUpvote ? 'Upvote' : 'Downvote'} confirmed! 500 burned, 500 to treasury. ${isDevWallet ? 'Dev mode' : `${state.votesRemaining}/10 votes left`}`, 'success', 6000);

        render();
      } catch (error) {
        console.error('Voting error:', error);

        if (error.code === 4001) {
          showToast('Transaction rejected by user', 'error');
        } else if (error.message && error.message.includes('Daily vote limit')) {
          showToast('Daily vote limit reached! Come back tomorrow.', 'error');
        } else if (error.message && error.message.includes('Already voted')) {
          showToast('Already voted for this host!', 'error');
        } else if (error.message && error.message.includes('Not whitelisted')) {
          showToast('Not whitelisted for Season 0 Beta.', 'error');
        } else {
          showToast('Vote failed: ' + (error.reason || error.message || 'Unknown error'), 'error');
        }
      }
    }

    // ===== RENDER FUNCTIONS =====
    function render() {
      const app = document.getElementById('app');

      if (!state.isLoggedIn) {
        app.innerHTML = renderLoginPage();
      } else if (state.launchSuccess) {
        app.innerHTML = renderLaunchSuccess();
      } else if (state.currentView === 'leaderboard') {
        app.innerHTML = renderLeaderboard();
      } else if (state.currentView === 'history') {
        app.innerHTML = renderHistory();
      } else if (state.currentView === 'suggestions') {
        app.innerHTML = renderSuggestions();
      } else {
        app.innerHTML = renderCreateContest();
      }

      attachEventListeners();
    }

    function renderLaunchSuccess() {
      const { contestId, castHash, txHash, txUrl } = state.launchSuccess;
      return `
        <div class="min-h-screen bg-gradient-to-b from-green-400 via-emerald-500 to-green-900 flex items-center justify-center p-6 relative overflow-hidden">
          <div class="absolute inset-0 opacity-20">
            <div class="absolute bottom-0 left-1/4 w-4 h-4 bg-white rounded-full bubble" style="animation-duration: 3s"></div>
            <div class="absolute bottom-0 left-1/2 w-6 h-6 bg-white rounded-full bubble" style="animation-duration: 4s; animation-delay: 1s"></div>
            <div class="absolute bottom-0 right-1/3 w-3 h-3 bg-white rounded-full bubble" style="animation-duration: 5s; animation-delay: 2s"></div>
          </div>

          <div class="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center relative z-10 border-4 border-green-400">
            <div class="text-7xl mb-4 animate-bounce">üéâ</div>
            <h1 class="text-3xl font-black mb-4 text-green-600">
              CONTEST LAUNCHED!
            </h1>

            <div class="bg-green-50 rounded-xl p-4 mb-6 border-2 border-green-200 text-left">
              <div class="mb-3">
                <p class="text-xs text-green-600 font-bold">CONTEST ID</p>
                <p class="text-lg font-black text-green-800">#${contestId}</p>
              </div>
              <div class="mb-3">
                <p class="text-xs text-green-600 font-bold">STATUS</p>
                <p class="text-sm font-bold text-green-700">‚úÖ Prize Locked in Escrow</p>
              </div>
              <div class="mb-3">
                <p class="text-xs text-green-600 font-bold">WINNER SELECTION</p>
                <p class="text-sm font-bold text-green-700">üé≤ Chainlink VRF (when contest ends)</p>
              </div>
              <div>
                <p class="text-xs text-green-600 font-bold">TRANSACTION</p>
                <a href="${txUrl}" target="_blank" class="text-sm font-bold text-blue-600 underline break-all">
                  ${txHash.slice(0, 20)}...
                </a>
              </div>
            </div>

            <button
              onclick="state.launchSuccess = null; render();"
              class="w-full bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white px-6 py-4 rounded-2xl font-black text-lg transition-all shadow-lg transform hover:scale-105 border-2 border-green-300"
            >
              ü¶é Launch Another Contest
            </button>

            <a
              href="${txUrl}"
              target="_blank"
              class="block mt-4 text-green-600 font-bold text-sm underline"
            >
              View on BaseScan ‚Üí
            </a>
          </div>
        </div>
      `;
    }

    function renderLoginPage() {
      return `
        <div class="min-h-screen bg-gradient-to-b from-blue-400 via-purple-500 to-blue-900 flex items-center justify-center p-6 relative overflow-hidden">
          <div class="absolute inset-0 opacity-20">
            <div class="absolute bottom-0 left-1/4 w-4 h-4 bg-white rounded-full bubble" style="animation-duration: 3s"></div>
            <div class="absolute bottom-0 left-1/2 w-6 h-6 bg-white rounded-full bubble" style="animation-duration: 4s; animation-delay: 1s"></div>
            <div class="absolute bottom-0 right-1/3 w-3 h-3 bg-white rounded-full bubble" style="animation-duration: 5s; animation-delay: 2s"></div>
          </div>

          <div class="bg-white rounded-3xl shadow-2xl p-12 max-w-md w-full text-center relative z-10 border-4 border-purple-400">
            <div class="mb-6">
              <div class="text-7xl mb-4 animate-bounce">ü¶é</div>
              <h1 class="text-5xl font-black mb-3" style="background: linear-gradient(45deg, #9333ea, #ec4899, #a855f7); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 2px 2px 4px rgba(147, 51, 234, 0.3); letter-spacing: -0.02em">
                Danng<br/>Neynartodes!!
              </h1>
              <p class="text-purple-600 font-bold text-sm">üåä Season 0 Beta üåä</p>
            </div>

            <div class="mb-6 p-4 bg-gradient-to-r from-purple-100 to-pink-100 rounded-xl border-2 border-purple-300">
              <div class="text-2xl mb-2">üîí</div>
              <p class="text-sm font-black text-purple-800 mb-1">SEASON 0 BETA</p>
              <p class="text-xs text-purple-700 font-semibold">
                ‚úÖ Whitelist Required<br/>
                üíé Hold 20K+ $NEYNARTODES
              </p>
            </div>

            ${state.isCheckingWhitelist ? `
              <div class="mb-4 p-4 bg-blue-100 rounded-xl border-2 border-blue-300">
                <div class="animate-spin text-3xl mb-2">üåÄ</div>
                <p class="text-sm font-bold text-blue-800">${state.walletStatus || 'Checking whitelist & balance...'}</p>
                <p class="text-xs text-blue-600 mt-1">Unlock your wallet if prompted</p>
              </div>
            ` : ''}

            <button
              id="connectButton"
              ${state.isCheckingWhitelist ? 'disabled' : ''}
              class="w-full flex items-center justify-center gap-3 bg-gradient-to-r from-purple-500 via-pink-500 to-purple-600 hover:from-purple-600 hover:via-pink-600 hover:to-purple-700 disabled:from-gray-400 disabled:to-gray-400 text-white px-6 py-5 rounded-2xl font-black text-xl transition-all shadow-lg transform hover:scale-105 border-2 border-purple-300"
              style="text-shadow: 1px 1px 2px rgba(0,0,0,0.3)"
            >
              üî• ${state.isCheckingWhitelist ? (state.walletStatus ? 'Waiting...' : 'Checking...') : 'Connect Wallet'}
            </button>

            <p class="mt-2 text-xs text-gray-500">
              SDK: ${window.FarcasterSDK ? '‚úÖ' : '‚ùå'} | Wallet: ${window.FarcasterSDK?.wallet ? '‚úÖ' : '‚ùå'} | ETH: ${window.ethereum ? '‚úÖ' : '‚ùå'}
            </p>

            <div class="mt-8 p-4 bg-purple-50 rounded-xl border-2 border-purple-200">
              <p class="text-sm text-purple-800 mb-2 font-semibold">üåä Powered by the Colony üåä</p>
              <a
                href="https://dexscreener.com/base/0x8de1622fe07f56cda2e2273e615a513f1d828b07"
                target="_blank"
                rel="noopener noreferrer"
                class="text-purple-600 hover:text-pink-600 font-black text-lg transition-colors"
              >
                $NEYNARTODES
              </a>
              <p class="font-mono text-xs text-gray-600 mt-2 break-all">CA: 0x8de1622fe07f56cda2e2273e615a513f1d828b07</p>
            </div>

            <a
              href="https://github.com/95m6sbvh6c-byte/neynartode#readme"
              target="_blank"
              rel="noopener noreferrer"
              class="mt-4 inline-flex items-center gap-2 text-purple-600 hover:text-pink-600 font-semibold text-sm transition-colors"
            >
              <span class="w-5 h-5 rounded-full bg-purple-200 flex items-center justify-center text-xs">?</span>
              How to Use NEYNARtodes
            </a>
          </div>
        </div>
      `;
    }

    function renderHeader() {
      return `
        <div class="bg-gradient-to-r from-purple-400 via-pink-400 to-purple-500 rounded-2xl shadow-2xl p-5 mb-6 border-4 border-purple-300">
          <div class="text-center mb-4">
            <h1 class="text-3xl font-black text-white flex items-center justify-center gap-3 drop-shadow-lg" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.3)">
              <svg width="40" height="40" viewBox="0 0 100 100" class="drop-shadow-lg">
                <defs>
                  <linearGradient id="logoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#fbbf24"/>
                    <stop offset="100%" style="stop-color:#f59e0b"/>
                  </linearGradient>
                </defs>
                <circle cx="50" cy="50" r="45" fill="url(#logoGrad)" stroke="white" stroke-width="4"/>
                <text x="50" y="65" font-size="50" text-anchor="middle" fill="white">ü¶é</text>
              </svg>
              <span>NEYNARtodes</span>
              <svg width="40" height="40" viewBox="0 0 100 100" class="drop-shadow-lg">
                <circle cx="50" cy="50" r="45" fill="url(#logoGrad)" stroke="white" stroke-width="4"/>
                <text x="50" y="65" font-size="50" text-anchor="middle" fill="white">üåä</text>
              </svg>
            </h1>
            <p class="text-sm text-purple-100 font-semibold">
              Season 0 Beta ‚Ä¢ ${state.userAddress.substring(0, 6)}...${state.userAddress.substring(38)}
              ${state.userBadges.length > 0 ? `<span class="ml-2">${state.userBadges.map(b => getBadgeEmoji(b)).join('')}</span>` : ''}
            </p>
            <p class="text-xs text-white font-bold mt-1 bg-purple-600 bg-opacity-50 inline-block px-3 py-1 rounded-full">
              Provider: ${window.activeEthProvider ? '‚úÖ' : '‚ùå'} |
              ü¶é ${parseFloat(state.userBalance).toLocaleString()} $NEYNARTODES
            </p>
          </div>
          <div class="flex justify-center gap-2 flex-wrap">
            <button id="viewCreate" class="px-4 py-2 rounded-xl font-bold transition-all transform hover:scale-105 ${state.currentView === 'create' ? 'bg-white text-purple-600 shadow-lg' : 'bg-purple-300 text-purple-800 hover:bg-purple-200'}">
              ‚ú® Create
            </button>
            <button id="viewHistory" class="px-4 py-2 rounded-xl font-bold transition-all transform hover:scale-105 ${state.currentView === 'history' ? 'bg-white text-purple-600 shadow-lg' : 'bg-purple-300 text-purple-800 hover:bg-purple-200'}">
              üìú History
            </button>
            <button id="viewLeaderboard" class="px-4 py-2 rounded-xl font-bold transition-all transform hover:scale-105 ${state.currentView === 'leaderboard' ? 'bg-white text-purple-600 shadow-lg' : 'bg-purple-300 text-purple-800 hover:bg-purple-200'}">
              üèÜ Leaderboard
            </button>
            <button id="viewSuggestions" class="px-4 py-2 rounded-xl font-bold transition-all transform hover:scale-105 ${state.currentView === 'suggestions' ? 'bg-white text-purple-600 shadow-lg' : 'bg-purple-300 text-purple-800 hover:bg-purple-200'}">
              üí° Suggestions
            </button>
          </div>
        </div>
      `;
    }

    function renderLeaderboard() {
      return `
        <div class="min-h-screen bg-gradient-to-b from-blue-100 via-purple-100 to-pink-100 p-6 relative">
          <div class="fixed inset-0 pointer-events-none opacity-10 overflow-hidden">
            <div class="absolute top-10 left-10 text-6xl">ü™∏</div>
            <div class="absolute top-40 right-20 text-5xl">üêö</div>
            <div class="absolute bottom-20 left-1/4 text-7xl">üåä</div>
            <div class="absolute bottom-40 right-1/3 text-5xl">ü´ß</div>
          </div>

          <div class="max-w-7xl mx-auto relative z-10">
            ${renderHeader()}

            <div class="space-y-6">
              <!-- Season Info -->
              <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="bg-gradient-to-br from-purple-500 to-purple-700 rounded-2xl shadow-2xl p-6 text-white border-4 border-purple-400 transform hover:scale-105 transition-transform">
                  <div class="text-sm font-bold mb-2 opacity-90">‚è∞ Season Ends In ‚è∞</div>
                  ${(() => {
                    const countdown = getSeasonCountdown();
                    if (!countdown) return '<div id="countdown-text" class="text-3xl font-black mb-2">Loading...</div>';
                    if (countdown.ended) return '<div id="countdown-text" class="text-3xl font-black mb-2">Season Ended!</div>';
                    return `
                      <div id="countdown-text" class="text-3xl font-black mb-2">${countdown.text}</div>
                      <div class="text-xs opacity-90 font-semibold">Season #${state.currentSeason} Beta</div>
                    `;
                  })()}
                </div>

                <div class="bg-gradient-to-br from-green-400 to-emerald-600 rounded-2xl shadow-2xl p-6 text-white border-4 border-green-300 transform hover:scale-105 transition-transform">
                  <div class="text-sm font-bold mb-2 opacity-90">üèÜ Host Prize Pool üèÜ</div>
                  <div class="text-4xl font-black mb-2">${state.hostPoolETH.toFixed(4)} ETH</div>
                  <div class="text-xs opacity-90 font-semibold">For Contest Creators</div>
                </div>

                <div class="bg-gradient-to-br from-red-400 to-orange-600 rounded-2xl shadow-2xl p-6 text-white border-4 border-red-300 transform hover:scale-105 transition-transform">
                  <div class="text-sm font-bold mb-2 opacity-90">üî• ALL-TIME BURNED üî•</div>
                  <div class="text-4xl font-black mb-2">${Number(state.totalTokensBurned).toLocaleString(undefined, {maximumFractionDigits: 0})} $NEYNARTODES</div>
                  <div class="text-xs opacity-90 font-semibold">Permanently removed from supply</div>
                </div>

                <div class="bg-gradient-to-br from-yellow-400 to-orange-500 rounded-2xl shadow-2xl p-6 text-white border-4 border-yellow-300 transform hover:scale-105 transition-transform">
                  <div class="text-sm font-bold mb-2 opacity-90">üëë Leader üëë</div>
                  ${state.leaderboardData.length > 0 ? `
                    <a href="https://warpcast.com/${state.leaderboardData[0].username}" target="_blank" class="block hover:opacity-90 transition-opacity cursor-pointer">
                      <div class="flex items-center gap-2 mb-2">
                        ${state.leaderboardData[0].pfpUrl
                          ? `<img src="${state.leaderboardData[0].pfpUrl}" alt="@${state.leaderboardData[0].username}" class="w-10 h-10 rounded-full object-cover border-2 border-yellow-200" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="w-10 h-10 rounded-full bg-yellow-200 items-center justify-center text-lg text-yellow-800 hidden">${state.leaderboardData[0].pfp}</span>`
                          : `<span class="w-10 h-10 rounded-full bg-yellow-200 flex items-center justify-center text-lg text-yellow-800">${state.leaderboardData[0].pfp}</span>`
                        }
                        <span class="text-2xl font-black">@${state.leaderboardData[0].username}</span>
                      </div>
                      <div class="text-xs opacity-90 font-semibold">
                        ${state.leaderboardData[0].totalScore.toLocaleString()} points
                      </div>
                    </a>
                  ` : `
                    <div class="flex items-center gap-2 mb-2">
                      <span class="text-3xl font-black">TBA</span>
                    </div>
                    <div class="text-xs opacity-90 font-semibold">
                      Launch contests to compete!
                    </div>
                  `}
                </div>
              </div>

              <!-- All-Time Stats -->
              <div class="grid grid-cols-1 gap-4">
                <div class="bg-gradient-to-br from-emerald-400 to-green-600 rounded-2xl shadow-2xl p-6 text-white border-4 border-emerald-300">
                  <div class="text-sm font-bold mb-2 opacity-90">üíé ALL-TIME PRIZES üíé</div>
                  <div class="text-4xl font-black mb-2">${state.totalPrizesGiven.toFixed(4)} ETH</div>
                  <div class="text-xs opacity-90 font-semibold">Given to hosts & voters</div>
                </div>
              </div>

              <!-- Feed the Neynartodes Button -->
              ${parseFloat(state.pendingClankerFees) > 0 ? `
                <div class="bg-gradient-to-r from-orange-100 to-red-100 rounded-2xl shadow-xl p-6 border-4 border-orange-300">
                  <div class="flex items-center justify-between">
                    <div class="flex-1">
                      <h3 class="text-2xl font-black text-orange-800 mb-2">ü¶é Feed the Neynartodes! ü¶é</h3>
                      <p class="text-sm text-orange-700 font-semibold mb-2">
                        ${parseFloat(state.pendingClankerFees).toFixed(2)} $NEYNARTODES available from Clanker fees!
                      </p>
                      <p class="text-xs text-orange-600">
                        Click to collect fees and compound liquidity. 50% goes to treasury, 50% to recipient, then triggers Captain Hook!
                      </p>
                    </div>
                    <button
                      onclick="feedTheNeynartodes()"
                      class="ml-4 px-8 py-4 bg-gradient-to-r from-orange-500 to-red-600 hover:from-orange-600 hover:to-red-700 text-white rounded-2xl font-black text-xl transition-all shadow-lg transform hover:scale-105 border-2 border-orange-300"
                    >
                      üçñ FEED NOW
                    </button>
                  </div>
                </div>
              ` : ''}

              <!-- Voting Info -->
              <div class="bg-gradient-to-r from-pink-100 to-purple-100 rounded-2xl shadow-xl p-6 border-4 border-purple-300">
                <div class="flex items-center justify-between">
                  <div>
                    <h3 class="text-xl font-black text-purple-800 mb-1">‚ö° Your Voting Power ‚ö°</h3>
                    <p class="text-sm text-purple-700 font-semibold">
                      1000 $NEYNARTODES per vote ‚Ä¢ Resets daily üîÑ
                    </p>
                  </div>
                  <div class="text-right">
                    <div class="text-4xl font-black text-purple-600">${state.votesRemaining}/10</div>
                    <div class="text-xs text-purple-700 font-bold">Votes Left Today</div>
                  </div>
                </div>
                <div class="mt-4 bg-white p-4 rounded-xl border-2 border-purple-200 text-sm text-purple-800">
                  <p class="font-black mb-2">ü¶é How Voting Works:</p>
                  <ul class="mt-2 space-y-1 list-none font-semibold">
                    <li>üí∏ 1000 $NEYNARTODES per vote (50% üî• burned, 50% ‚Üí prize pool)</li>
                    <li>üëç Upvotes add 200 points | üëé Downvotes subtract 200 points</li>
                    <li>üìä 10 votes per day - make them count!</li>
                  </ul>
                </div>
              </div>

              <!-- Leaderboard Table -->
              <div class="bg-white rounded-2xl shadow-2xl p-6 border-4 border-purple-300">
                <div class="flex items-center justify-between mb-6">
                  <div class="flex items-center gap-3">
                    <div class="text-purple-600 text-4xl">üìà</div>
                    <div>
                      <h2 class="text-3xl font-black text-purple-800">ü¶é Colony Leaderboard ü¶é</h2>
                      <p class="text-sm text-purple-600 font-bold">Top Neynartode Feeders - Season ${state.currentSeason}</p>
                    </div>
                  </div>
                  <a
                    href="https://github.com/95m6sbvh6c-byte/neynartode/blob/main/docs/GUIDE_LEADERBOARD.md"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="w-8 h-8 rounded-full bg-purple-200 hover:bg-purple-300 flex items-center justify-center text-purple-700 font-bold text-sm transition-colors"
                    title="Leaderboard Guide"
                  >?</a>
                </div>

                <div class="overflow-x-auto">
                  ${state.leaderboardData.length === 0 ? `
                    <div class="text-center py-12">
                      <div class="text-6xl mb-4">ü¶é</div>
                      <h3 class="text-2xl font-black text-purple-800 mb-2">No Hosts Yet!</h3>
                      <p class="text-purple-600 font-semibold">Be the first to launch a contest and claim the top spot!</p>
                      <p class="text-sm text-purple-500 mt-2">Top 10 hosts will be displayed here</p>
                    </div>
                  ` : `
                  <table class="w-full">
                    <thead>
                      <tr class="border-b-2 border-gray-200">
                        <th class="text-left py-3 px-2 font-semibold text-gray-700">Rank</th>
                        <th class="text-left py-3 px-2 font-semibold text-gray-700">Host</th>
                        <th class="text-right py-3 px-2 font-semibold text-gray-700">Score</th>
                        <th class="text-center py-3 px-2 font-semibold text-gray-700">Vote</th>
                        <th class="text-right py-3 px-2 font-semibold text-gray-700">Completed</th>
                        <th class="text-right py-3 px-2 font-semibold text-gray-700">Neynar</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${state.leaderboardData.map(host => `
                        <tr class="border-b-2 border-purple-100 hover:bg-gradient-to-r hover:from-purple-50 hover:to-pink-50 transition-all">
                          <td class="py-4 px-2">
                            <div class="font-black text-xl ${
                              host.rank === 1 ? 'text-yellow-500 text-2xl' :
                              host.rank === 2 ? 'text-gray-400 text-xl' :
                              host.rank === 3 ? 'text-orange-500 text-xl' :
                              'text-purple-600'
                            }">
                              ${host.rank === 1 ? 'üëë' : host.rank === 2 ? 'ü•à' : host.rank === 3 ? 'ü•â' : `#${host.rank}`}
                            </div>
                          </td>
                          <td class="py-4 px-2">
                            <a href="https://warpcast.com/${host.username}" target="_blank" class="flex items-center gap-2 hover:opacity-80 transition-opacity cursor-pointer">
                              ${host.pfpUrl
                                ? `<img src="${host.pfpUrl}" alt="@${host.username}" class="w-10 h-10 rounded-full object-cover border-2 border-purple-300" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="w-10 h-10 rounded-full bg-purple-200 items-center justify-center text-lg hidden">${host.pfp}</span>`
                                : `<span class="w-10 h-10 rounded-full bg-purple-200 flex items-center justify-center text-lg">${host.pfp}</span>`
                              }
                              <div>
                                <div class="font-semibold text-gray-800 flex items-center gap-1 hover:text-purple-600">
                                  @${host.username}
                                  ${host.badges.map(badge => `<span title="${getBadgeTitle(badge)}">${getBadgeEmoji(badge)}</span>`).join('')}
                                </div>
                              </div>
                            </a>
                          </td>
                          <td class="py-4 px-2 text-right">
                            <div class="font-bold text-purple-600 text-lg" title="Contest: ${(host.contestScore || 0).toLocaleString()} | Votes: ${(host.voteScore || 0).toLocaleString()}">
                              ${(host.totalScore || 0).toLocaleString()}
                            </div>
                            <div class="text-xs text-gray-500">
                              <span title="Social Score">üí¨${(host.socialScore || 0).toLocaleString()}</span>
                              <span class="ml-1" title="Token Score">üí∞${(host.tokenScore || 0).toLocaleString()}</span>
                              <span class="ml-1" title="Vote Score (${host.upvotes || 0}üëç - ${host.downvotes || 0}üëé)">üó≥Ô∏è${(host.voteScore || 0).toLocaleString()}</span>
                            </div>
                          </td>
                          <td class="py-4 px-2">
                            <div class="flex gap-1 justify-center">
                              <button
                                onclick="voteForHost(${host.fid}, true)"
                                ${state.votesRemaining <= 0 ? 'disabled' : ''}
                                class="p-2 bg-green-100 hover:bg-green-200 disabled:bg-gray-100 disabled:cursor-not-allowed text-green-600 rounded transition-colors"
                                title="Upvote (+200 pts)"
                              >
                                üëç
                              </button>
                              <button
                                onclick="voteForHost(${host.fid}, false)"
                                ${state.votesRemaining <= 0 ? 'disabled' : ''}
                                class="p-2 bg-red-100 hover:bg-red-200 disabled:bg-gray-100 disabled:cursor-not-allowed text-red-600 rounded transition-colors"
                                title="Downvote (-200 pts)"
                              >
                                üëé
                              </button>
                            </div>
                          </td>
                          <td class="py-4 px-2 text-right text-gray-700">
                            <div class="font-semibold">${host.completedContests || host.contests || 0}</div>
                            <div class="text-xs text-gray-400">${host.contests || 0} total</div>
                          </td>
                          <td class="py-4 px-2 text-right">
                            <span class="bg-blue-100 text-blue-700 px-2 py-1 rounded text-sm font-semibold">
                              ${host.neynarScore}
                            </span>
                          </td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                  `}
                </div>

                <div class="mt-6 p-6 bg-gradient-to-r from-purple-100 to-pink-100 rounded-2xl border-4 border-purple-300">
                  <h3 class="font-black text-purple-900 mb-3 text-xl">ü¶é Scoring System ü¶é</h3>
                  <div class="text-sm text-purple-800 space-y-2 font-semibold">
                    <div>üéØ <strong>Total Score = Contest Score + Vote Score</strong></div>
                    <div>üìä Contest Score = (Social√ó3) + Token</div>
                    <div>üó≥Ô∏è Vote Score = (Upvotes - Downvotes) √ó 200</div>
                    <div>üí¨ Social = (Likes√ó1 + Recasts√ó2 + Replies√ó3) √ó 100</div>
                    <div>üí∞ Token = Volume Points √ó 50</div>
                  </div>
                </div>
              </div>

              <!-- Active Contests Section -->
              ${state.upcomingContests.length > 0 ? `
                <div class="bg-white rounded-2xl shadow-2xl p-6 border-4 border-green-300 mt-6">
                  <div class="flex items-center gap-3 mb-6">
                    <div class="text-green-600 text-4xl">üî•</div>
                    <div>
                      <h2 class="text-3xl font-black text-green-700">üî¥ Active Contests üî¥</h2>
                      <p class="text-sm text-green-600 font-bold">${state.upcomingContests.length} contest${state.upcomingContests.length > 1 ? 's' : ''} live now!</p>
                    </div>
                  </div>

                  <div class="space-y-4">
                    ${state.upcomingContests.filter(c => new Date(c.endTime) > new Date()).slice(0, 10).map(contest => {
                      const now = new Date();
                      const isLive = new Date(contest.startTime) <= now && new Date(contest.endTime) > now;
                      const isPending = contest.status === 1;
                      const timeLeft = Math.max(0, Math.floor((new Date(contest.endTime) - now) / 1000));
                      const hoursLeft = Math.floor(timeLeft / 3600);
                      const minutesLeft = Math.floor((timeLeft % 3600) / 60);

                      return `
                        <div class="border-2 ${isLive ? 'border-green-400 bg-green-50' : isPending ? 'border-yellow-400 bg-yellow-50' : 'border-purple-200 bg-purple-50'} rounded-xl p-4">
                          <div class="flex items-start justify-between">
                            <div class="flex-1">
                              <div class="flex items-center gap-2 mb-2">
                                ${isLive ? '<span class="bg-green-500 text-white px-3 py-1 rounded-full text-xs font-bold animate-pulse">üî¥ LIVE NOW</span>' : isPending ? '<span class="bg-yellow-500 text-white px-3 py-1 rounded-full text-xs font-bold">üé≤ PENDING VRF</span>' : '<span class="bg-purple-500 text-white px-3 py-1 rounded-full text-xs font-bold">‚è∞ UPCOMING</span>'}
                                <span class="text-sm font-semibold text-gray-700">Contest #${contest.contestId}</span>
                              </div>

                              <div class="flex items-center gap-2 mb-3">
                                ${contest.hostUser?.pfpUrl ? `<img src="${contest.hostUser.pfpUrl}" class="w-8 h-8 rounded-full border-2 border-purple-300" onerror="this.style.display='none'" />` : ''}
                                <span class="font-bold text-purple-700">${contest.hostUser?.username ? '@' + contest.hostUser.username : contest.host.slice(0, 10) + '...'}</span>
                              </div>

                              <div class="grid grid-cols-2 gap-3 mt-3">
                                <div class="bg-white p-2 rounded-lg">
                                  <div class="text-xs text-gray-600">üéÅ Prize</div>
                                  <div class="text-sm font-bold text-green-600">${contest.prize}</div>
                                </div>
                                <div class="bg-white p-2 rounded-lg">
                                  <div class="text-xs text-gray-600">‚è±Ô∏è Time Left</div>
                                  <div class="text-sm font-bold text-blue-600">${hoursLeft}h ${minutesLeft}m</div>
                                </div>
                                <div class="bg-white p-2 rounded-lg col-span-2">
                                  <div class="text-xs text-gray-600 mb-1">üìä Entry Requirements</div>
                                  <div class="flex flex-wrap gap-1">
                                    ${contest.requireRecast ? '<span class="bg-blue-100 text-blue-700 px-2 py-0.5 rounded text-xs font-semibold">üîÑ Recast</span>' : ''}
                                    ${contest.requireLike ? '<span class="bg-pink-100 text-pink-700 px-2 py-0.5 rounded text-xs font-semibold">‚ù§Ô∏è Like</span>' : ''}
                                    ${contest.requireReply ? '<span class="bg-green-100 text-green-700 px-2 py-0.5 rounded text-xs font-semibold">üí¨ Reply</span>' : ''}
                                    ${contest.volumeRequirement > 0 ? `<span class="bg-yellow-100 text-yellow-700 px-2 py-0.5 rounded text-xs font-semibold">üí∞ $${contest.volumeRequirement} ${contest.tokenRequirementSymbol || ''}</span>` : ''}
                                    ${!contest.requireRecast && !contest.requireLike && !contest.requireReply && !contest.volumeRequirement ? '<span class="bg-gray-100 text-gray-600 px-2 py-0.5 rounded text-xs font-semibold">üéÅ Open to all</span>' : ''}
                                  </div>
                                </div>
                              </div>

                            </div>
                          </div>
                        </div>
                      `;
                    }).join('')}
                  </div>

                  ${state.upcomingContests.length > 10 ? `
                    <div class="mt-4 text-center text-sm text-purple-600 font-semibold">
                      + ${state.upcomingContests.length - 10} more contests scheduled
                    </div>
                  ` : ''}
                </div>
              ` : ''}
            </div>
          </div>
        </div>
      `;
    }

    function renderHistory() {
      return `
        <div class="min-h-screen bg-gradient-to-b from-blue-100 via-purple-100 to-pink-100 p-6 relative">
          <div class="fixed inset-0 pointer-events-none opacity-10 overflow-hidden">
            <div class="absolute top-10 left-10 text-6xl">ü™∏</div>
            <div class="absolute top-40 right-20 text-5xl">üêö</div>
            <div class="absolute bottom-20 left-1/4 text-7xl">üåä</div>
            <div class="absolute bottom-40 right-1/3 text-5xl">ü´ß</div>
          </div>

          <div class="max-w-7xl mx-auto relative z-10">
            ${renderHeader()}

            <!-- Stats Summary -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
              <div class="bg-gradient-to-br from-purple-500 to-purple-700 rounded-2xl shadow-xl p-4 text-white border-4 border-purple-400">
                <div class="text-sm font-bold opacity-90">üìä Total Contests</div>
                <div class="text-3xl font-black">${state.historyTotal || 0}</div>
              </div>
              <div class="bg-gradient-to-br from-green-400 to-emerald-600 rounded-2xl shadow-xl p-4 text-white border-4 border-green-300">
                <div class="text-sm font-bold opacity-90">‚úÖ Completed</div>
                <div class="text-3xl font-black">${(state.historyData || []).filter(c => c.status === 2).length}</div>
              </div>
              <div class="bg-gradient-to-br from-blue-400 to-cyan-600 rounded-2xl shadow-xl p-4 text-white border-4 border-blue-300">
                <div class="text-sm font-bold opacity-90">üîµ Active</div>
                <div class="text-3xl font-black">${(state.historyData || []).filter(c => c.status === 0).length}</div>
              </div>
              <div class="bg-gradient-to-br from-yellow-400 to-orange-500 rounded-2xl shadow-xl p-4 text-white border-4 border-yellow-300">
                <div class="text-sm font-bold opacity-90">üé≤ Pending VRF</div>
                <div class="text-3xl font-black">${(state.historyData || []).filter(c => c.status === 1).length}</div>
              </div>
            </div>

            <!-- Contest History Table -->
            <div class="bg-white rounded-2xl shadow-2xl p-6 border-4 border-purple-300">
              <div class="flex items-center justify-between mb-6">
                <div class="flex items-center gap-3">
                  <div class="text-purple-600 text-4xl">üìú</div>
                  <div>
                    <h2 class="text-3xl font-black text-purple-800">Contest History</h2>
                    <p class="text-sm text-purple-600 font-bold">Last 20 contests on NEYNARtodes</p>
                  </div>
                </div>
                <div class="flex items-center gap-3">
                  <a
                    href="https://github.com/95m6sbvh6c-byte/neynartode/blob/main/docs/GUIDE_HISTORY.md"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="w-8 h-8 rounded-full bg-purple-200 hover:bg-purple-300 flex items-center justify-center text-purple-700 font-bold text-sm transition-colors"
                    title="History Guide"
                  >?</a>
                  <button
                    onclick="loadHistory()"
                    class="px-4 py-2 bg-purple-100 hover:bg-purple-200 text-purple-700 rounded-lg font-semibold transition-colors"
                  >
                    üîÑ Refresh
                  </button>
                </div>
              </div>

              ${state.historyLoading ? `
                <div class="text-center py-12">
                  <div class="text-6xl mb-4 animate-bounce">ü¶é</div>
                  <h3 class="text-2xl font-black text-purple-800 mb-2">Loading Contests...</h3>
                  <p class="text-purple-600 font-semibold">Fetching on-chain data</p>
                </div>
              ` : state.historyError ? `
                <div class="text-center py-12">
                  <div class="text-6xl mb-4">‚ùå</div>
                  <h3 class="text-2xl font-black text-red-800 mb-2">Error Loading History</h3>
                  <p class="text-red-600 font-semibold">${state.historyError}</p>
                  <button
                    onclick="loadHistory()"
                    class="mt-4 px-6 py-2 bg-red-100 hover:bg-red-200 text-red-700 rounded-lg font-semibold transition-colors"
                  >
                    Try Again
                  </button>
                </div>
              ` : state.historyData.length === 0 ? `
                <div class="text-center py-12">
                  <div class="text-6xl mb-4">ü¶é</div>
                  <h3 class="text-2xl font-black text-purple-800 mb-2">No Contests Yet!</h3>
                  <p class="text-purple-600 font-semibold">Be the first to launch a contest!</p>
                </div>
              ` : `
                <div class="overflow-x-auto">
                  <table class="w-full">
                    <thead>
                      <tr class="border-b-2 border-gray-200">
                        <th class="text-left py-3 px-2 font-semibold text-gray-700">#</th>
                        <th class="text-left py-3 px-2 font-semibold text-gray-700">Host</th>
                        <th class="text-left py-3 px-2 font-semibold text-gray-700">Prize</th>
                        <th class="text-center py-3 px-2 font-semibold text-gray-700">Duration</th>
                        <th class="text-center py-3 px-2 font-semibold text-gray-700">Participants</th>
                        <th class="text-center py-3 px-2 font-semibold text-gray-700">Status</th>
                        <th class="text-left py-3 px-2 font-semibold text-gray-700">Winner</th>
                        <th class="text-right py-3 px-2 font-semibold text-gray-700">Ended</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${state.historyData.map(contest => `
                        <tr class="border-b-2 border-purple-100 hover:bg-gradient-to-r hover:from-purple-50 hover:to-pink-50 transition-all">
                          <td class="py-4 px-2">
                            <div class="font-black text-purple-600">#${contest.contestId}</div>
                          </td>
                          <td class="py-4 px-2">
                            <div class="flex items-center gap-2">
                              ${contest.hostUser ? `
                                <a href="https://warpcast.com/${contest.hostUser.username}" target="_blank" class="flex items-center gap-2 hover:opacity-80 transition-opacity">
                                  ${contest.hostUser.pfpUrl
                                    ? `<img src="${contest.hostUser.pfpUrl}" alt="@${contest.hostUser.username}" class="w-8 h-8 rounded-full object-cover border-2 border-purple-300" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="w-8 h-8 rounded-full bg-purple-200 items-center justify-center text-sm hidden">üë§</span>`
                                    : `<span class="w-8 h-8 rounded-full bg-purple-200 flex items-center justify-center text-sm">üë§</span>`
                                  }
                                  <div>
                                    <div class="font-semibold text-gray-800 hover:text-purple-600">@${contest.hostUser.username}</div>
                                    <div class="text-xs text-gray-500">${contest.host.slice(0, 8)}...</div>
                                  </div>
                                </a>
                              ` : `
                                <div class="font-mono text-sm text-gray-600">${contest.host.slice(0, 10)}...</div>
                              `}
                            </div>
                          </td>
                          <td class="py-4 px-2">
                            <div class="font-bold text-green-600">
                              ${contest.prizeAmount.toLocaleString(undefined, { maximumFractionDigits: 4 })} $${contest.prizeTokenSymbol}
                            </div>
                            ${contest.volumeRequirement > 0 ? `
                              <div class="text-xs text-gray-500">
                                Min: $${contest.volumeRequirement} ${contest.tokenRequirementSymbol || ''}
                              </div>
                            ` : ''}
                          </td>
                          <td class="py-4 px-2 text-center">
                            <div class="text-gray-700 font-semibold">
                              ${formatDuration(contest.durationHours, contest.durationMinutes)}
                            </div>
                          </td>
                          <td class="py-4 px-2 text-center">
                            <div class="bg-purple-100 text-purple-700 px-3 py-1 rounded-full text-sm font-bold inline-block">
                              üë• ${contest.participantCount}
                            </div>
                          </td>
                          <td class="py-4 px-2 text-center">
                            <span class="${getStatusColor(contest.status)} px-3 py-1 rounded-full text-sm font-bold">
                              ${getStatusEmoji(contest.status)} ${contest.statusText}
                            </span>
                          </td>
                          <td class="py-4 px-2">
                            ${contest.status === 2 && contest.winner !== '0x0000000000000000000000000000000000000000' ? `
                              <div class="flex items-center gap-2">
                                <span class="text-lg">üèÜ</span>
                                ${contest.winnerUser ? `
                                  <a href="https://warpcast.com/${contest.winnerUser.username}" target="_blank" class="flex items-center gap-2 hover:opacity-80 transition-opacity">
                                    ${contest.winnerUser.pfpUrl
                                      ? `<img src="${contest.winnerUser.pfpUrl}" alt="@${contest.winnerUser.username}" class="w-8 h-8 rounded-full object-cover border-2 border-yellow-400" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="w-8 h-8 rounded-full bg-yellow-200 items-center justify-center text-sm hidden">üë§</span>`
                                      : `<span class="w-8 h-8 rounded-full bg-yellow-200 flex items-center justify-center text-sm">üë§</span>`
                                    }
                                    <div>
                                      <div class="font-semibold text-yellow-700 hover:text-yellow-600">@${contest.winnerUser.username}</div>
                                      <div class="text-xs text-gray-500">${contest.winner.slice(0, 8)}...</div>
                                    </div>
                                  </a>
                                ` : `
                                  <div class="font-mono text-sm text-gray-600">${contest.winner.slice(0, 10)}...</div>
                                `}
                              </div>
                            ` : `
                              <span class="text-gray-400 text-sm">-</span>
                            `}
                          </td>
                          <td class="py-4 px-2 text-right">
                            <div class="text-sm text-gray-600">
                              ${formatDate(contest.endTime)}
                            </div>
                          </td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>

                <!-- Legend -->
                <div class="mt-6 p-4 bg-gray-50 rounded-xl border-2 border-gray-200">
                  <p class="text-sm font-semibold text-gray-700 mb-2">Status Legend:</p>
                  <div class="flex flex-wrap gap-4 text-sm">
                    <span class="bg-blue-100 text-blue-700 px-2 py-1 rounded">üîµ Active - Contest running</span>
                    <span class="bg-yellow-100 text-yellow-700 px-2 py-1 rounded">üé≤ PendingVRF - Awaiting random winner</span>
                    <span class="bg-green-100 text-green-700 px-2 py-1 rounded">‚úÖ Completed - Winner selected</span>
                    <span class="bg-red-100 text-red-700 px-2 py-1 rounded">‚ùå Cancelled - Contest cancelled</span>
                  </div>
                </div>
              `}
            </div>
          </div>
        </div>
      `;
    }

    function renderSuggestions() {
      const isDev = isDevWallet(state.userAddress);

      // Build DEV-only suggestions list
      let suggestionsHtml = '';
      if (isDev) {
        if (state.suggestionsLoading) {
          suggestionsHtml = `
            <div class="text-center py-8">
              <div class="text-4xl mb-2 animate-bounce">üí°</div>
              <p class="text-yellow-700 font-semibold">Loading suggestions...</p>
            </div>
          `;
        } else if (state.suggestions.length === 0) {
          suggestionsHtml = `
            <div class="text-center py-8">
              <div class="text-4xl mb-2">üì≠</div>
              <p class="text-yellow-700 font-semibold">No suggestions yet</p>
            </div>
          `;
        } else {
          suggestionsHtml = `
            <div class="space-y-3 max-h-96 overflow-y-auto">
              ${state.suggestions.map(s => `
                <div class="bg-white rounded-lg p-4 border border-yellow-200">
                  <div class="flex items-start justify-between gap-3">
                    <p class="text-gray-800 flex-1">${s.text}</p>
                    <span class="text-xs text-gray-400 whitespace-nowrap">${new Date(s.timestamp).toLocaleDateString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
            <p class="text-xs text-yellow-600 mt-4">Total: ${state.suggestions.length} suggestions</p>
          `;
        }
      }

      return `
        <div class="min-h-screen bg-gradient-to-b from-blue-100 via-purple-100 to-pink-100 p-6 relative">
          <div class="fixed inset-0 pointer-events-none opacity-10 overflow-hidden">
            <div class="absolute top-10 left-10 text-6xl">ü™∏</div>
            <div class="absolute top-40 right-20 text-5xl">üêö</div>
            <div class="absolute bottom-20 left-1/4 text-7xl">üåä</div>
            <div class="absolute bottom-40 right-1/3 text-5xl">ü´ß</div>
          </div>

          <div class="max-w-7xl mx-auto relative z-10">
            ${renderHeader()}

            <div class="bg-white rounded-2xl shadow-2xl p-6 border-4 border-purple-300">
              <div class="flex items-center gap-3 mb-6">
                <div class="text-purple-600 text-4xl">üí°</div>
                <div>
                  <h2 class="text-3xl font-black text-purple-800">Suggestion Box</h2>
                  <p class="text-sm text-purple-600 font-bold">Help us improve NEYNARtodes!</p>
                </div>
              </div>

              <!-- Submission Form -->
              <div class="bg-purple-50 rounded-xl p-6 border-2 border-purple-200 mb-6">
                <h3 class="text-xl font-bold text-purple-800 mb-4">üìù Submit a Suggestion</h3>
                <p class="text-sm text-purple-700 mb-4">
                  Your submission is <strong>completely anonymous</strong> - no wallet address or identity is stored.
                </p>
                <textarea
                  id="suggestionInput"
                  placeholder="Share your idea, feedback, or suggestion..."
                  class="w-full px-4 py-3 border-2 border-purple-300 rounded-xl focus:border-purple-500 focus:outline-none resize-none h-32 text-gray-800"
                  maxlength="1000"
                >${state.suggestionText}</textarea>
                <div class="flex items-center justify-between mt-3">
                  <span class="text-xs text-purple-600">${state.suggestionText.length}/1000 characters</span>
                  <button
                    id="submitSuggestion"
                    class="px-6 py-3 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-xl font-bold transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
                    ${state.suggestionText.trim().length < 10 ? 'disabled' : ''}
                  >
                    üöÄ Submit Anonymously
                  </button>
                </div>
                <p class="text-xs text-purple-500 mt-2">Minimum 10 characters required</p>
              </div>

              ${isDev ? `
              <!-- DEV Only: View All Suggestions -->
              <div class="bg-yellow-50 rounded-xl p-6 border-2 border-yellow-300">
                <div class="flex items-center justify-between mb-4">
                  <h3 class="text-xl font-bold text-yellow-800">üîí All Suggestions (DEV Only)</h3>
                  <button
                    id="refreshSuggestions"
                    class="px-4 py-2 bg-yellow-200 hover:bg-yellow-300 text-yellow-800 rounded-lg font-semibold transition-colors"
                  >
                    üîÑ Refresh
                  </button>
                </div>
                ${suggestionsHtml}
              </div>
              ` : `
              <!-- Non-DEV: Thank you message -->
              <div class="bg-green-50 rounded-xl p-6 border-2 border-green-200 text-center">
                <div class="text-4xl mb-3">üôè</div>
                <h3 class="text-xl font-bold text-green-800 mb-2">Thank You!</h3>
                <p class="text-green-700">
                  Your anonymous suggestions help make NEYNARtodes better for everyone.
                </p>
              </div>
              `}
            </div>
          </div>
        </div>
      `;
    }

    function renderCreateContest() {
      return `
        <div class="min-h-screen bg-gradient-to-b from-blue-100 via-purple-100 to-pink-100 p-6 relative">
          <div class="fixed inset-0 pointer-events-none opacity-10 overflow-hidden">
            <div class="absolute top-10 left-10 text-6xl">ü™∏</div>
            <div class="absolute top-40 right-20 text-5xl">üêö</div>
            <div class="absolute bottom-20 left-1/4 text-7xl">üåä</div>
          </div>

          <div class="max-w-7xl mx-auto relative z-10">
            ${renderHeader()}

            <!-- Safeguards Notice -->
            <div class="bg-blue-50 border-2 border-blue-300 rounded-lg p-4 mb-6">
              <h3 class="font-bold text-blue-900 mb-2">üõ°Ô∏è Season 0 Safeguards Active</h3>
              <div class="text-sm text-blue-800 space-y-1">
                <p>‚Ä¢ <strong>Whitelist Required:</strong> Only whitelisted addresses can participate</p>
                <p>‚Ä¢ <strong>Token Gate:</strong> Minimum 20,000 $NEYNARTODES required</p>
                <p>‚Ä¢ <strong>Reply Quality:</strong> Minimum 4 words per reply to prevent spam</p>
                <p>‚Ä¢ <strong>Trade Volume Cap:</strong> $10 max for NEYNARTODES, or ‚â§ prize for custom token</p>
              </div>
            </div>

            <div class="bg-white rounded-2xl shadow-2xl p-8 border-4 border-purple-300">
              <div class="flex items-center justify-between mb-6">
                <h2 class="text-3xl font-black text-purple-800">üéâ Create New Contest üéâ</h2>
                <a
                  href="https://github.com/95m6sbvh6c-byte/neynartode/blob/main/docs/GUIDE_CREATE.md"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="w-8 h-8 rounded-full bg-purple-200 hover:bg-purple-300 flex items-center justify-center text-purple-700 font-bold text-sm transition-colors"
                  title="Create Contest Guide"
                >?</a>
              </div>

              <div class="space-y-6">
                <!-- Contest Period -->
                <div class="p-6 bg-purple-50 rounded-xl border-2 border-purple-200">
                  <h3 class="text-xl font-bold text-purple-800 mb-4">üìÖ Contest Period</h3>

                  <div class="mb-4">
                    <label class="block text-sm font-semibold text-gray-700 mb-2">Start Mode</label>
                    <div class="flex gap-3">
                      <button id="startNow" class="flex-1 py-2 rounded-lg font-semibold transition-colors ${state.startMode === 'now' ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-600'}">
                        Start Now
                      </button>
                      <button id="startScheduled" class="flex-1 py-2 rounded-lg font-semibold transition-colors ${state.startMode === 'scheduled' ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-600'}">
                        Schedule
                      </button>
                    </div>
                  </div>

                  ${state.startMode === 'scheduled' ? `
                    <div class="mb-4">
                      <label class="block text-sm font-semibold text-gray-700 mb-2">Start Date & Time</label>
                      <input type="datetime-local" id="startDate" value="${state.startDate}" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                    </div>
                  ` : ''}

                  <div class="mb-4">
                    <label class="block text-sm font-semibold text-gray-700 mb-2">Contest Duration</label>
                    <div class="grid grid-cols-2 gap-3">
                      <div>
                        <label class="block text-xs text-gray-600 mb-1">Hours</label>
                        <input type="number" id="durationHours" value="${state.durationHours}" min="0" max="720" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      </div>
                      <div>
                        <label class="block text-xs text-gray-600 mb-1">Minutes</label>
                        <input type="number" id="durationMinutes" value="${state.durationMinutes}" min="0" max="59" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      </div>
                    </div>
                    <p class="text-xs text-gray-600 mt-2">‚è±Ô∏è Minimum duration: 1 minute</p>
                  </div>

                  ${state.startMode === 'scheduled' && state.startDate && state.durationHours !== '' && state.durationMinutes !== '' ? `
                    <div class="bg-purple-100 p-3 rounded-lg">
                      <p class="text-xs text-purple-800 font-semibold mb-1">üìÖ Contest Timeline:</p>
                      <p class="text-sm text-purple-900">
                        <strong>Starts:</strong> ${new Date(state.startDate).toLocaleString()}<br/>
                        <strong>Duration:</strong> ${state.durationHours}h ${state.durationMinutes}m<br/>
                        <strong>Ends:</strong> ${(() => {
                          const start = new Date(state.startDate);
                          const hours = parseInt(state.durationHours) || 0;
                          const minutes = parseInt(state.durationMinutes) || 0;
                          const end = new Date(start.getTime() + (hours * 60 + minutes) * 60 * 1000);
                          return end.toLocaleString();
                        })()}
                      </p>
                    </div>
                  ` : state.startMode === 'now' && state.durationHours !== '' && state.durationMinutes !== '' ? `
                    <div class="bg-purple-100 p-3 rounded-lg">
                      <p class="text-xs text-purple-800 font-semibold mb-1">üìÖ Contest Duration:</p>
                      <p class="text-sm text-purple-900">
                        <strong>Starts:</strong> Immediately upon launch<br/>
                        <strong>Duration:</strong> ${state.durationHours}h ${state.durationMinutes}m
                      </p>
                    </div>
                  ` : ''}
                </div>

                <!-- Prize Settings -->
                <div class="p-6 bg-green-50 rounded-xl border-2 border-green-200">
                  <h3 class="text-xl font-bold text-green-800 mb-4">üéÅ Prize (Token Only)</h3>

                  <div class="space-y-4">
                    <div class="relative">
                      <label class="block text-sm font-semibold text-gray-700 mb-2">Search Token</label>
                      <input type="text" id="prizeTokenSearch" value="${state.prizeTokenSearch}" placeholder="USDC, ETH, NEYNARTODES..." class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      ${state.showPrizeTokenSuggestions ? `
                        <div class="absolute z-10 w-full mt-1 bg-white border-2 border-purple-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto">
                          ${searchTokens(state.prizeTokenSearch).map((token, idx) => `
                            <button onclick="selectPrizeToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-purple-50 border-b border-gray-100 transition-colors flex items-center gap-3">
                              <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-purple-200" onerror="this.src='https://via.placeholder.com/40/9333ea/ffffff?text=${token.ticker[0]}'" />
                              <div class="flex-1">
                                <div class="font-semibold text-gray-800">${token.name} <span class="text-purple-600">(${token.ticker})</span></div>
                                <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
                              </div>
                              <div class="text-right">
                                <div class="text-xs text-gray-600">Market Cap</div>
                                <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
                              </div>
                            </button>
                          `).join('')}
                        </div>
                      ` : ''}
                    </div>

                    ${state.prizeTokenAddress ? `
                      <div class="bg-gradient-to-r from-purple-50 to-pink-50 p-4 rounded-lg border-2 border-purple-200 flex items-center gap-3">
                        <img src="${state.prizeTokenImage}" alt="${state.prizeTokenTicker}" class="w-12 h-12 rounded-full object-cover border-2 border-purple-400 shadow-lg" onerror="this.src='https://via.placeholder.com/48/9333ea/ffffff?text=${state.prizeTokenTicker[0]}'" />
                        <div class="flex-1">
                          <div class="text-xs text-purple-600 font-semibold mb-1">‚úì Selected Prize Token</div>
                          <div class="font-bold text-purple-900 text-lg">${state.prizeTokenTicker}</div>
                          <div class="text-xs text-gray-500 font-mono">${state.prizeTokenAddress.substring(0, 10)}...${state.prizeTokenAddress.substring(38)}</div>
                        </div>
                      </div>
                    ` : ''}

                    <div>
                      <label class="block text-sm font-semibold text-gray-700 mb-2">Prize Amount</label>
                      <input type="number" id="prizeTokenAmount" value="${state.prizeTokenAmount}" placeholder="1000" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                    </div>
                  </div>
                </div>

                <!-- Social Dynamics (Always ON) -->
                <div class="p-6 bg-pink-50 rounded-xl border-2 border-pink-200">
                  <div class="flex items-center justify-between mb-4">
                    <h3 class="text-xl font-bold text-pink-800">üë• Social Dynamics</h3>
                    <span class="px-4 py-2 rounded-lg font-semibold bg-purple-600 text-white">REQUIRED</span>
                  </div>

                  <div class="space-y-4">
                    <!-- Cast URL/Hash - REQUIRED -->
                    <div class="bg-yellow-50 p-4 rounded-lg border-2 border-yellow-300">
                      <label class="block text-sm font-semibold text-gray-700 mb-2">üì¢ Contest Cast URL <span class="text-red-500">*</span></label>
                      <input type="text" id="castHash" value="${state.castHash}" placeholder="https://warpcast.com/username/0x1234abcd or 0x1234abcd" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      <p class="text-xs text-yellow-700 mt-2">‚ö†Ô∏è <strong>Post your contest announcement on Warpcast first!</strong> Then paste the cast URL or hash here. Engagement (recasts, replies) on this cast determines eligible participants.</p>
                    </div>

                    <div class="grid grid-cols-3 gap-3">
                      <div>
                        <label class="block text-xs font-semibold text-gray-700 mb-2">Min Likes (0-1)</label>
                        <input type="number" id="minLikes" value="${state.minLikes}" min="0" max="1" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      </div>
                      <div>
                        <label class="block text-xs font-semibold text-gray-700 mb-2">Min Recasts (0-1)</label>
                        <input type="number" id="minRecasts" value="${state.minRecasts}" min="0" max="1" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      </div>
                      <div>
                        <label class="block text-xs font-semibold text-gray-700 mb-2">Min Replies</label>
                        <input type="number" id="minReplies" value="${state.minReplies}" min="0" class="w-full px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                      </div>
                    </div>
                    <p class="text-xs text-pink-700 font-semibold">üìù Replies must have at least 4 words to count</p>
                  </div>
                </div>

                <!-- Tokenomics (Can be toggled off for 0.001 ETH) -->
                <div class="p-6 bg-green-50 rounded-xl border-2 border-green-200">
                  <div class="flex items-center justify-between mb-4">
                    <h3 class="text-xl font-bold text-green-800">üí∞ Trading Volume Requirement</h3>
                    ${isDevWallet(state.userAddress) ? `
                      <label class="flex items-center gap-3 cursor-pointer">
                        <span class="text-sm font-semibold text-gray-700">Enable Tokenomics</span>
                        <div class="relative">
                          <input type="checkbox" id="tokenomicsToggle" ${state.tokenomicsEnabled ? 'checked' : ''} class="sr-only peer" />
                          <div class="w-14 h-7 bg-gray-300 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[4px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-purple-600"></div>
                        </div>
                        <span class="text-xs text-gray-500">(Dev: FREE)</span>
                      </label>
                    ` : `
                      <label class="flex items-center gap-3 cursor-pointer">
                        <span class="text-sm font-semibold text-gray-700">Enable Tokenomics</span>
                        <div class="relative">
                          <input type="checkbox" id="tokenomicsToggle" ${state.tokenomicsEnabled ? 'checked' : ''} class="sr-only peer" />
                          <div class="w-14 h-7 bg-gray-300 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[4px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-purple-600"></div>
                        </div>
                        <span class="text-xs ${state.tokenomicsEnabled ? 'text-green-600 font-semibold' : 'text-orange-600 font-semibold'}">${state.tokenomicsEnabled ? '(Enabled)' : '(-0.001 ETH to disable)'}</span>
                      </label>
                    `}
                  </div>

                  ${state.tokenomicsEnabled ? `

                  <div class="space-y-4">
                    <!-- Default Token Info -->
                    <div class="bg-gradient-to-r from-green-50 to-emerald-50 p-4 rounded-lg border-2 border-green-200">
                      <div class="flex items-center gap-3">
                        <div class="w-12 h-12 rounded-full bg-purple-600 flex items-center justify-center text-white text-xl font-bold border-2 border-green-400 shadow-lg">ü¶é</div>
                        <div class="flex-1">
                          <div class="text-xs text-green-600 font-semibold mb-1">Default Token (FREE)</div>
                          <div class="font-bold text-green-900 text-lg">NEYNARTODES</div>
                          <div class="text-xs text-gray-500 font-mono">${CONFIG.CONTRACTS.neynartodes.substring(0, 10)}...${CONFIG.CONTRACTS.neynartodes.substring(38)}</div>
                        </div>
                      </div>
                    </div>

                    <!-- Custom Token Option -->
                    <div class="border-2 border-dashed border-green-300 rounded-lg p-4">
                      <div class="flex items-center gap-2 mb-3">
                        <input type="checkbox" id="useCustomToken" ${state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase() ? 'checked' : ''} class="w-5 h-5 rounded border-gray-300 text-purple-600 focus:ring-purple-500" />
                        <label for="useCustomToken" class="text-sm font-semibold text-gray-700">Use Custom Token (+0.001 ETH fee)</label>
                      </div>

                      <div id="customTokenSection" class="${state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase() ? '' : 'hidden'}">
                        <div class="relative mb-3">
                          <label class="block text-sm font-semibold text-gray-700 mb-2">Search Token</label>
                          <input type="text" id="tokenSearch" value="${state.tokenSearch}" placeholder="Search: USDC, ETH, BRETT..." class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                          ${state.showTokenSuggestions ? `
                            <div class="absolute z-10 w-full mt-1 bg-white border-2 border-green-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto">
                              ${searchTokens(state.tokenSearch).map((token, idx) => `
                                <button onclick="selectToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-green-50 border-b border-gray-100 transition-colors flex items-center gap-3">
                                  <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-green-200" onerror="this.src='https://via.placeholder.com/40/22c55e/ffffff?text=${token.ticker[0]}'" />
                                  <div class="flex-1">
                                    <div class="font-semibold text-gray-800">${token.name} <span class="text-green-600">(${token.ticker})</span></div>
                                    <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
                                  </div>
                                  <div class="text-right">
                                    <div class="text-xs text-gray-600">Market Cap</div>
                                    <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
                                  </div>
                                </button>
                              `).join('')}
                            </div>
                          ` : ''}
                        </div>

                        ${state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase() ? `
                          <div class="bg-gradient-to-r from-orange-50 to-yellow-50 p-4 rounded-lg border-2 border-orange-200 flex items-center gap-3">
                            <img src="${state.tokenImage}" alt="${state.tokenTicker}" class="w-12 h-12 rounded-full object-cover border-2 border-orange-400 shadow-lg" onerror="this.src='https://via.placeholder.com/48/22c55e/ffffff?text=${state.tokenTicker[0]}'" />
                            <div class="flex-1">
                              <div class="text-xs text-orange-600 font-semibold mb-1">‚úì Custom Token (+0.001 ETH)</div>
                              <div class="font-bold text-orange-900 text-lg">${state.tokenTicker}</div>
                              <div class="text-xs text-gray-500 font-mono">${state.tokenAddress.substring(0, 10)}...${state.tokenAddress.substring(38)}</div>
                            </div>
                          </div>
                        ` : ''}
                      </div>
                    </div>

                    <!-- Trade Volume Input -->
                    <div>
                      <label class="block text-sm font-semibold text-gray-700 mb-2">Min Trade Volume ($)</label>
                      ${state.tokenAddress && state.tokenAddress.toLowerCase() === CONFIG.CONTRACTS.neynartodes.toLowerCase() ? `
                        <input type="number" id="minTradeVolume" value="10" readonly class="w-full px-4 py-2 border-2 border-green-300 rounded-lg bg-green-50 text-green-800 font-bold cursor-not-allowed" />
                        <p class="text-xs text-green-600 mt-1 font-semibold">üîí NEYNARTODES volume is locked at $10</p>
                      ` : `
                        <input type="number" id="minTradeVolume" value="${state.minTradeVolume}" placeholder="0" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none" />
                        <p class="text-xs text-gray-600 mt-1">Custom token: max volume = prize amount</p>
                      `}
                    </div>

                    <div class="bg-blue-50 border-l-4 border-blue-400 p-3 rounded">
                      <p class="text-xs text-blue-800 font-semibold">
                        üí° <strong>NEYNARTODES:</strong> Locked at $10 (FREE) | <strong>Custom token:</strong> Volume ‚â§ prize amount (+0.001 ETH fee)
                      </p>
                    </div>
                  </div>
                  ` : `
                  <div class="bg-gray-100 p-4 rounded-lg text-center">
                    <p class="text-gray-600 font-semibold">Tokenomics disabled - No volume requirements</p>
                    <p class="text-xs text-gray-500 mt-1">Toggle ON to enable trading volume requirements</p>
                  </div>
                  `}
                </div>

                <!-- Winner Announcement -->
                <div class="p-6 bg-yellow-50 rounded-xl border-2 border-yellow-200">
                  <h3 class="text-xl font-bold text-yellow-800 mb-4">üí¨ Winner Announcement</h3>
                  <label class="block text-sm font-semibold text-gray-700 mb-2">Custom Message</label>
                  <textarea id="customMessage" rows="3" placeholder="You just won our amazing contest!" class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none">${state.customMessage}</textarea>
                </div>

                <!-- Pending Transaction Banner -->
                ${state.pendingTx ? `
                  <div class="mb-4 p-4 bg-yellow-100 border-2 border-yellow-400 rounded-xl animate-pulse">
                    <div class="flex items-center justify-center gap-3 text-yellow-800 font-bold">
                      <span class="animate-spin">‚è≥</span>
                      <span>Transaction Pending...</span>
                    </div>
                    <a href="https://basescan.org/tx/${state.pendingTx}" target="_blank" class="block text-center text-sm text-blue-600 underline mt-2">
                      View on BaseScan ‚Üí
                    </a>
                  </div>
                ` : ''}

                <!-- Launch Button -->
                <button id="launchButton" class="w-full flex items-center justify-center gap-3 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white px-8 py-6 rounded-2xl font-bold text-2xl transition-all shadow-2xl transform hover:scale-105 ${state.pendingTx ? 'opacity-50 cursor-not-allowed' : ''}" ${state.pendingTx ? 'disabled' : ''}>
                  ${state.pendingTx ? '‚è≥ LAUNCHING...' : '‚ñ∂Ô∏è LAUNCH CONTEST'}
                </button>
                <p id="launchStatus" class="text-center text-sm text-blue-600 font-bold mt-2"></p>
                <p class="text-center text-sm text-gray-600">
                  ‚ö†Ô∏è Prize will be locked in escrow smart contract
                </p>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // ===== DROPDOWN HELPERS =====
    function updatePrizeTokenDropdown() {
      const container = document.getElementById('prizeTokenSearch')?.parentElement;
      if (!container) return;

      // Remove old dropdown if exists
      const oldDropdown = container.querySelector('.absolute');
      if (oldDropdown) oldDropdown.remove();

      // Create new dropdown if needed
      if (state.showPrizeTokenSuggestions && state.prizeTokenSearch.length >= 2) {
        const results = searchTokens(state.prizeTokenSearch);
        const dropdown = document.createElement('div');
        dropdown.className = 'absolute z-10 w-full mt-1 bg-white border-2 border-purple-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto';
        dropdown.style.top = '100%';
        dropdown.style.left = '0';

        if (results.length === 0) {
          // Show "no results" message with option to use custom address
          dropdown.innerHTML = `
            <div class="p-4 text-center">
              <div class="text-gray-600 mb-2">No tokens found for "${state.prizeTokenSearch}"</div>
              <div class="text-xs text-gray-500 mb-3">
                Token not listed? You can use a custom address below after closing this.
              </div>
              <button onclick="showCustomPrizeToken()" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors text-sm font-semibold">
                ‚ûï Use Custom Token Address
              </button>
            </div>
          `;
        } else {
          dropdown.innerHTML = results.map((token, idx) => `
            <button onclick="selectPrizeToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-purple-50 border-b border-gray-100 transition-colors flex items-center gap-3">
              <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-purple-200" onerror="this.src='https://via.placeholder.com/40/9333ea/ffffff?text=${token.ticker[0]}'" />
              <div class="flex-1">
                <div class="font-semibold text-gray-800">${token.name} <span class="text-purple-600">(${token.ticker})</span></div>
                <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
              </div>
              <div class="text-right">
                <div class="text-xs text-gray-600">Market Cap</div>
                <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
              </div>
            </button>
          `).join('') + `
            <button onclick="showCustomPrizeToken()" class="w-full text-left px-4 py-3 bg-purple-50 hover:bg-purple-100 transition-colors border-t-2 border-purple-200">
              <div class="font-semibold text-purple-700 text-center">‚ûï Use Custom Token Address</div>
            </button>
          `;
        }

        container.appendChild(dropdown);
      }
    }

    function updateTokenDropdown() {
      const container = document.getElementById('tokenSearch')?.parentElement;
      if (!container) return;

      // Remove old dropdown if exists
      const oldDropdown = container.querySelector('.absolute');
      if (oldDropdown) oldDropdown.remove();

      // Create new dropdown if needed
      if (state.showTokenSuggestions && state.tokenSearch.length >= 2) {
        const results = searchTokens(state.tokenSearch);
        const dropdown = document.createElement('div');
        dropdown.className = 'absolute z-10 w-full mt-1 bg-white border-2 border-green-300 rounded-lg shadow-2xl max-h-80 overflow-y-auto';
        dropdown.style.top = '100%';
        dropdown.style.left = '0';

        if (results.length === 0) {
          // Show "no results" message with option to use custom address
          dropdown.innerHTML = `
            <div class="p-4 text-center">
              <div class="text-gray-600 mb-2">No tokens found for "${state.tokenSearch}"</div>
              <div class="text-xs text-gray-500 mb-3">
                Token not listed? You can use a custom address below after closing this.
              </div>
              <button onclick="showCustomToken()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-semibold">
                ‚ûï Use Custom Token Address
              </button>
            </div>
          `;
        } else {
          dropdown.innerHTML = results.map((token, idx) => `
            <button onclick="selectToken(${idx})" class="w-full text-left px-4 py-3 hover:bg-green-50 border-b border-gray-100 transition-colors flex items-center gap-3">
              <img src="${token.image}" alt="${token.ticker}" class="w-10 h-10 rounded-full object-cover border-2 border-green-200" onerror="this.src='https://via.placeholder.com/40/22c55e/ffffff?text=${token.ticker[0]}'" />
              <div class="flex-1">
                <div class="font-semibold text-gray-800">${token.name} <span class="text-green-600">(${token.ticker})</span></div>
                <div class="text-xs text-gray-500 font-mono">${token.address.substring(0, 10)}...${token.address.substring(38)}</div>
              </div>
              <div class="text-right">
                <div class="text-xs text-gray-600">Market Cap</div>
                <div class="text-sm font-bold text-green-600">$${(token.mcap / 1000000).toFixed(1)}M</div>
              </div>
            </button>
          `).join('') + `
            <button onclick="showCustomToken()" class="w-full text-left px-4 py-3 bg-green-50 hover:bg-green-100 transition-colors border-t-2 border-green-200">
              <div class="font-semibold text-green-700 text-center">‚ûï Use Custom Token Address</div>
            </button>
          `;
        }

        container.appendChild(dropdown);
      }
    }

    // ===== EVENT LISTENERS =====
    function attachEventListeners() {
      // Login page
      const connectButton = document.getElementById('connectButton');
      if (connectButton) {
        connectButton.onclick = connectWallet;
      }

      // View switching
      const viewCreate = document.getElementById('viewCreate');
      const viewHistory = document.getElementById('viewHistory');
      const viewLeaderboard = document.getElementById('viewLeaderboard');

      if (viewCreate) viewCreate.onclick = () => {
        state.currentView = 'create';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'create' });
        stopHistoryAutoRefresh();
        stopCountdownTimer();
        render();
      };
      if (viewHistory) viewHistory.onclick = () => {
        state.currentView = 'history';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'history' });
        stopCountdownTimer();
        // Always refresh history when switching to this view
        loadHistory();
        // Start auto-refresh for active/pending contests
        startHistoryAutoRefresh();
      };
      if (viewLeaderboard) viewLeaderboard.onclick = () => {
        state.currentView = 'leaderboard';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'leaderboard' });
        stopHistoryAutoRefresh();
        startCountdownTimer();
        render();
      };

      // Suggestions tab
      const viewSuggestions = document.getElementById('viewSuggestions');
      if (viewSuggestions) viewSuggestions.onclick = () => {
        state.currentView = 'suggestions';
        if (window.analytics?.track) window.analytics.track('View Changed', { view: 'suggestions' });
        stopHistoryAutoRefresh();
        stopCountdownTimer();
        // Load suggestions for DEV
        if (isDevWallet(state.userAddress)) {
          loadSuggestions();
        }
        render();
      };

      // Suggestions form handlers
      const suggestionInput = document.getElementById('suggestionInput');
      if (suggestionInput) {
        suggestionInput.oninput = (e) => {
          state.suggestionText = e.target.value;
          render();
        };
      }

      const submitSuggestion = document.getElementById('submitSuggestion');
      if (submitSuggestion) {
        submitSuggestion.onclick = () => submitAnonymousSuggestion();
      }

      const refreshSuggestions = document.getElementById('refreshSuggestions');
      if (refreshSuggestions) {
        refreshSuggestions.onclick = () => loadSuggestions();
      }

      // Create contest form
      const startNow = document.getElementById('startNow');
      const startScheduled = document.getElementById('startScheduled');
      if (startNow) startNow.onclick = () => { state.startMode = 'now'; render(); };
      if (startScheduled) startScheduled.onclick = () => { state.startMode = 'scheduled'; render(); };

      // Tokenomics toggle handler
      const tokenomicsToggle = document.getElementById('tokenomicsToggle');
      if (tokenomicsToggle) {
        tokenomicsToggle.onchange = async (e) => {
          const wantsDisable = !e.target.checked;

          // Dev wallet can toggle freely
          if (isDevWallet(state.userAddress)) {
            state.tokenomicsEnabled = e.target.checked;
            if (!state.tokenomicsEnabled) {
              state.minTradeVolume = '0';
            } else {
              state.minTradeVolume = '10'; // Reset to default
            }
            render();
            return;
          }

          // Regular users must pay 0.001 ETH to disable
          if (wantsDisable) {
            const confirmed = confirm('üí∞ Disable Tokenomics?\n\nThis will remove all trading volume requirements.\n\nCost: 0.001 ETH\n\nProceed?');
            if (!confirmed) {
              e.target.checked = true; // Revert toggle
              return;
            }

            try {
              // Send 0.001 ETH to treasury
              const ethProvider = window.activeEthProvider || window.ethereum;
              if (!ethProvider) {
                showToast('No wallet connected!', 'error');
                e.target.checked = true;
                return;
              }

              const provider = new ethers.providers.Web3Provider(ethProvider);
              const signer = provider.getSigner();
              const fee = ethers.utils.parseEther('0.001');

              showToast('Sending 0.001 ETH fee... Confirm in wallet!', 'info');

              const tx = await signer.sendTransaction({
                to: CONFIG.CONTRACTS.treasury,
                value: fee
              });

              showToast('Transaction submitted! Waiting for confirmation...', 'info', 10000);
              await tx.wait();

              state.tokenomicsEnabled = false;
              state.minTradeVolume = '0';
              showToast('Tokenomics disabled! You can now create contests without volume requirements.', 'success');
              render();
            } catch (error) {
              console.error('Fee payment error:', error);
              showToast('Fee payment failed: ' + error.message, 'error');
              e.target.checked = true; // Revert toggle
            }
          } else {
            // Enabling is free
            state.tokenomicsEnabled = true;
            state.minTradeVolume = '10'; // Reset to default
            render();
          }
        };
      }

      // Custom token checkbox handler
      const useCustomToken = document.getElementById('useCustomToken');
      if (useCustomToken) {
        useCustomToken.onchange = (e) => {
          const customSection = document.getElementById('customTokenSection');
          if (e.target.checked) {
            customSection?.classList.remove('hidden');
          } else {
            customSection?.classList.add('hidden');
            // Reset to default NEYNARTODES
            state.tokenAddress = CONFIG.CONTRACTS.neynartodes;
            state.tokenTicker = 'NEYNARTODES';
            state.tokenImage = '';
            state.tokenSearch = '';
            state.minTradeVolume = '10'; // Reset volume
          }
          render();
        };
      }

      const prizeTokenSearch = document.getElementById('prizeTokenSearch');
      if (prizeTokenSearch) {
        prizeTokenSearch.oninput = (e) => {
          state.prizeTokenSearch = e.target.value;
          state.showPrizeTokenSuggestions = e.target.value.length >= 2;
          // Don't call render() - let dropdown stay open and update via direct DOM manipulation
          updatePrizeTokenDropdown();
        };
        prizeTokenSearch.onfocus = (e) => {
          if (e.target.value.length >= 2) {
            state.showPrizeTokenSuggestions = true;
            updatePrizeTokenDropdown();
          }
        };
      }

      const tokenSearch = document.getElementById('tokenSearch');
      if (tokenSearch) {
        tokenSearch.oninput = (e) => {
          state.tokenSearch = e.target.value;
          state.showTokenSuggestions = e.target.value.length >= 2;
          // Don't call render() - let dropdown stay open and update via direct DOM manipulation
          updateTokenDropdown();
        };
        tokenSearch.onfocus = (e) => {
          if (e.target.value.length >= 2) {
            state.showTokenSuggestions = true;
            updateTokenDropdown();
          }
        };
      }

      // Form inputs
      const startDate = document.getElementById('startDate');
      const endDate = document.getElementById('endDate');
      const durationHours = document.getElementById('durationHours');
      const durationMinutes = document.getElementById('durationMinutes');
      const castHash = document.getElementById('castHash');
      const minLikes = document.getElementById('minLikes');
      const minRecasts = document.getElementById('minRecasts');
      const minReplies = document.getElementById('minReplies');
      const customMessage = document.getElementById('customMessage');
      const prizeTokenAmount = document.getElementById('prizeTokenAmount');
      const minTradeVolume = document.getElementById('minTradeVolume');

      if (startDate) startDate.onchange = (e) => { state.startDate = e.target.value; render(); };
      if (endDate) endDate.onchange = (e) => { state.endDate = e.target.value; };
      if (durationHours) {
        durationHours.oninput = (e) => {
          state.durationHours = e.target.value;
        };
        durationHours.onchange = (e) => {
          state.durationHours = e.target.value;
          render();
        };
        durationHours.onblur = () => { render(); };
      }
      if (durationMinutes) {
        durationMinutes.oninput = (e) => {
          state.durationMinutes = e.target.value;
        };
        durationMinutes.onchange = (e) => {
          state.durationMinutes = e.target.value;
          render();
        };
        durationMinutes.onblur = () => { render(); };
      }
      if (castHash) castHash.oninput = (e) => { state.castHash = e.target.value; };
      if (minLikes) minLikes.oninput = (e) => { state.minLikes = e.target.value; };
      if (minRecasts) minRecasts.oninput = (e) => { state.minRecasts = e.target.value; };
      if (minReplies) minReplies.oninput = (e) => { state.minReplies = e.target.value; };
      if (customMessage) customMessage.oninput = (e) => { state.customMessage = e.target.value; };
      if (prizeTokenAmount) prizeTokenAmount.oninput = (e) => { state.prizeTokenAmount = e.target.value; };
      if (minTradeVolume) minTradeVolume.oninput = (e) => { state.minTradeVolume = e.target.value; };

      const launchButton = document.getElementById('launchButton');
      if (launchButton) {
        launchButton.onclick = async () => {
          try {
            console.log('üîò Launch button clicked');

            // Show status in UI since alerts don't work in Warpcast
            const statusDiv = document.getElementById('launchStatus');
            if (statusDiv) statusDiv.textContent = 'Step 1: Launch clicked...';

            // Check if dev wallet (unlimited contest launches)
            const isDev = isDevWallet(state.userAddress);

          // Check if user already launched a contest today (skip for dev wallet)
          if (!isDev) {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

            if (state.lastLaunchDate) {
              const lastLaunch = new Date(state.lastLaunchDate);
              const lastLaunchDay = new Date(lastLaunch.getFullYear(), lastLaunch.getMonth(), lastLaunch.getDate());

              if (today.getTime() === lastLaunchDay.getTime()) {
                showToast('Daily Contest Limit! You can only launch 1 contest per day. Try again tomorrow!', 'warning');
                return;
              }
            }
          }

          // Validate duration
          const hours = parseInt(state.durationHours) || 0;
          const minutes = parseInt(state.durationMinutes) || 0;
          const totalMinutes = hours * 60 + minutes;

          if (totalMinutes < 1) {
            showToast('Contest duration must be at least 1 minute!', 'error');
            return;
          }

          // Validate scheduled start date
          if (state.startMode === 'scheduled' && !state.startDate) {
            showToast('Please set contest start date!', 'error');
            return;
          }

          if (!state.prizeTokenAddress || !state.prizeTokenAmount) {
            showToast('Please select a prize token and enter the amount!', 'error');
            return;
          }

          // Cast hash is ALWAYS required
          if (!state.castHash) {
            showToast('Cast Required! Post your contest announcement on Warpcast first, then paste the URL.', 'warning');
            return;
          }

          // Extract and validate cast hash
          const extractedHash = extractCastHash(state.castHash);
          if (!extractedHash) {
            showToast('Invalid cast URL/hash format. Please enter a valid Warpcast or Farcaster URL.', 'error');
            return;
          }

          // Validate cast exists (pass raw input for short hash resolution from farcaster.xyz)
          if (statusDiv) statusDiv.textContent = 'Step 2: Validating cast...';
          const castValidation = await validateCast(extractedHash, state.castHash);
          if (!castValidation.valid) {
            if (statusDiv) statusDiv.textContent = '‚ùå Cast validation failed: ' + castValidation.error;
            return;
          }

          // Check if this is the user's own cast (required for leaderboard integrity)
          if (!castValidation.isOwnCast && !isDev) {
            if (statusDiv) statusDiv.textContent = '‚ùå Not your cast! Must be your own post.';
            return;
          }

          if (statusDiv) statusDiv.textContent = 'Step 3: Cast verified ‚úì Preparing transaction...';

          // Store the validated hash (use resolved full hash if available)
          state.castHash = castValidation.hash || extractedHash;

          // Volume requirement validation
          const prizeAmount = parseFloat(state.prizeTokenAmount) || 0;
          const volumeReq = parseFloat(state.minTradeVolume) || 0;
          const isCustomToken = state.tokenAddress && state.tokenAddress.toLowerCase() !== CONFIG.CONTRACTS.neynartodes.toLowerCase();

          if (isCustomToken) {
            // Custom token: volume must be <= prize amount
            if (volumeReq > prizeAmount) {
              showToast(`Volume requirement cannot exceed prize amount (${prizeAmount} ${state.prizeTokenTicker})`, 'error');
              return;
            }
          } else {
            // Default NEYNARTODES: fixed cap at $10
            if (volumeReq > 10) {
              showToast('Volume requirement cannot exceed $10 for NEYNARTODES!', 'error');
              return;
            }
          }

          // Ensure token address defaults to NEYNARTODES if not set
          if (!state.tokenAddress) {
            state.tokenAddress = CONFIG.CONTRACTS.neynartodes;
            state.tokenTicker = 'NEYNARTODES';
          }

          // Calculate end time
          let startTime, endTime;
          if (state.startMode === 'scheduled') {
            startTime = new Date(state.startDate);
            endTime = new Date(startTime.getTime() + totalMinutes * 60 * 1000);
          } else {
            startTime = new Date();
            endTime = new Date(startTime.getTime() + totalMinutes * 60 * 1000);
          }

          // Record this launch
          state.lastLaunchDate = new Date();

          // Add to upcoming contests
          const newContest = {
            id: Date.now(),
            contestId: null, // Will be set after on-chain tx
            host: state.userAddress,
            hostUser: state.userProfile ? {
              fid: state.userProfile.fid,
              username: state.userProfile.username,
              displayName: state.userProfile.displayName,
              pfpUrl: state.userProfile.pfpUrl
            } : null,
            prize: state.prizeType === 'token' ? `${state.prizeTokenAmount} ${state.prizeTokenTicker}` : `NFT #${state.prizeNftId}`,
            startTime: startTime,
            endTime: endTime,
            duration: `${hours}h ${minutes}m`,
            socialEnabled: state.socialEnabled,
            // Token is only enabled if tokenomics is enabled AND tokenEnabled is true
            tokenEnabled: state.tokenomicsEnabled && state.tokenEnabled,
            // Entry requirements
            requireRecast: parseInt(state.minRecasts) > 0,
            requireLike: parseInt(state.minLikes) > 0,
            requireReply: parseInt(state.minReplies) > 0,
            // Volume is locked at $10 for NEYNARTODES token, otherwise use user input
            volumeRequirement: state.tokenomicsEnabled && state.tokenEnabled ? (
              state.tokenAddress.toLowerCase() === CONFIG.CONTRACTS.neynartodes.toLowerCase()
                ? 10
                : parseFloat(state.minTradeVolume) || 0
            ) : 0,
            tokenRequirementSymbol: state.tokenomicsEnabled && state.tokenEnabled ? state.tokenTicker : null,
            status: 0, // Active
            participantCount: 0
          };

          // Launch contest on ContestEscrow contract
          // Contest is only added to state AFTER successful on-chain tx (inside launchContestOnChain)
          if (statusDiv) statusDiv.textContent = 'Step 4: Calling contract...';
          await launchContestOnChain(newContest, totalMinutes * 60);

          } catch (error) {
            console.error('‚ùå Launch button error:', error);
            const statusDiv = document.getElementById('launchStatus');
            if (statusDiv) statusDiv.textContent = '‚ùå Error: ' + (error.message || error);
          }
        };
      }

      // Close dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        const prizeTokenSearch = document.getElementById('prizeTokenSearch');
        const tokenSearch = document.getElementById('tokenSearch');

        // Close prize token dropdown if clicking outside
        if (prizeTokenSearch && !prizeTokenSearch.parentElement.contains(e.target)) {
          state.showPrizeTokenSuggestions = false;
          updatePrizeTokenDropdown();
        }

        // Close tokenomics dropdown if clicking outside
        if (tokenSearch && !tokenSearch.parentElement.contains(e.target)) {
          state.showTokenSuggestions = false;
          updateTokenDropdown();
        }
      });
    }

    // ContestEscrow ABI for creating contests
    const CONTEST_ESCROW_ABI = [
      'function createContestETH(uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function createContestERC20(address _prizeToken, uint256 _prizeAmount, uint256 _duration, string calldata _castId, address _tokenRequirement, uint256 _volumeRequirement) external payable returns (uint256 contestId)',
      'function getContest(uint256 _contestId) external view returns (address host, address prizeToken, uint256 prizeAmount, uint256 startTime, uint256 endTime, string memory castId, address tokenRequirement, uint256 volumeRequirement, uint8 status, address winner)',
      'function customTokenFee() external view returns (uint256)',
      'function defaultToken() external view returns (address)',
      'event ContestCreated(uint256 indexed contestId, address indexed host, address prizeToken, uint256 prizeAmount, uint256 endTime, string castId)'
    ];

    const ERC20_ABI = [
      'function approve(address spender, uint256 amount) external returns (bool)',
      'function allowance(address owner, address spender) external view returns (uint256)',
      'function balanceOf(address account) external view returns (uint256)',
      'function decimals() external view returns (uint8)'
    ];

    // Launch contest on ContestEscrow contract
    async function launchContestOnChain(contest, durationSeconds) {
      const statusDiv = document.getElementById('launchStatus');
      try {
        console.log('üöÄ launchContestOnChain() called');
        if (statusDiv) statusDiv.textContent = 'Step 5: Getting wallet provider...';

        // Use the stored provider (Farcaster or MetaMask)
        const ethProvider = window.activeEthProvider || window.ethereum;
        if (!ethProvider) {
          if (statusDiv) statusDiv.textContent = '‚ùå No wallet provider found!';
          return;
        }

        if (statusDiv) statusDiv.textContent = 'Step 6: Getting account from provider...';

        // For smart wallets, get address directly from provider first
        let signerAddress;
        try {
          const accounts = await ethProvider.request({ method: 'eth_accounts' });
          signerAddress = accounts[0];
          if (statusDiv) statusDiv.textContent = 'Step 6b: Got address: ' + signerAddress.slice(0,10) + '...';
        } catch (e) {
          if (statusDiv) statusDiv.textContent = 'Step 6b ERROR: ' + e.message;
          throw e;
        }

        if (statusDiv) statusDiv.textContent = 'Step 7: Creating ethers provider/signer...';
        const provider = new ethers.providers.Web3Provider(ethProvider);
        const signer = provider.getSigner(signerAddress);
        if (statusDiv) statusDiv.textContent = 'Step 7b: Signer ready for ' + signerAddress.slice(0,10) + '...';

        if (statusDiv) statusDiv.textContent = 'Step 7c: Creating contract...';

        // Use shared rpcProvider for reading contract data (avoids smart wallet issues)
        const contestEscrowRead = new ethers.Contract(
          CONFIG.CONTRACTS.contestEscrow,
          CONTEST_ESCROW_ABI,
          rpcProvider
        );

        // Contract with signer for transactions
        const contestEscrow = new ethers.Contract(
          CONFIG.CONTRACTS.contestEscrow,
          CONTEST_ESCROW_ABI,
          signer
        );
        console.log('   ContestEscrow contract:', CONFIG.CONTRACTS.contestEscrow);

        if (statusDiv) statusDiv.textContent = 'Step 7d: Reading contract config...';

        // Get custom token fee and default token (use read-only provider)
        const customTokenFee = await contestEscrowRead.customTokenFee();
        const defaultToken = await contestEscrowRead.defaultToken();
        console.log('   Custom token fee:', ethers.utils.formatEther(customTokenFee), 'ETH');
        console.log('   Default token:', defaultToken);

        // Determine if we need to pay custom token fee
        const tokenRequirement = state.tokenEnabled ? state.tokenAddress : defaultToken;
        const isCustomToken = tokenRequirement.toLowerCase() !== defaultToken.toLowerCase();
        console.log('   Token requirement:', tokenRequirement);
        console.log('   Is custom token:', isCustomToken);

        // Sanitize volume requirement - ensure valid number
        let volumeRequirement = ethers.BigNumber.from(0);
        if (state.tokenomicsEnabled && state.tokenEnabled && state.minTradeVolume) {
          try {
            // For NEYNARTODES, lock at $10
            if (state.tokenAddress.toLowerCase() === CONFIG.CONTRACTS.neynartodes.toLowerCase()) {
              volumeRequirement = ethers.utils.parseEther('10');
            } else {
              // Clean the input - remove any invalid chars and limit decimals
              const cleanVolume = parseFloat(state.minTradeVolume).toFixed(18).replace(/\.?0+$/, '');
              if (cleanVolume && !isNaN(parseFloat(cleanVolume))) {
                volumeRequirement = ethers.utils.parseEther(cleanVolume);
              }
            }
          } catch (e) {
            console.error('Invalid volume format:', e);
            volumeRequirement = ethers.BigNumber.from(0);
          }
        }
        console.log('   Volume requirement:', ethers.utils.formatEther(volumeRequirement));
        console.log('   Tokenomics enabled:', state.tokenomicsEnabled);

        // Cast ID - validated cast hash from user input (REQUIRED)
        // Encode social requirements into castId: "castHash|R1L0P1" format
        // R = recast required (1 if minRecasts > 0), L = like required, P = reply required
        const reqRecast = parseInt(state.minRecasts) > 0 ? '1' : '0';
        const reqLike = parseInt(state.minLikes) > 0 ? '1' : '0';
        const reqReply = parseInt(state.minReplies) > 0 ? '1' : '0';

        // VALIDATION: At least one social requirement must be enabled
        if (reqRecast === '0' && reqLike === '0' && reqReply === '0') {
          console.error('‚ùå No social requirements enabled');
          showToast('At least one social requirement (Recast, Like, or Reply) must be enabled!', 'error');
          return;
        }

        const requirementsCode = `R${reqRecast}L${reqLike}P${reqReply}`;
        const castId = `${state.castHash}|${requirementsCode}`;
        console.log('   Cast ID to send (with requirements):', castId);
        console.log('   Requirements encoded: Recast=' + reqRecast + ', Like=' + reqLike + ', Reply=' + reqReply);
        if (!state.castHash || !state.castHash.startsWith('0x')) {
          console.error('‚ùå Invalid cast hash - empty or doesnt start with 0x');
          showToast('Invalid cast hash. Please start over and enter a valid cast URL/hash.', 'error');
          return;
        }

        let tx;

        if (state.prizeType === 'token') {
          // Check if prize is ETH (address(0) or WETH)
          const isETHPrize = state.prizeTokenAddress.toLowerCase() === '0x0000000000000000000000000000000000000000' ||
                            state.prizeTokenAddress.toLowerCase() === '0x4200000000000000000000000000000000000006'; // WETH on Base

          console.log('   Prize type: token');
          console.log('   Is ETH prize:', isETHPrize);
          console.log('   Prize token ticker:', state.prizeTokenTicker);

          if (isETHPrize || state.prizeTokenTicker === 'ETH') {
            // ETH prize - call createContestETH
            // Sanitize prize amount
            const cleanPrize = parseFloat(state.prizeTokenAmount).toFixed(18).replace(/\.?0+$/, '');
            if (!cleanPrize || isNaN(parseFloat(cleanPrize))) {
              showToast('Invalid prize amount. Please enter a valid number.', 'error');
              return;
            }
            const prizeAmount = ethers.utils.parseEther(cleanPrize);
            const totalValue = isCustomToken ? prizeAmount.add(customTokenFee) : prizeAmount;

            console.log('üìù Calling createContestETH with:');
            console.log('   _duration:', durationSeconds);
            console.log('   _castId:', castId);
            console.log('   _tokenRequirement:', tokenRequirement);
            console.log('   _volumeRequirement:', volumeRequirement.toString());
            console.log('   value (ETH):', ethers.utils.formatEther(totalValue));

            if (statusDiv) statusDiv.textContent = 'Step 8: Building transaction...';

            // Encode the function call
            const iface = new ethers.utils.Interface(CONTEST_ESCROW_ABI);
            const txData = iface.encodeFunctionData('createContestETH', [
              durationSeconds,
              castId,
              tokenRequirement,
              volumeRequirement
            ]);

            if (statusDiv) statusDiv.textContent = 'Step 8b: Sending transaction...';
            console.log('‚è≥ Waiting for wallet confirmation...');

            // Try eth_sendTransaction first (smart wallets), fall back to ethers signer (EOA)
            try {
              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [{
                  from: signerAddress,
                  to: CONFIG.CONTRACTS.contestEscrow,
                  value: '0x' + totalValue.toBigInt().toString(16),
                  data: txData
                }]
              });
              tx = { hash: txHash };
              if (statusDiv) statusDiv.textContent = 'Step 9: TX sent! Hash: ' + txHash.slice(0,15) + '...';
              console.log('‚úÖ Wallet confirmed (smart wallet)! TX:', txHash);
            } catch (txError) {
              // If eth_sendTransaction fails, try ethers.js signer (EOA wallets)
              if (txError.message?.includes('unsupported') || txError.message?.includes('not supported')) {
                console.log('Smart wallet method failed, trying EOA signer...');
                if (statusDiv) statusDiv.textContent = 'Step 8c: Trying EOA signer...';
                try {
                  tx = await contestEscrow.createContestETH(
                    durationSeconds,
                    castId,
                    tokenRequirement,
                    volumeRequirement,
                    { value: totalValue }
                  );
                  if (statusDiv) statusDiv.textContent = 'Step 9: TX sent! Hash: ' + tx.hash.slice(0,15) + '...';
                  console.log('‚úÖ Wallet confirmed (EOA)! TX:', tx.hash);
                } catch (eoaError) {
                  if (statusDiv) statusDiv.textContent = '‚ùå TX Error: ' + (eoaError.message || eoaError).slice(0, 50);
                  console.error('EOA TX Error:', eoaError);
                  throw eoaError;
                }
              } else {
                if (statusDiv) statusDiv.textContent = '‚ùå TX Error: ' + (txError.message || txError).slice(0, 50);
                console.error('TX Error:', txError);
                throw txError;
              }
            }
          } else {
            // ERC20 prize - need to approve then call createContestERC20
            if (statusDiv) statusDiv.textContent = 'Step 8: Preparing ERC20 prize...';

            // Get decimals using read-only provider
            const prizeTokenRead = new ethers.Contract(state.prizeTokenAddress, ERC20_ABI, rpcProvider);
            let decimals;
            try {
              decimals = await prizeTokenRead.decimals();
            } catch {
              decimals = 18; // Default to 18 decimals
            }

            // Sanitize prize amount - limit to token's decimal places
            const cleanPrize = parseFloat(state.prizeTokenAmount).toFixed(decimals).replace(/\.?0+$/, '');
            if (!cleanPrize || isNaN(parseFloat(cleanPrize))) {
              if (statusDiv) statusDiv.textContent = '‚ùå Invalid prize amount';
              return;
            }
            const prizeAmount = ethers.utils.parseUnits(cleanPrize, decimals);

            // Check allowance using read-only provider
            if (statusDiv) statusDiv.textContent = 'Step 8b: Checking allowance...';
            const allowance = await prizeTokenRead.allowance(signerAddress, CONFIG.CONTRACTS.contestEscrow);

            if (allowance.lt(prizeAmount)) {
              if (statusDiv) statusDiv.textContent = 'Step 8c: Approval needed - check wallet!';

              // Encode approve function call
              const approveIface = new ethers.utils.Interface(ERC20_ABI);
              const approveData = approveIface.encodeFunctionData('approve', [
                CONFIG.CONTRACTS.contestEscrow,
                prizeAmount
              ]);

              // Try eth_sendTransaction first (smart wallets), fall back to ethers signer (EOA)
              try {
                await ethProvider.request({
                  method: 'eth_sendTransaction',
                  params: [{
                    from: signerAddress,
                    to: state.prizeTokenAddress,
                    data: approveData
                  }]
                });
              } catch (approveError) {
                // If eth_sendTransaction fails, try ethers.js signer (EOA wallets)
                if (approveError.message?.includes('unsupported') || approveError.message?.includes('not supported')) {
                  console.log('Smart wallet approve failed, trying EOA signer...');
                  const prizeToken = new ethers.Contract(state.prizeTokenAddress, ERC20_ABI, signer);
                  const approveTx = await prizeToken.approve(CONFIG.CONTRACTS.contestEscrow, prizeAmount);
                  await approveTx.wait();
                } else {
                  if (statusDiv) statusDiv.textContent = '‚ùå Approve Error: ' + (approveError.message || approveError).slice(0, 50);
                  throw approveError;
                }
              }

              if (statusDiv) statusDiv.textContent = 'Step 8d: Waiting for approval confirmation...';

              // Wait for approval tx to be mined
              let approved = false;
              for (let i = 0; i < 60; i++) {
                await new Promise(r => setTimeout(r, 2000));
                const newAllowance = await prizeTokenRead.allowance(signerAddress, CONFIG.CONTRACTS.contestEscrow);
                if (newAllowance.gte(prizeAmount)) {
                  approved = true;
                  break;
                }
              }
              if (!approved) {
                if (statusDiv) statusDiv.textContent = '‚ùå Approval not confirmed after 2 minutes';
                return;
              }
              if (statusDiv) statusDiv.textContent = 'Step 8e: Approval confirmed!';
            }

            const ethValue = isCustomToken ? customTokenFee : ethers.BigNumber.from(0);

            console.log('üìù Calling createContestERC20 with:');
            console.log('   _prizeToken:', state.prizeTokenAddress);
            console.log('   _prizeAmount:', prizeAmount.toString());
            console.log('   _duration:', durationSeconds);
            console.log('   _castId:', castId);
            console.log('   _tokenRequirement:', tokenRequirement);
            console.log('   _volumeRequirement:', volumeRequirement.toString());
            console.log('   value (ETH for fee):', ethers.utils.formatEther(ethValue));

            if (statusDiv) statusDiv.textContent = 'Step 9: Sending ERC20 contest tx... Check wallet!';

            // Encode createContestERC20 function call
            const createIface = new ethers.utils.Interface(CONTEST_ESCROW_ABI);
            const createData = createIface.encodeFunctionData('createContestERC20', [
              state.prizeTokenAddress,
              prizeAmount,
              durationSeconds,
              castId,
              tokenRequirement,
              volumeRequirement
            ]);

            // Try eth_sendTransaction first (smart wallets), fall back to ethers signer (EOA)
            try {
              const txHash = await ethProvider.request({
                method: 'eth_sendTransaction',
                params: [{
                  from: signerAddress,
                  to: CONFIG.CONTRACTS.contestEscrow,
                  value: ethValue.gt(0) ? '0x' + ethValue.toBigInt().toString(16) : '0x0',
                  data: createData
                }]
              });
              tx = { hash: txHash };
              if (statusDiv) statusDiv.textContent = 'Step 10: TX sent! Hash: ' + txHash.slice(0,15) + '...';
              console.log('‚úÖ Wallet confirmed! TX:', txHash);
            } catch (txError) {
              // If eth_sendTransaction fails with "unsupported", try ethers.js signer (EOA wallets)
              if (txError.message?.includes('unsupported') || txError.message?.includes('not supported')) {
                console.log('Smart wallet createContestERC20 failed, trying EOA signer...');
                if (statusDiv) statusDiv.textContent = 'Step 9b: Trying EOA signer...';
                const contestEscrowSigner = new ethers.Contract(CONFIG.CONTRACTS.contestEscrow, CONTEST_ESCROW_ABI, signer);
                tx = await contestEscrowSigner.createContestERC20(
                  state.prizeTokenAddress,
                  prizeAmount,
                  durationSeconds,
                  castId,
                  tokenRequirement,
                  volumeRequirement,
                  { value: ethValue }
                );
                if (statusDiv) statusDiv.textContent = 'Step 10: TX sent! Hash: ' + tx.hash.slice(0,15) + '...';
                console.log('‚úÖ EOA wallet confirmed! TX:', tx.hash);
              } else {
                if (statusDiv) statusDiv.textContent = '‚ùå TX Error: ' + (txError.message || txError).slice(0, 50);
                console.error('TX Error:', txError);
                throw txError;
              }
            }
          }
        } else {
          // NFT prize - not supported in current contract
          showToast('NFT prizes are not yet supported. Please use token prizes for now.', 'error');
          return;
        }

        console.log('üì§ Transaction submitted:', tx.hash);

        // Show persistent notification while waiting
        const txUrl = `https://basescan.org/tx/${tx.hash}`;
        state.pendingTx = tx.hash;
        if (statusDiv) statusDiv.textContent = 'Waiting for confirmation...';

        // Wait for transaction receipt using read provider (since tx.wait() doesn't work with raw hashes)
        let receipt = null;
        for (let i = 0; i < 60; i++) {
          await new Promise(r => setTimeout(r, 2000));
          receipt = await rpcProvider.getTransactionReceipt(tx.hash);
          if (receipt) break;
        }

        if (!receipt) {
          if (statusDiv) statusDiv.textContent = '‚è≥ TX submitted but not confirmed yet. Check Basescan.';
          console.log('‚è≥ TX not confirmed after 2 min, but was submitted');
        } else {
          console.log('‚úÖ Transaction confirmed:', receipt.transactionHash);
          console.log('üìú Receipt logs:', receipt.logs);
        }

        // Parse contest ID from event
        let contestId = 'Unknown';

        if (receipt?.logs) {
          // Parse from raw logs using contract interface
          const parseIface = new ethers.utils.Interface(CONTEST_ESCROW_ABI);
          for (const log of receipt.logs) {
            try {
              const parsed = parseIface.parseLog(log);
              if (parsed.name === 'ContestCreated') {
                contestId = parsed.args.contestId.toString();
                console.log('‚úÖ Found contestId via interface.parseLog:', contestId);
                break;
              }
            } catch (e) {
              // Log doesn't match our event, skip
            }
          }

          // Method 2: Direct topic parsing as last resort
          if (contestId === 'Unknown' && receipt.logs.length > 0) {
            const contestCreatedTopic = ethers.utils.id('ContestCreated(uint256,address,address,uint256,uint256,string)');
            const eventLog = receipt.logs.find(log => log.topics[0] === contestCreatedTopic);
            if (eventLog && eventLog.topics[1]) {
              contestId = ethers.BigNumber.from(eventLog.topics[1]).toString();
              console.log('‚úÖ Found contestId from raw topic:', contestId);
            } else {
              console.log('‚ö†Ô∏è Could not find ContestCreated event');
              console.log('   Available logs:', receipt.logs.map(l => l.topics[0]));
            }
          }
        }

        // Clear pending tx
        state.pendingTx = null;

        // Store successful contest info
        const successInfo = {
          contestId,
          castHash: castId,
          txHash: receipt.transactionHash,
          timestamp: new Date().toISOString()
        };

        // Save to localStorage for persistence
        const launchedContests = JSON.parse(localStorage.getItem('neynartodes_launched_contests') || '[]');
        launchedContests.push(successInfo);
        localStorage.setItem('neynartodes_launched_contests', JSON.stringify(launchedContests));

        console.log('üéâ Contest created:', successInfo);

        // Track contest creation
        if (window.analytics?.track) {
          window.analytics.track('Contest Created', {
            contestId,
            prizeType: state.prizeType,
            token: state.tokenAddress,
            tokenTicker: state.tokenTicker,
            duration: state.durationHours,
            txHash: receipt?.transactionHash
          });
        }

        // Store custom message for winner announcement (if provided)
        const apiBaseUrl = window.location.origin || 'https://frame-opal-eight.vercel.app';
        if (state.customMessage && contestId !== 'Unknown') {
          try {
            await fetch(`${apiBaseUrl}/api/store-message`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contestId: contestId,
                message: state.customMessage
              })
            });
            console.log('‚úÖ Custom message stored for winner announcement');
          } catch (e) {
            console.log('‚ö†Ô∏è Could not store custom message:', e.message);
          }
        }

        // Store token price at contest creation (for fair volume calculations)
        if (contestId !== 'Unknown' && tokenRequirement !== ethers.constants.AddressZero) {
          try {
            await fetch(`${apiBaseUrl}/api/store-contest-price`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contestId: contestId,
                tokenAddress: tokenRequirement
              })
            });
            console.log('‚úÖ Token price captured at contest creation');
          } catch (e) {
            console.log('‚ö†Ô∏è Could not store token price:', e.message);
          }
        }

        // Add contest to state ONLY after successful on-chain tx
        contest.onChainId = contestId;
        contest.contestId = contestId !== 'Unknown' ? parseInt(contestId) : null;
        state.upcomingContests.push(contest);
        state.upcomingContests.sort((a, b) => a.startTime - b.startTime);

        // Update last launch date
        state.lastLaunchDate = new Date();

        // Show success screen (don't use alert - Warpcast blocks it)
        state.launchSuccess = {
          contestId,
          castHash: castId,
          txHash: tx.hash,
          txUrl
        };

        // Reset form only after successful launch
        state.prizeTokenAddress = '';
        state.prizeTokenAmount = '';
        state.prizeTokenTicker = '';
        state.prizeTokenImage = '';
        state.prizeTokenSearch = '';
        state.tokenAddress = '';
        state.tokenTicker = '';
        state.tokenImage = '';
        state.tokenSearch = '';
        state.castHash = '';
        state.customMessage = '';
        state.minLikes = '0';
        state.minRecasts = '0';
        state.minReplies = '0';
        state.minTradeVolume = '';

        render();
      } catch (error) {
        console.error('Contest launch error:', error);

        if (error.code === 4001) {
          showToast('Transaction rejected by user', 'error');
        } else if (error.message?.includes('Prize required')) {
          showToast('Prize amount required! Please enter an amount greater than 0.', 'error');
        } else if (error.message?.includes('Include custom token fee')) {
          showToast('Custom token fee required! Using a custom token costs 0.001 ETH.', 'error');
        } else if (error.message?.includes('Invalid duration')) {
          showToast('Invalid duration! Contest duration must be greater than 0.', 'error');
        } else {
          showToast('Contest launch failed: ' + (error.reason || error.message || 'Unknown error'), 'error');
        }
      }
    }

    // Feed the Neynartodes function - DEPRECATED (Clanker fees now go direct to Treasury)
    window.feedTheNeynartodes = async () => {
      showToast('This feature has been retired! Clanker fees now flow directly to Treasury.', 'info');
    };

    // Make functions globally accessible for inline onclick handlers
    window.voteForHost = voteForHost;

    // Custom token prompt functions
    window.showCustomPrizeToken = () => {
      state.showPrizeTokenSuggestions = false;
      updatePrizeTokenDropdown();

      let address = prompt('Enter the token contract address:\n\n(e.g., 0x532f27101965dd16442E59d40670FaF5eBB142E4)');
      if (!address) return;

      // Trim whitespace and normalize
      address = address.trim();

      if (!address.startsWith('0x') || address.length !== 42) {
        showToast(`Invalid address format. Must start with 0x and be 42 characters.`, 'error');
        return;
      }

      const ticker = prompt('Enter the token symbol/ticker:\n\n(e.g., BRETT, USDC, FIRKIT)');
      if (!ticker) return;

      const name = prompt('Enter the token name (optional):', ticker);

      // Add custom token to database
      const customToken = {
        name: name || ticker,
        ticker: ticker.toUpperCase(),
        address: address.toLowerCase(),
        mcap: 1000000,
        supply: 1000000000,
        image: `https://via.placeholder.com/40/9333ea/ffffff?text=${ticker[0]}`
      };

      // Save to localStorage with 1-year expiration
      saveCustomToken(customToken);

      tokenDatabase.push(customToken);

      // Auto-select the custom token
      state.prizeTokenAddress = customToken.address;
      state.prizeTokenTicker = customToken.ticker;
      state.prizeTokenImage = customToken.image;
      state.prizeTokenSearch = customToken.name;
      render();
    };

    window.showCustomToken = () => {
      state.showTokenSuggestions = false;
      updateTokenDropdown();

      let address = prompt('Enter the token contract address:\n\n(e.g., 0x532f27101965dd16442E59d40670FaF5eBB142E4)');
      if (!address) return;

      // Trim whitespace and normalize
      address = address.trim();

      if (!address.startsWith('0x') || address.length !== 42) {
        showToast(`Invalid address format. Must start with 0x and be 42 characters.`, 'error');
        return;
      }

      const ticker = prompt('Enter the token symbol/ticker:\n\n(e.g., BRETT, USDC, FIRKIT)');
      if (!ticker) return;

      const name = prompt('Enter the token name (optional):', ticker);

      // Add custom token to database
      const customToken = {
        name: name || ticker,
        ticker: ticker.toUpperCase(),
        address: address.toLowerCase(),
        mcap: 1000000,
        supply: 1000000000,
        image: `https://via.placeholder.com/40/22c55e/ffffff?text=${ticker[0]}`
      };

      // Save to localStorage with 1-year expiration
      saveCustomToken(customToken);

      tokenDatabase.push(customToken);

      // Auto-select the custom token
      state.tokenAddress = customToken.address;
      state.tokenTicker = customToken.ticker;
      state.tokenImage = customToken.image;
      state.tokenMcap = customToken.mcap;
      state.tokenSearch = customToken.name;
      render();

      // Show caps info
      const basePercent = customToken.mcap < 10000 ? 0.01 : customToken.mcap < 20000 ? 0.005 : customToken.mcap < 1000000 ? 0.0025 : customToken.mcap < 10000000 ? 0.001 : 0.0005;
      const multiplier = getBadgeMultiplier(state.userBadges);
      const maxPercent = basePercent * multiplier;
      const maxTokens = Math.floor(customToken.supply * maxPercent);

      showToast(`Custom token added! Market Cap: $${customToken.mcap.toLocaleString()}, Max: ${maxTokens.toLocaleString()} ${customToken.ticker}`, 'success');
    };

    window.selectPrizeToken = (idx) => {
      const results = searchTokens(state.prizeTokenSearch);
      if (results[idx]) {
        const token = results[idx];
        state.prizeTokenAddress = token.address;
        state.prizeTokenTicker = token.ticker;
        state.prizeTokenImage = token.image;
        state.prizeTokenSearch = token.name;
        state.showPrizeTokenSuggestions = false;
        render();
      }
    };

    window.selectToken = (idx) => {
      const results = searchTokens(state.tokenSearch);
      if (results[idx]) {
        const token = results[idx];
        state.tokenAddress = token.address;
        state.tokenTicker = token.ticker;
        state.tokenImage = token.image;
        state.tokenMcap = token.mcap;
        state.tokenSearch = token.name;
        state.showTokenSuggestions = false;

        // Track token selection
        if (window.analytics?.track) {
          window.analytics.track('Token Selected', {
            token: token.address,
            ticker: token.ticker,
            mcap: token.mcap
          });
        }

        render();

        // Show info about caps
        const basePercent = token.mcap < 10000 ? 0.01 : token.mcap < 20000 ? 0.005 : token.mcap < 1000000 ? 0.0025 : token.mcap < 10000000 ? 0.001 : 0.0005;
        const multiplier = getBadgeMultiplier(state.userBadges);
        const maxPercent = basePercent * multiplier;
        const maxTokens = Math.floor(token.supply * maxPercent);

        showToast(`Token selected! Market Cap: $${token.mcap.toLocaleString()}, Max: ${maxTokens.toLocaleString()} ${token.ticker}`, 'success');
      }
    };

    // ===== INIT =====
    // Load token list from Base on startup
    fetchBaseTokens().catch(err => console.warn('Token list fetch failed:', err));

    // Initial render
    render();

    // Re-render when Farcaster SDK loads (it's async)
    window.addEventListener('farcaster-ready', () => {
      console.log('Farcaster SDK ready event received, re-rendering...');
      render();
    });
  </script>
</body>
</html>
